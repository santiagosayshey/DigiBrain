motivation - what happens if we write code and dont test it
- x ray code thing - malfunction - cost the lives of x people
- money
- future business
- relationships with stakeholders - we don’t want to get SUED



idea - testing
- what is it? checking your code works as intended. how do we do this? we write test cases. We define the expected output, run the program and get the actual output and see if the two match..
- why is it important
	- confidence and peace of mind that our motivation is achieved
- question - what if the two dont match?


consider- bugs
- defect in source code
- caused by errors
	- human error (forgetting a semicolon)
	- misjudgement - thought a function does something, but it actually does something else
	- miscalculation — explain yourself here
- cause faults in program

idea - testing vs debugging
- testing
	- process of intentional examination to find bugs
	- used to verify and validate software requirements. 
		- tests that end in sucess show that the system operates as intended
		- on the other hand, sucessful tests expose bugs in the system to be fixed
		- verify - are we building the product right?
		- validate - we building the right product?
- debugging
	- process of responding to bugs found in examination’’

idea - static vs dynamic
- inspections are static
	- inspect code to discover problems
	- supplemented by tool based documents and code analysis (intellisense)
	- cannot check:
		- real requirments
		- non functional requirements
	- can check
		- code quality, modularity, maintainbility, flexibility
- testing is dynamic
	- exercising and observing the behaviour of the code in action
	- executed with test data and verified against expected data
- they are complementary, not opposing
mermaid diagram to show what inspects devolve into:
- spec, software architecture, uml, database schema, program
- system prototype comes off requirements spec
- testing connects to program and system prototype


example - testing a temperate gauge component
- mermaid diagram showing a state machine. inputs, outputs, is the output expected? yes - sucess, no - debug - detect in SUT - detect in specification - detect in OS, compiler, external dependencies, hardware, etc

idea - testing process
1. gather requirements
2. design test cases
3. prepare test data
4. run program with test data
5. analyse and compare the test results
6. go back to step 2
7. make test reports

consider - test case design
- goal is create a asset of tests that effectively validate validation and defect testing - why test just to test?
- exhaustive testing is important, but its very time and resource intensive. how do we do this?
	- unit testing - testing individual components in isolation. derived from programmer experience
	- integration testing - testing modules together
	- system testing - testing the entire system at once, determining if major requirements are met - the tester DOES NOT know the details of the system

idea - black box testing
- based on specified behavior
- implementation not needed to design test cases
- good to identify missing logic defects
- mermaid diagram to show black box testing (a literal black box)

idea - white box testing
- design tests based on the implemented behaviour
- can be automated
- more experience, but more rigorous
- can introduce bias, because the test maker is also usually a code developer
- mermaid diagram to show white box testing

idea - path testing
- cover this yourself

consider - code coverage
- to which the degree is the source code executed when test cases are run?
- higher coverage = less bugs
- covers
	- statements
	- branches
	- conditions

idea - partition testing
- cover this yourself

example - equivalence partions
- program accepts 4 to 10 inputs that are 5 digit integers greater than 10,000
- test values less than 10000, between 10,000 and 99,999 abd greater than 99,999
- make test cases AT and AROUND these boundaries 


idea - integration testing
- testing the collection of modules and their interfaces
- multiple ways to do this
	- top down - start at the skeleton and build outwards
	- bottom up - integration bottom components and integrate them together
	- sandwich - combo of the other two 
- we need to do this incrementally. do component 1, then 1 and 2, then 1 and 2 and 3.
	- this way, we localise errors to single components, not groups
- major difference between unit testing is that we can *integrate* things like databases, networks, file systems, etc rather than testing components by themselves



idea - system testing
 - integrate components to create sub systems
 - integrate sub sytems to create entire systems
 - usually black box and done by non developers - a dedicated “quality assurance” team does black box tests once systems have been developed