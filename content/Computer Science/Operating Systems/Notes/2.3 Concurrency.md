> [!motivation] The Need for Process Management
> In modern computing environments, **multiple programs often need to run concurrently on a single processor**. For example:
> - A user might be browsing the web while a background application checks for updates
> - An operating system needs to manage various system tasks while running user applications
> - A server must handle requests from multiple clients simultaneously
> 
> This creates a challenge: **How can a single processor efficiently handle multiple tasks**, giving each the illusion of continuous execution? 
> 
> While multi-core processors can run truly parallel tasks, even these systems often have **more active processes than available cores**. This necessitates a system for managing which code runs when, and for how long.

> [!idea] Dispatch: Switching Between Processes
> Dispatching is the **mechanism that switches the CPU from one process to another**. It involves:
> 
> - **Saving the state** of the currently running process
> - **Loading the state** of the next process to run
> - **Transferring control** to that process
> 
> Key components:
> 1. **Context Switch**: Saving and loading process states
> 2. **Dispatch Latency**: Time taken to stop one process and start another
> 
> Dispatching enables the **illusion of concurrent execution** on a single processor by rapidly switching between processes.

> [!consider] Dispatcher Control and State Management
> **How does the dispatcher gain control?**
> There are two main approaches:
> 
> 1. **Cooperative Multitasking**: Processes voluntarily yield control
> 2. **True Multitasking**: OS uses interrupts to preemptively take control
> 
> | Aspect | Cooperative Multitasking | True Multitasking |
> |--------|--------------------------|-------------------|
> | Mechanism | Processes call yield() or make blocking system calls | Hardware interrupts (timer, I/O) and software interrupts (system calls, exceptions) |
> | Strengths | - Simple implementation<br>- Low overhead<br>- Predictable switching points | - Better responsiveness<br>- Fairer CPU allocation<br>- Can handle misbehaving processes |
> | Weaknesses | - Vulnerable to poorly designed processes<br>- Poor responsiveness<br>- One process can monopolize CPU | - Higher overhead<br>- More complex implementation<br>- Potential for race conditions |
> 
> **What must be saved and restored?**
> - CPU registers (Program Counter, Stack Pointer, general-purpose registers)
> - Process state information
> - Memory management data
> - I/O status


> [!example] Dispatch in Action
> Consider two processes: A (text editor) and B (web browser)
> 
> 1. Process A is running
> 2. Dispatcher decides to switch to B
> 3. Dispatcher **saves A's state** (registers, program counter, etc.)
> 4. Dispatcher **loads B's previously saved state**
> 5. Execution resumes with Process B
> 
> This happens many times per second, creating the illusion of simultaneous execution.

> [!idea] Scheduling: Deciding Which Process Runs Next
> Scheduling is the **strategy used to determine which process should be dispatched to run next**. It involves:
> 
> - Maintaining a **queue of ready-to-run processes**
> - **Selecting the next process** based on a scheduling algorithm
> - **Balancing system objectives** (e.g., fairness, throughput, response time)
> 
> Key concepts:
> 1. **Scheduling Algorithms**: Methods for selecting the next process (e.g., Round Robin, Priority Scheduling)
> 2. **Preemption**: Ability to interrupt a running process to schedule another
> 
> Scheduling aims to **optimize system performance and ensure fair allocation** of CPU time among processes.

> [!example] Scheduling in Practice
> Consider three processes: A, B, and C, with a Round Robin scheduler
> 
> 1. Scheduler **starts with A**, gives it a time slice
> 2. After time slice expires, **A is preempted, B is scheduled**
> 3. B runs for its time slice, then **C is scheduled**
> 4. After C's time slice, the **cycle repeats with A**
> 
> This ensures each process gets regular CPU time, preventing any single process from monopolizing the processor.

