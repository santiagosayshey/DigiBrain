> [!consider] CPU Registers in System Calls
> Registers are small, fast storage locations **within the CPU used for quick data access** and manipulation during program execution.
> 
> In system calls, registers play crucial roles:
> - Passing system call numbers and arguments
> - Storing return values
> - Maintaining program state during mode switches
> 
> Key registers in x86 architecture:
> 
> | Technical Name | Register | Purpose in System Calls |
> |----------------|----------|-------------------------|
> | Accumulator    | EAX      | System call number, return value |
> | Base           | EBX      | 1st argument |
> | Counter        | ECX      | 2nd argument |
> | Data           | EDX      | 3rd argument |
> | Source Index   | ESI      | 4th argument |
> | Destination Index | EDI   | 5th argument |
> | Base Pointer   | EBP      | Frame pointer (stack management) |
> | Stack Pointer  | ESP      | Top of stack |
> 
> During a system call:
> 1. User mode sets Accumulator (EAX) with syscall number
> 2. Arguments loaded into other registers or pushed onto stack
> 3. Kernel accesses these registers to perform requested operation
> 4. Kernel places return value in Accumulator (EAX) before returning to user mode
> 
> This register usage ensures efficient data transfer between user and kernel modes.

> [!example] Common x86 Assembly Instructions
> | Instruction | Syntax | Description | Example |
> |-------------|--------|-------------|---------|
> | movl | `movl <source>, <destination>` | Moves a 32-bit value between registers or memory | `movl $5, %eax` moves the value 5 into EAX register |
> | push | `push <source>` | Pushes a value onto the stack | `push %ebx` pushes the value in EBX onto the stack |
> | pop | `pop <destination>` | Removes the top value from the stack | `pop %ecx` pops the top stack value into ECX |
> | call | `call <function>` | Calls a function, pushing the return address onto the stack | `call printf` calls the printf function |
> | ret | `ret` | Returns from a function call | `ret` returns to the calling function |
> | int | `int <interrupt number>` | Generates a software interrupt | `int $0x80` generates interrupt 0x80 (used for system calls in Linux) |
> | jmp | `jmp <label>` | Unconditional jump to a memory address | `jmp loop_start` jumps to the loop_start label |
> | cmp | `cmp <operand1>, <operand2>` | Compares two values, setting flags | `cmp %eax, %ebx` compares EAX and EBX |
> | add | `add <source>, <destination>` | Adds the source to the destination | `add $1, %ecx` increments ECX by 1 |
> 
> **Register Prefixes:**
> - `%` denotes a register (e.g., `%eax`, `%ebx`)
> - `$` denotes an immediate value (e.g., `$5`, `$0x80`)
> 
> **Memory Access:**
> - `()` used for indirect addressing (e.g., `(%esp)` accesses memory at the address in ESP)
> - Offset can be added: `4(%esp)` accesses memory at ESP + 4
> 
> **Example: System Call Setup**
> ```x86asm
> movl $4, %eax    # System call number for write()
> movl $1, %ebx    # File descriptor (1 for stdout)
> movl $msg, %ecx  # Pointer to the message
> movl $13, %edx   # Message length
> int $0x80        # Trigger system call
> ```
> This example sets up registers for a write() system call and then triggers it using the int instruction.
