
> [!motivation] Automation
> The evolution of computing systems reflects a drive towards automation, aiming to increase efficiency and reduce human intervention:
> 
> - **Switchboard Era**: 
>   - Operators manually connected calls by plugging wires into switchboards
>   - Limited scalability due to human cognitive and physical constraints
> 
> - **Early Computer Systems**:
>   - Operators manually loaded programs and data using punch cards or paper tape
>   - Managed system resources (memory, CPU time, I/O devices) by hand
>   - Inefficient use of expensive hardware as systems idled between tasks
> 
> - **Need for Automation**:
>   - Growing complexity and demand for computing power
>   - Requirement for faster task switching and resource allocation
>   - Desire to maximize hardware utilization
> 
> This progression highlights the need for **a system that can automate resource management, task scheduling, and system control** - laying the groundwork for the development of operating systems.


> [!idea] Operating Systems: The Computer's Manager
> An operating system (OS) is software that **manages computer hardware and software resources**, providing common services for computer programs.
> 
> Key functions:
> - Resource management: **Allocates** CPU time, memory, storage, and I/O devices
> - Process management: **Schedules** and coordinates running programs
> - Memory management: **Controls memory** allocation and deallocation
> - File system management: Organizes and **controls access** to stored data
> - User interface: Provides means for users to **interact** with the computer
> 
> Purpose:
> - **Abstracts hardware** complexity from users and applications
> - Enables efficient use of computer resources
> - Provides a stable, consistent environment for running applications
> - Ensures security and separation between users and processes
> 
> **Visualise**: An OS functions like a skilled **orchestra conductor, coordinating various components** (instruments) to work harmoniously, managing resources (musicians' time and energy), and interpreting between the score (user inputs) and the performance (computer operations).

> [!consider] The Necessity of Abstraction in Computing
> Imagine if every program had to directly control all hardware components it uses. This would lead to:
> 
> - **Increased Complexity**: Even simple programs would require extensive code
> 
> With OS abstractions:
> ```python
> print("Hello, World!")
> ```
> 
> Without OS abstractions (pseudocode, greatly simplified):
> ```
> ; Set up video memory address
> MOV AX, 0xB800
> MOV ES, AX
> 
> ; Write 'Hello, World!' to video memory
> MOV DI, 0
> MOV AL, 'H'
> MOV AH, 0x07  ; White on black
> MOV [ES:DI], AX
> ; ... Repeat for each character
> 
> ; Wait for key press
> MOV AH, 0
> INT 0x16
> 
> ; Return control to system
> INT 0x20
> ```
> 
> - **Reduced Portability**: Programs would be tied to specific hardware configurations
> 
> - **Security Risks**: Direct hardware access could lead to system-wide vulnerabilities
> 
> - **Inefficient Resource Use**: Lack of centralized management could result in conflicts
> 
> - **Development Challenges**: Programmers would need deep hardware knowledge for every task
> 
> Operating systems solve these issues by providing layers of abstraction, allowing developers to focus on application logic rather than hardware intricacies.

> [!consider] The Escalating Dangers of Low-Level Programming
> As the saying goes:
> - Assembly lets you shoot yourself in the foot
> - C gives you enough rope to hang yourself
> - C++ creates a pistol, bullets, and shooting range, then lets you shoot yourself in the foot
> 
> But programming without an OS?
> - Holding an RPG aimed at your face
> - With the trigger rigged to a cheetah chasing a gazelle
> - While juggling chainsaws
> - On a unicycle
> - Balanced on a tightrope
> - Over an active volcano
> 
> Remember: With great power comes great responsibility (and potential for catastrophic system failures)!
