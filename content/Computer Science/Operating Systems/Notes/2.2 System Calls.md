> [!idea] System Calls: Bridge Between User and Kernel
> System calls are the **interface between user programs and the kernel**. They allow c**ontrolled access to privileged operations** and hardware resources.
> 
> Key aspects:
> 1. **Mechanism**: Uses special CPU instructions to switch from user to kernel mode
> 2. **Purpose**: Enables user programs to request services requiring higher privileges
> 3. **Examples**: File operations, process creation, network access
> 4. **Security**: Provides a controlled, limited entry point to kernel functionality
> 
> Process:
> 1. User program prepares system call number and arguments
> 2. CPU switches to kernel mode
> 3. Kernel performs requested operation
> 4. CPU returns to user mode with result

> [!example] System Call Process: `read()`
> Let's walk through how a process P calls the `read()` system call:
> 
> 1. **C Code in User Space**:
>    ```c
>    char buffer[100];
>    int fd = 0;  // file descriptor for stdin
>    int count = 100;
>    int bytes_read = read(fd, buffer, count);
>    ```
> 
> 2. **Process P in User Mode**:
>    - P can't access `read()` directly due to user mode restrictions
>    - P creates a buffer in its own memory space for the read operation
> 
> 3. **System Call Preparation**:
>    - C library prepares for system call:
>      ```assembly
>      movl $3, %eax    ; Load system call number for read() into EAX
>      movl $0, %ebx    ; 1st arg: file descriptor (0 for stdin)
>      movl $buffer, %ecx ; 2nd arg: buffer address
>      movl $100, %edx  ; 3rd arg: count
>      int $0x80        ; Use interrupt 0x80 to enter kernel mode
>      ```
>    - `$3` is the system call number for `read()` in Linux x86
>    - `$0x80` is the standard interrupt for system calls in Linux
>    - **EAX**: 32-bit general-purpose register, used here to pass the system call number
>      - Why EAX? It's a convention in x86 Linux. EAX is chosen for its historical use as an accumulator and its position as the first general-purpose register.
> 
> 4. **Kernel's System Call Table**:
>    - Kernel maintains a table mapping system call numbers to their handlers
>    - Example structure:
>      ```c
>      void* sys_call_table[] = {
>          [0] = sys_restart_syscall,
>          [1] = sys_exit,
>          [2] = sys_fork,
>          [3] = sys_read,
>          // ... other system calls ...
>      };
>      ```
> 
> 5. **Transition to Kernel Mode**:
>    - The `int $0x80` instruction triggers a switch to kernel mode
>    - CPU now has full system access
> 
> 6. **Kernel Handling**:
>    - Kernel reads system call number from EAX (3 for `read()`)
>    - Looks up handler in `sys_call_table`
>    - Jumps to `sys_read()` function
>    - Kernel accesses user memory to fill the buffer
> 
> 7. **Return to User Mode**:
>    - After `read()` completes, kernel prepares return value
>    - Uses `iret` (return-from-interrupt) to switch back to user mode
>    - Control returns to Process P, with data in the buffer and bytes read in EAX
> 
> ![[Pasted image 20240730073149.png]]
> 
> This process demonstrates the interaction between user space, system libraries, CPU registers, and kernel space during a system call.


> [!consider]- Security Implications of System Calls
> System calls, while essential for OS functionality, present significant security challenges:
> 
> 1. **Privileged Access**:
>    - Kernel mode operations have unrestricted access to system resources
>    - Potential for unintended or malicious system-wide changes
> 
> 2. **Vulnerability Surface**:
>    - Each system call is a potential entry point for attacks
>    - Even minor flaws can lead to system-wide compromises
> 
> 3. **Input Validation**:
>    - Crucial to thoroughly verify all parameters passed from user space
>    - Risks include memory corruption, privilege escalation, and data leaks
> 
> 4. **Return State Verification**:
>    - Ensure system state after call execution aligns with expected outcomes
>    - Prevent unauthorized changes or unexpected side effects
> 
> Robust security measures and continuous auditing of system call implementations are vital to maintain system integrity and prevent exploitation.
