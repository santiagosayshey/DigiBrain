
> [!idea] Paging: A Solution to Fragmentation
> Paging is a memory management scheme that **eliminates the need for contiguous physical memory allocation**.
> 
> **Key concepts:**
> - **Divides physical memory into fixed-size blocks called "frames"**
> - Divides logical memory (process space) into same-size blocks called "pages"
> - Uses a page table to map virtual pages to physical frames
> - Allows non-contiguous allocation of physical memory
> 
> **Benefits:**
> - Eliminates external fragmentation
> - Simplifies memory allocation and deallocation
> - Enables efficient use of physical memory
> - Facilitates shared memory and memory protection
> 
> **Challenges:**
> - May introduce internal fragmentation within pages
> - Requires additional memory for page tables
> - Adds complexity to address translation process

> [!consider] Paging: The Library Analogy
> Think of paging like organizing books in a library:
> 
> - **Books** = Programs
> - **Pages of a book** = Pages of a program
> - **Library shelves** = Physical memory frames
> - **Library catalog** = Page table
> 
> In this analogy:
> - Books are split into individual pages (like programs into memory pages)
> - Pages are stored on shelves in any available slot (like pages in any available frame)
> - The catalog tells you where to find each page of a book (like the page table mapping virtual to physical addresses)
> - You can easily add or remove books without reorganizing the entire library (like allocating or freeing memory without compaction)
> 
> This system allows efficient use of shelf space and easy management of books, just as paging allows efficient use of memory and easy management of programs.

> [!example] Paging in Action
> Let's consider a simple scenario with a 32-byte process in a system with 16-byte pages/frames.
> 
> **Process memory (virtual addresses):**
> ```
> +----------------+----------------+
> |  Page 0 (0-15) |  Page 1 (16-31)|
> +----------------+----------------+
> ```
> 
> **Physical memory:**
> ```
> +----------------+----------------+----------------+----------------+
> | Frame 0 (Free) | Frame 1 (Used) | Frame 2 (Free) | Frame 3 (Used) |
> +----------------+----------------+----------------+----------------+
> ```
> 
> **Page Table:**
> ```
> Virtual Page | Physical Frame
>      0       |      2
>      1       |      0
> ```
> 
> In this example:
> - The process's Page 0 is stored in Frame 2
> - The process's Page 1 is stored in Frame 0
> - Frames 1 and 3 might be used by other processes
> 
> When the CPU needs to access address 18 (on Page 1):
> 1. It calculates: Page number = 18 / 16 = 1, Offset = 18 % 16 = 2
> 2. It looks up Page 1 in the page table, finding Frame 0
> 3. It accesses physical address: (Frame 0 * 16) + Offset = 0 * 16 + 2 = 2
> 
> This demonstrates how paging allows non-contiguous memory allocation while maintaining the illusion of contiguous addresses for the process.

