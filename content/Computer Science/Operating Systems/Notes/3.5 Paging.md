> [!idea] Paging: A Solution to Fragmentation
> Paging is a memory management scheme that **eliminates the need for contiguous physical memory allocation**.
> 
> **Key concepts and process:**
> 1. **Division of memory:**
>    - **Physical memory** is divided into fixed-size blocks called "frames". Referenced using Page Frame Number (PFN)
>    - **Logical memory** (process space) is divided into same-size blocks called "pages". Referenced using VPN (Virtual Page Number)
> 
> 2. **Allocation and page table:**
>    - When a process is created, it's assigned a single page table
>    - Process's pages are stored in any available frames, not necessarily contiguous
>    - The page table acts as an index, showing which page corresponds to which frame 
> 
> 3. **Address translation:**
>    - CPU generates virtual addresses
>    - Memory Management Unit (MMU) splits address into page number and offset
>    - Page number is used to index the page table, finding the frame number
>    - Frame number is combined with offset to get physical address
> 
> ![[Pasted image 20240813152249.png|600]]
> 
> **Benefits:**
> - Eliminates external fragmentation
> - Simplifies memory allocation and deallocation
> - Enables efficient use of physical memory
> - Facilitates shared memory and memory protection
> 
> **Challenges:**
> - May introduce internal fragmentation within pages
> - Requires additional memory for page tables
> - Adds complexity to address translation process
> 
> This system allows processes to operate as if they have contiguous memory, while physically being scattered across different frames.

> [!consider] Paging: The Library Analogy
> Think of paging like organizing books in a library:
> 
> - **Books** = Programs
> - **Pages of a book** = Pages of a program
> - **Library shelves** = Physical memory frames
> - **Library catalog** = Page table
> 
> In this analogy:
> - Books are split into individual pages (like programs into memory pages)
> - Pages are stored on shelves in any available slot (like pages in any available frame)
> - The catalog tells you where to find each page of a book (like the page table mapping virtual to physical addresses)
> - You can easily add or remove books without reorganizing the entire library (like allocating or freeing memory without compaction)
> 
> This system allows efficient use of shelf space and easy management of books, just as paging allows efficient use of memory and easy management of programs.

> [!example] Address Translation Steps
> **Scenario:** 
> System specifications:
> - Page size: 4 KB (2^12 bytes) -> This is why we use 12 in our bit operations
> - Virtual address size: 32 bits
> - Physical address size: 28 bits
> - Virtual address to translate: 0x1234567 (hexadecimal)
> - Page table base address: 0x100000
> - Page table entry size: 4 bytes
> 
> | Step | Technical Explanation | Real Example Calculation |
> |------|----------------------|---------------------------|
> | Extract Virtual Page Number from Virtual Address | Perform a right shift by 12 bits on the virtual address. We use 12 because our page size is 4 KB (2^12 bytes). This shift separates the page number from the offset. | Virtual Address: 0x1234567<br>In binary: 0001 0010 0011 0100 0101 0110 0111<br><br>Shift right by 12 bits (because 2^12 = 4096, our page size):<br>0001 0010 0011 0100 0101 0110 0111 becomes<br>0000 0000 0000 0001 0010 0011 0100<br><br>Result in hex: 0x1234<br><br>The rightmost 12 bits (0101 0110 0111) that were shifted out represent the offset within the 4 KB page. The remaining bits form the Virtual Page Number. |
> | Calculate address of Page Table Entry | Multiply the Virtual Page Number by 4 (size of each page table entry) and add to the page table base address. | PTE Address = Page Table Base + (VPN * Entry Size)<br>            = 0x100000 + (0x1234 * 4)<br>            = 0x100000 + 0x48D0<br>            = 0x1048D0 |
> | Read Page Table Entry from memory | Access the physical memory at the calculated PTE address and read the 4-byte value stored there. | Let's assume the value at 0x1048D0 is 0x7F000<br>PTE Content = 0x7F000 |
> | Extract Page Frame Number | Perform a right shift by 12 bits on the Page Table Entry. We again use 12 because our page size is 4 KB (2^12 bytes). This shift removes the flags stored in the lower bits of the PTE. | PTE Content: 0x7F000<br>In binary: 0111 1111 0000 0000 0000<br><br>Shift right by 12 bits (because 2^12 = 4096, our page size):<br>0111 1111 0000 0000 0000 becomes<br>0000 0000 0000 0111 1111<br><br>Result in hex: 0x7F<br><br>The rightmost 12 bits that were shifted out typically contain flags. The remaining bits form the Page Frame Number. |
> | Build Physical Address | 1. Left shift the Page Frame Number by 12 bits. We use 12 because we need to make room for the 12-bit offset.<br>2. Perform a bitwise OR with the offset from the original Virtual Address. | 1. Left shift PFN by 12 (because our offset is 12 bits):<br>   0x7F becomes 0x7F000<br>   (0111 1111 becomes 0111 1111 0000 0000 0000)<br><br>2. Get offset (last 12 bits of VA, because 2^12 = 4096):<br>   0x1234567 & 0xFFF = 0x567<br><br>3. Combine with bitwise OR:<br>   0x7F000 \| 0x567 = 0x7F567 |
> | Read contents of Physical Address | Use the constructed physical address to access the corresponding location in physical memory. | Read 4 bytes from physical address 0x7F567 |
> | Load into register | Copy the 4 bytes read from physical memory into a CPU register. | Move the 4 bytes read from 0x7F567 into a CPU register |

> [!consider] Paging: Further Considerations
> As you think about paging, you might wonder about several aspects:
> 
> **1. Page Size:**
> - Typically ranges from 4KB to 4MB in modern systems
> - Smaller pages:
>   - Less internal fragmentation
>   - More pages per process, larger page tables
> - Larger pages:
>   - Smaller page tables, faster translation
>   - More internal fragmentation
> - OS may support multiple page sizes (e.g., huge pages for databases)
> 
> **2. Page Table Storage:**
> - Stored in main memory
> - Each process has its own page table
> - For large address spaces, page tables can be very large
> - Solutions for large page tables:
>   - Multi-level page tables
>   - Inverted page tables
>   - Translation Lookaside Buffer (TLB) for caching translations
> 
> **3. Page Table Base Register:**
> - CPU has a register pointing to the current process's page table
> - Updated during context switches
> 
> **4. Shared Pages:**
> - Multiple processes can share read-only pages (e.g., code segments)
> - Implemented by mapping different virtual pages to the same physical frame
> 
> **5. Page Faults:**
> - What if a page isn't in memory?
> - Page fault handler loads the required page from disk
> - Enables virtual memory larger than physical memory
> 
> **6. Protection:**
> - Page table entries often include permission bits (read/write/execute)
> - Enables fine-grained memory protection
> 
> **7. Speed**
> - We need double the number of memory references per instruction,
> 
> These considerations highlight the complexity and flexibility of paging systems in modern operating systems.
