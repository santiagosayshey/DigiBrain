> [!idea] Paging: A Solution to Fragmentation
> Paging is a memory management scheme that **eliminates the need for contiguous physical memory allocation**.
> 
> **Key concepts and process:**
> 1. **Division of memory:**
>    - **Physical memory** is divided into fixed-size blocks called "frames". Referenced using Page Frame Number (PFN)
>    - **Logical memory** (process space) is divided into same-size blocks called "pages". Refeerences using VPN (Virt)
> 
> 2. **Allocation and page table:**
>    - When a process is created, it's assigned a single page table
>    - Process's pages are stored in any available frames, not necessarily contiguous
>    - The page table acts as an index, showing which page corresponds to which frame 
> 
> 3. **Address translation:**
>    - CPU generates virtual addresses
>    - Memory Management Unit (MMU) splits address into page number and offset
>    - Page number is used to index the page table, finding the frame number
>    - Frame number is combined with offset to get physical address
> 
> ![[Pasted image 20240813152249.png|600]]
> 
> **Benefits:**
> - Eliminates external fragmentation
> - Simplifies memory allocation and deallocation
> - Enables efficient use of physical memory
> - Facilitates shared memory and memory protection
> 
> **Challenges:**
> - May introduce internal fragmentation within pages
> - Requires additional memory for page tables
> - Adds complexity to address translation process
> 
> This system allows processes to operate as if they have contiguous memory, while physically being scattered across different frames.

> [!consider] Paging: The Library Analogy
> Think of paging like organizing books in a library:
> 
> - **Books** = Programs
> - **Pages of a book** = Pages of a program
> - **Library shelves** = Physical memory frames
> - **Library catalog** = Page table
> 
> In this analogy:
> - Books are split into individual pages (like programs into memory pages)
> - Pages are stored on shelves in any available slot (like pages in any available frame)
> - The catalog tells you where to find each page of a book (like the page table mapping virtual to physical addresses)
> - You can easily add or remove books without reorganizing the entire library (like allocating or freeing memory without compaction)
> 
> This system allows efficient use of shelf space and easy management of books, just as paging allows efficient use of memory and easy management of programs.


> [!example] Address Translation Process
> 
> Given:
> - Virtual memory: 4,294,967,296 bytes (2^32)
> - Physical memory: 4,194,304 bytes (2^22)
> - Page size: 4,096 bytes
> - Virtual address: 11,123,456
> 
> | Step | Explanation | Calculation |
> |------|-------------|-------------|
> | 1. Extract Virtual Page Number from Virtual Address | We divide the virtual address by the page size to get the Virtual Page Number. | Virtual Page Number = 11,123,456 / 4,096 = 2,715 |
> | 2. Calculate address of Page Table Entry | We multiply the Virtual Page Number by 4 (assuming 4-byte Page Table Entry entries) and add it to the page table base address. | Assuming page table base is 1,000,000:<br>Page Table Entry address = 1,000,000 + (2,715 * 4) = 1,010,860 |
> | 3. Read Page Table Entry from memory | We access the memory at the calculated Page Table Entry address to retrieve the Page Table Entry. | Read 4 bytes from address 1,010,860<br>(Let's assume we read: 2,310,144) |
> | 4. Extract Page Frame Number | We extract the Page Frame Number from the Page Table Entry, typically by shifting and masking. | Assuming Page Frame Number is in upper 20 bits:<br>Page Frame Number = 2,310,144 / 4,096 = 564 |
> | 5. Build Physical Address | We construct the Physical Address by combining the Page Frame Number with the offset from the original Virtual Address. | Offset = 11,123,456 % 4,096 = 2,560<br>Physical Address = (564 * 4,096) + 2,560 = 2,314,240 |
> | 6. Read contents of Physical Address | We access the physical memory at the calculated Physical Address. | Read data from physical address 2,314,240 |
> | 7. Load into register | We transfer the data read from physical memory into a CPU register. | Move data to a CPU register (e.g., EAX) |


> [!consider] Paging: Further Considerations
> As you think about paging, you might wonder about several aspects:
> 
> **1. Page Size:**
> - Typically ranges from 4KB to 4MB in modern systems
> - Smaller pages:
>   - Less internal fragmentation
>   - More pages per process, larger page tables
> - Larger pages:
>   - Smaller page tables, faster translation
>   - More internal fragmentation
> - OS may support multiple page sizes (e.g., huge pages for databases)
> 
> **2. Page Table Storage:**
> - Stored in main memory
> - Each process has its own page table
> - For large address spaces, page tables can be very large
> - Solutions for large page tables:
>   - Multi-level page tables
>   - Inverted page tables
>   - Translation Lookaside Buffer (TLB) for caching translations
> 
> **3. Page Table Base Register:**
> - CPU has a register pointing to the current process's page table
> - Updated during context switches
> 
> **4. Shared Pages:**
> - Multiple processes can share read-only pages (e.g., code segments)
> - Implemented by mapping different virtual pages to the same physical frame
> 
> **5. Page Faults:**
> - What if a page isn't in memory?
> - Page fault handler loads the required page from disk
> - Enables virtual memory larger than physical memory
> 
> **6. Protection:**
> - Page table entries often include permission bits (read/write/execute)
> - Enables fine-grained memory protection
> 
> **7. Speed**
> - We need double the number of memory references per instruction,
> 
> These considerations highlight the complexity and flexibility of paging systems in modern operating systems.
