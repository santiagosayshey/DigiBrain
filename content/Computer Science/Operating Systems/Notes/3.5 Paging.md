> [!motivation] Eliminating External Fragmentation
> In memory management, external fragmentation occurs when there is **enough total memory** to satisfy an allocation request, but the **available memory is not contiguous**. This leads to inefficient memory utilization and can prevent processes from being loaded into memory even when sufficient total memory exists.
> 
> To address this issue, we need a memory management technique that:
> - **Eliminates the requirement for contiguous memory allocation**
> - Allows segments to grow as needed without relying on adjacent free memory

> [!idea] Paging
> Paging is a memory management scheme that **divides the virtual address space into fixed-size units called pages and the physical memory into frames of the same size.**
> - Virtual address space is divided into pages of a fixed size, typically a power of 2 (e.g., 4KiB)
> - Physical memory is divided into frames of the same size as the pages
> - Instead of allocating contiguous memory to processes, individual pages are assigned to frames in physical memory
> - Pages belonging to a process do not need to be stored in adjacent frames, allowing for flexibility in memory allocation
> 
> ![[Pasted image 20240826041749.png|600]]

> [!idea] Benefits and Implications of Paging
> - **Elimination of External Fragmentation**: By allowing pages to be allocated to non-contiguous frames, paging effectively eliminates external fragmentation. The physical memory can be utilized more efficiently, as small gaps between allocated memory no longer hinder the allocation of new processes.
> 
> - **Flexibility in Memory Allocation**: Paging enables processes to grow or shrink their memory usage by allocating or deallocating individual pages. This flexibility allows for more efficient memory utilization and accommodates the dynamic memory requirements of processes.
> 
> - **Page Tables**: To keep track of the mapping between virtual pages and physical frames, a data structure called a page table is used. Each process has its own page table, which contains entries that map virtual page numbers to physical frame numbers. The page table is consulted during memory accesses to translate virtual addresses to physical addresses.

> [!consider] Translation from Virtual to Physical Addresses
> When memory is not stored contiguously in physical memory, a new **challenge** arises: **locating the next piece of memory for a process.**
> - In a paging system, each virtual address consists of a page number and an offset within the page
> - To access physical memory, the system needs to **translate the virtual address into a corresponding physical address**
> - The translation process involves **converting the virtual page number to a physical frame number and appending the offset**

> [!idea] Page Address Translation
> To translate a virtual address to a physical address, the system uses the following steps:
> 1. **Extract the Page Number**: The high-order bits of the virtual address represent the page number. The number of bits used for the page number depends on the size of the virtual address space and the page size.
> 2. **Extract the Offset**: The low-order bits of the virtual address represent the offset within the page. The number of bits used for the offset depends on the page size.
> 3. **Translate Page Number to Frame Number**: The system looks up the page number in the process's page table to find the corresponding frame number in physical memory.
> 4. **Construct Physical Address**: The physical address is constructed by concatenating the frame number obtained from the page table with the offset from the virtual address.
> 
> By performing this translation, the system can locate the physical memory location corresponding to a given virtual address, even when the pages are not stored contiguously in physical memory.

> [!example] Determining Offset Bits
> To determine the number of low-order bits needed for the offset within a page, we can use the page size. The number of offset bits is calculated as the logarithm base 2 of the page size.
> 
> | Page Size | Offset Bits |
> |-----------|-------------|
> | 16 bytes  | 4           |
> | 512 bytes | 9           |
> | 1 KB      | 10          |
> | 4 KB      | 12          |
> | 1 MB      | 20          |
> 
> For example, with a page size of 4 KB (2^12 bytes), we need 12 bits to represent the offset within a page.

> [!example] Determining Page Number Bits
> To determine the number of high-order bits needed for the page number, we consider the total number of bits in the virtual address and subtract the number of offset bits.
> 
> | Virtual Address Bits | Page Size | Page Number Bits |
> |----------------------|-----------|------------------|
> | 10                   | 16 bytes  | 6                |
> | 16                   | 512 bytes | 7                |
> | 20                   | 1 KB      | 10               |
> | 32                   | 4 KB      | 20               |
> | 32                   | 1 MB      | 12               |
> 
> For example, with a 32-bit virtual address and a page size of 4 KB, we need 20 bits to represent the page number (32 - 12 offset bits).

> [!example] Number of Virtual Pages
> Given the number of bits used for the virtual page number (VPN), we can calculate the maximum number of virtual pages in the address space using the formula: 2^(VPN bits).
> 
> | VPN Bits | Maximum Virtual Pages |
> |----------|----------------------|
> | 6        | 64                   |
> | 7        | 128                  |
> | 10       | 1,024                |
> | 12       | 4,096                |
> | 20       | 1,048,576            |
> 
> For example, with 20 bits used for the VPN, the address space can contain up to 1,048,576 virtual pages.