
> [!idea] Scheduling: Deciding Which Process Runs Next
> Scheduling is the **strategy used to determine which process should be dispatched to run next**. It involves:
> 
> - Maintaining a **queue of ready-to-run processes**
> - **Selecting the next process** based on a scheduling algorithm
> - **Balancing system objectives** (e.g., fairness, throughput, response time, turnaround time, waiting time, utilisation, overhead)
> 
> Key concepts:
> 1. **Scheduling Algorithms**: Methods for selecting the next process (e.g., Round Robin, Priority Scheduling)
> 2. **Preemption**: Ability to interrupt a running process to schedule another
> 
> Scheduling aims to **optimize system performance and ensure fair allocation** of CPU time among processes.

> [!example] General Scheduling
> Consider three processes: A, B, and C, with a Round Robin scheduler
> 
> 1. Scheduler **starts with A**, gives it a time slice
> 2. After time slice expires, **A is preempted, B is scheduled**
> 3. B runs for its time slice, then **C is scheduled**
> 4. After C's time slice, the **cycle repeats with A**
> 
> This ensures each process gets regular CPU time, preventing any single process from monopolizing the processor.

> [!idea] State Transitions in Process Scheduling
> State transitions refer to the changes in the status of a process as it moves through different stages of its lifecycle. This includes:
> 
> - **Ready State**: Process is ready to run but waiting for CPU time
> - **Running State**: Process is currently being executed by the CPU
> - **Blocked State**: Process is waiting for an event (e.g., I/O completion)
> - **Terminated State**: Process has finished execution
> 
> These transitions are crucial for efficient process management and scheduling.

> [!idea] Key Scheduling Concepts
> 
> 1. **Workload**: The set of processes that need to be scheduled
> 2. **Job**: A single unit of work that needs to be processed
> 3. **Scheduler**: The algorithm or mechanism that decides which job runs next
> 4. **Metric**: Criteria used to evaluate the performance of the scheduling algorithm (e.g., turnaround time, response time, waiting time)
>
> - **Turnaround Time**: Time from job submission to job completion
> - **Response Time**: Time from job submission to first response
> - **Waiting Time**: Total time a job spends in the ready queue
> - **Throughput**: Number of jobs completed per unit time
> - **Resource Utilization**: Percentage of time resources are busy
> - **Overhead**: Extra time consumed in managing the processes
> - **Fairness**: Equal distribution of CPU time among processes

> [!consider] Evaluating Scheduling Algorithms
> When evaluating scheduling algorithms, we consider:
> 
> - **Arrival Time**: When a job arrives in the system
> - **Run Time**: How long a job needs to run
> 
> We use various schedulers like FIFO, SJK, STCF, and RR, comparing the turnaround and response times for each job under each scheduler.
> 
> **Assumptions**:
> - Same running time for each job
> - All jobs arrive at the same time
> - No I/O operations
> - Determined run time


> [!example] Evaluating Scheduling Algorithms
> This example illustrates how different scheduling algorithms perform under various conditions.
> 
> **FIFO (First-In-First-Out)**
> - Description: Jobs executed in the order they arrive.
> - Scenario: Jobs A, B, C with run times 10, 10, 10 units, arriving simultaneously.
> ![[Pasted image 20240804232600.png]]
> 
> **FIFO with Different Running Times**
> - Removed Assumption: Jobs have the same running time.
> - Issue: Convoy Effect â€“ Short jobs wait for long jobs to complete.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units, arriving simultaneously.
> ![[Pasted image 20240804232643.png]]
> 
> **SJF (Shortest Job First)**
> - Description: Jobs executed in order of their length, shortest job first.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units, arriving simultaneously.
> - Turnaround Times: B: 10, C: 20, A: 120 units
> - Average Turnaround Time: (10 + 20 + 120) / 3 = 50 units
> 
> **SJF with Different Arrival Times**
> - Removed Assumption: All jobs arrive at the same time.
> - Issue: Smaller jobs arriving after a larger job face delays.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units. A arrives at 0, B at 10, C at 20.
> - Turnaround Times: A: 100, B: 100, C: 100 units
> - Average Turnaround Time: (100 + 100 + 100) / 3 = 100 units
> 
> **STCF (Shortest Time-to-Completion First)**
> - Description: Preempts longer jobs when shorter jobs arrive.
> - Removed Assumptions: All jobs arrive at the same time, jobs cannot be preempted.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units. A arrives at 0, B at 10, C at 20.
> - Turnaround Times: B: 10, C: 20, A: 120 units
> - Average Turnaround Time: (10 + 20 + 120) / 3 = 50 units
> 
> **STCF with I/O Operations**
> - Removed Assumption: No I/O operations.
> - Issue: Jobs may be blocked waiting for I/O, affecting scheduling decisions.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units. A arrives at 0, B at 10, C at 20. A has I/O operations.
> - Turnaround Times: B: 10, C: 20, A: 130 units (assuming 10 units of I/O wait time)
> - Average Turnaround Time: (10 + 20 + 130) / 3 = 53.33 units
> 
> **RR (Round Robin)**
> - Description: Each job gets a fixed time slice (quantum) in cyclic order.
> - Removed Assumptions: All jobs arrive at the same time, jobs cannot be preempted.
> - Issue: Overhead from frequent context switches if quantum is too small.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units. A arrives at 0, B at 10, C at 20. Quantum = 1 unit.
> - Turnaround Times: B: 19, C: 28, A: 118 units
> - Average Turnaround Time: (19 + 28 + 118) / 3 = 55 units
> 
> **RR without Preemptive Interrupts**
> - Removed Assumption: Jobs can be preempted.
> - Issue: Long-running jobs may monopolize the CPU, increasing response times for other jobs.
> - Scenario: Jobs A, B, C with run times 100, 10, 10 units. A arrives at 0, B at 10, C at 20. No preemption.
> - Turnaround Times: A: 100, B: 110, C: 120 units
> - Average Turnaround Time: (100 + 110 + 120) / 3 = 110 units

> [!summary] Comparison of Scheduling Algorithms
> - **FIFO**: Simple to implement, but can lead to poor performance with varying job lengths.
> - **SJF**: Optimal for minimizing average turnaround time when all jobs are available simultaneously, but impractical in real systems due to unknown job lengths.
> - **STCF**: Improves on SJF by allowing preemption, but may lead to starvation of longer jobs.
> - **RR**: Provides fair CPU time distribution and good response times, but may increase average turnaround time.
> 
> **Best Use Cases**:
> - **FIFO**: Suitable for batch systems where simplicity is prioritized over performance.
> - **SJF/STCF**: Ideal for systems where job lengths are known or can be estimated accurately, and minimizing average turnaround time is crucial.
> - **STCF with I/O**: Beneficial in I/O-bound systems, as it can efficiently utilize CPU time during I/O waits.
> - **RR**: Best for time-sharing systems and interactive environments where quick response times are essential.
> - **RR without Preemption**: Useful in specific real-time systems where context switching overhead must be minimized.
> 
> In practice, modern operating systems often use hybrid approaches, combining elements of multiple algorithms to balance various performance metrics and adapt to different workloads. The choice of algorithm depends on system requirements, workload characteristics, and specific performance goals.

