> [!idea] System Calls: Low-Level Mechanics
> A system call involves a complex interaction between user space, the CPU, and kernel space. Here's what happens at a low level:
> 
> 1. User space preparation
> 2. CPU mode switch
> 3. Kernel space handling
> 4. Return to user space

Certainly. I'll revise the example callout to include code blocks that illustrate each step of the low-level system call process.

> [!example] Low-Level System Call Process
> 1. **User Space Preparation**:
>    ```nasm
>    mov rax, 1        ; system call number (sys_write)
>    mov rdi, 1        ; file descriptor (stdout)
>    mov rsi, message  ; message to write
>    mov rdx, 13       ; message length
>    ```
> 
> 2. **CPU Mode Switch**:
>    ```nasm
>    syscall           ; triggers CPU mode switch
>    ```
>    At this point, the CPU:
>    - Saves user RIP to RCX and RFLAGS to R11
>    - Loads kernel RIP from IA32_LSTAR MSR
>    - Switches to kernel mode (CPL = 0)
> 
> 3. **Kernel Space Handling**:
>    ```c
>    // Simplified kernel code
>    void syscall_entry(void) {
>        save_user_registers();
>        syscall_number = regs->rax;
>        if (syscall_number < NR_syscalls)
>            syscall_table[syscall_number](regs);
>        restore_user_registers();
>    }
>    ```
> 
> 4. **Return to User Space**:
>    ```nasm
>    sysretq            ; return to user space
>    ```
>    The CPU:
>    - Restores RIP from RCX and RFLAGS from R11
>    - Switches back to user mode (CPL = 3)
> 
> After return, execution continues in user space with the next instruction.

