> [!idea] System Calls: Bridge Between User and Kernel
> System calls are the **interface between user programs and the kernel**. They allow c**ontrolled access to privileged operations** and hardware resources.
> 
> Key aspects:
> 1. **Mechanism**: Uses special CPU instructions to switch from user to kernel mode
> 2. **Purpose**: Enables user programs to request services requiring higher privileges
> 3. **Examples**: File operations, process creation, network access
> 4. **Security**: Provides a controlled, limited entry point to kernel functionality
> 
> Process:
> 1. User program prepares system call number and arguments
> 2. CPU switches to kernel mode
> 3. Kernel performs requested operation
> 4. CPU returns to user mode with result

> [!example] System Call Process: `read()`
> Let's walk through how a process P calls the `read()` system call:
> 
> 1. **Process P in User Mode**:
>    - P wants to call `read()` but can't access it directly
>    - P can only see its own memory due to user mode restrictions
> 
> 2. **System Call Preparation**:
>    - P prepares for system call using a predefined interface:
>      ```assembly
>      movl $6, %eax    ; Load system call number for read() into EAX
>      int $64          ; Trigger interrupt 64
>      ```
>    - Explanation:
>      - EAX is the 32-bit accumulator register in x86 architecture
>      - It's often used for storing function return values and, in this case, system call numbers
>      - `$6` is the index in the syscall table for `read()`
>      - `$64` is the interrupt number for system calls (on some systems)
> 
> 3. **Transition to Kernel Mode**:
>    - The `int $64` instruction causes a trap to the kernel
>    - CPU switches to kernel mode, giving full system access
>    - The kernel can now access the EAX register to determine which system call to execute
> 
> 4. **Kernel Handling**:
>    - Kernel reads the system call number from EAX (6 in this case)
>    - Looks up this number in its syscall table
>    - Jumps to the appropriate handler for `read()`
>    - Kernel can now access user memory to fill the user buffer
> 
> 5. **Return to User Mode**:
>    - After `read()` operation completes, kernel prepares to return
>    - Uses a return-from-trap instruction to switch back to user mode
>    - Control returns to Process P, with the result of `read()` typically stored back in EAX
> 
> This process allows safe, controlled access to privileged operations while maintaining separation between user and kernel space. Using EAX to pass the system call number is efficient as it's quickly accessible by both user and kernel mode code.

This version includes an explanation of the EAX register, highlighting its role in x86 architecture and its use in system calls. It clarifies why EAX is used for passing the system call number and receiving the return value.

