> [!idea] System Calls: High-Level Overview
> A system call is a programmatic way for an application to request a service from the kernel of the operating system. The process involves:
> 
> 1. Application prepares system call arguments
> 2. Application invokes the system call
> 3. Control transfers to the kernel
> 4. Kernel performs the requested operation
> 5. Kernel returns result to the application
> 6. Application continues execution
> 
> System calls provide a secure interface between user space and kernel space, allowing applications to perform privileged operations without direct access to hardware or kernel memory.

> [!idea] System Calls: Low-Level Process
> The low-level process of a system call involves:
> 
> 1. Application loads system call number and arguments into registers
> 2. Application executes a special instruction (e.g., `syscall` on x86-64)
> 3. CPU switches to kernel mode and jumps to a predefined entry point
> 4. Kernel saves user space context (registers, etc.)
> 5. Kernel validates system call number and arguments
> 6. Kernel executes the appropriate system call handler
> 7. Kernel prepares return value
> 8. Kernel restores user space context
> 9. CPU switches back to user mode and returns control to the application

> [!example] System Call: Image Description
> Create an image with the following elements:
> 
> 1. Two main sections: User Space and Kernel Space
> 2. In User Space:
>    - Application process with steps: Prepare Arguments, Invoke System Call
> 3. In Kernel Space:
>    - System Call Handler
>    - Various kernel services (e.g., File System, Network Stack)
> 4. An arrow from User Space to Kernel Space labeled "syscall instruction"
> 5. Arrows within Kernel Space showing flow through system call handling
> 6. An arrow returning from Kernel Space to User Space labeled "return"
> 7. Show register states at key points (before syscall, in kernel, after return)
> 
> Use different colors for User Space and Kernel Space to emphasize the boundary.

> [!code] System Call: Low-Level Implementation (x86-64)
> ```assembly
> ; User space code
> section .text
> global _start
> 
> _start:
>     ; Prepare system call arguments
>     mov rax, 1          ; System call number for 'write'
>     mov rdi, 1          ; File descriptor (1 = stdout)
>     mov rsi, message    ; Pointer to message
>     mov rdx, 13         ; Message length
>     
>     ; Invoke system call
>     syscall
>     
>     ; Exit program
>     mov rax, 60         ; System call number for 'exit'
>     xor rdi, rdi        ; Exit status 0
>     syscall
> 
> section .data
> message db 'Hello, World!', 10
> 
> ; Kernel space (simplified pseudocode)
> syscall_entry:
>     ; Save user space context
>     push user_registers
>     
>     ; Validate system call number
>     cmp rax, MAX_SYSCALL_NUM
>     ja syscall_error
>     
>     ; Jump to appropriate handler
>     call [syscall_table + rax * 8]
>     
>     ; Prepare for return to user space
>     mov [user_rax], rax  ; Store return value
>     
>     ; Restore user space context
>     pop user_registers
>     
>     ; Return to user space
>     sysret
> ```
> 
> This code demonstrates the user space preparation for a system call, the actual invocation, and a simplified version of what happens in kernel space during the system call handling process.


