> [!idea] Buffer Overflow
> A buffer overflow occurs when an operation **interacts with memory outside of a specified array**. This happens when a program writes data beyond the allocated buffer's boundaries.
> 
> - Occurs when accessing array elements beyond its defined size
> - Can overwrite adjacent memory, including other variables or critical data
> - Potential to modify return addresses, leading to arbitrary code execution

> [!example] Simple Buffer Overflow
> ```c
> char name[4];  // Array of 4 characters
> name[5] = 'a'; // Accessing 6th element (index 5) - out of bounds!
> ```
> This example demonstrates writing beyond the array's allocated memory, potentially overwriting adjacent data.

> [!consider] Implications of Buffer Overflows
> - **Data Corruption**: Overwriting adjacent variables or data structures
> - **Security Vulnerabilities**: Potential to modify sensitive information
> - **Control Flow Hijacking**: Overwriting return addresses to execute arbitrary code
> 
> Buffer overflows can be particularly dangerous when they allow attackers to manipulate a program's execution flow, potentially leading to unauthorized access or code execution.

> [!example] Vulnerable C Function
> ```c
> void vulnerable_function() {
>     char buffer[8];
>     int important_flag = 0;
>     
>     printf("Enter your name: ");
>     gets(buffer);  // Dangerous! No bounds checking
>     
>     if (important_flag != 0) {
>         printf("How did you do that?\n");
>     }
> }
> ```
> 
> In this example:
> - `buffer` is allocated 8 bytes
> - `important_flag` is stored adjacent to `buffer` in memory
> - `gets()` is used, which doesn't perform bounds checking
> - An attacker could input more than 8 characters to overflow `buffer` and modify `important_flag`
> 
> ```
> Memory layout:
> [buffer (8 bytes)][important_flag (4 bytes)]
> ```
> 
> By inputting 12 or more characters, an attacker overwrites `important_flag`, potentially bypassing security checks or altering program behavior.

> [!example] Buffer Overflow: Overwriting RIP
> Consider this vulnerable C function:
> 
> ```c
> void vulnerable_function(char *input) {
>     char buffer[64];
>     strcpy(buffer, input);  // Dangerous! No bounds checking
> }
> 
> int main() {
>     char user_input[100];
>     gets(user_input);
>     vulnerable_function(user_input);
>     return 0;
> }
> ```
> 
> Exploit Process:
> - Cause Buffer Overflow: Input more than 64 bytes to overflow `buffer`.
> - Overwrite RIP: Continue writing past `buffer` to reach and overwrite the stored return address.
> - Use NOP Sled: Fill part of the payload with NOP (No Operation) instructions.
> - Insert Shellcode: Place malicious code after the NOP sled.
> - Add Target Address: Append the address of the buffer's start in little-endian format.
> 
> Payload Structure:
> ```
> [NOP Sled][Shellcode][New RIP Address]
> ```
> 
> Memory Layout (simplified):
> ```
> Higher addresses
> |                |
> | Main's frame   |
> | Return Address | ← Target for overwrite
> | Saved EBP      |
> | Local Vars     |
> | buffer[64]     | ← Start of overflow
> |                |
> Lower addresses
> ```
> 
> Exploit Details:
> - NOP Sled: A series of `0x90` bytes (x86 NOP instruction).
> - Shellcode: Machine code to execute attacker's desired actions.
> - New RIP Address: Address pointing to buffer start, written in little-endian.
> 
> Example Payload (pseudocode):
> ```python
> payload = b"\x90" * 30           # NOP sled
> payload += b"\x31\xc0\x50\x68..."  # Shellcode (example)
> payload += b"\x90" * (72 - len(payload))  # Padding
> payload += b"\x60\xf8\xff\xbf"  # New RIP (0xbffff860 in little-endian)
> ```
> 
> The NOP sled increases the likelihood of successful execution by providing a "slide" into the shellcode. The little-endian address at the end overwrites the return address, redirecting execution to the attacker's code.

