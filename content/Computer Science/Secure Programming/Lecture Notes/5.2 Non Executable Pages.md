> [!idea] Non-Executable Pages
> Non-executable pages, also known as Data Execution Prevention (DEP) or No-Execute (NX), **mark certain memory pages as non-executable, preventing code execution from those regions.** We achieve this by **setting write and execute bits on page tables.** 
> 
> Key points:
> - The stack is intended for storing data, not code, so making it executable is unnecessary and potentially dangerous.
> - By marking the stack and other data regions as non-executable, DEP/NX prevents attackers from executing injected shellcode via buffer overflow exploits.
> - DEP/NX does not prevent all types of attacks, such as heap overflows or return-oriented programming (ROP), which reuse existing code snippets.
> - DEP/NX is widely supported by modern processors and operating systems, making it a standard exploit mitigation technique.


> [!example] DEP/NX in Action
> Consider a simple buffer overflow vulnerability in a program:
> ```c
> void vulnerable_function(char *input) {
>     char buffer[100];
>     strcpy(buffer, input);
> }
> ```
> Without DEP/NX, an attacker could:
> 1. Send a long input that overflows the `buffer` and overwrites the return address on the stack.
> 2. Include shellcode in the input, which gets executed when the function returns.
>
> With DEP/NX enabled:
> 1. The stack is marked as non-executable.
> 2. If the attacker tries to execute shellcode on the stack, the program crashes due to a violation of the non-executable permission.
> 3. The exploit attempt is thwarted, protecting the system from arbitrary code execution.


> [!consider] Exploiting DEP/NX
> While DEP/NX makes it harder to execute injected shellcode, attackers have found ways to bypass this protection:
> 
> 1. **Denial-of-Service (DoS) attacks**: Triggering a crash by attempting to execute code on a non-executable page can be used as a DoS attack, even if arbitrary code execution is not achieved.
>
> 2. **Return-to-libc attacks**: Instead of injecting shellcode, attackers can redirect execution to existing code in the C standard library (libc), which is already loaded in executable memory. By carefully crafting the stack, attackers can chain together calls to libc functions to perform malicious actions.
>
> 3. **Return-Oriented Programming (ROP)**: ROP is an advanced technique that allows attackers to create custom "shellcode" using small code snippets (gadgets) that already exist in executable memory. By chaining together these gadgets, attackers can perform arbitrary computations and bypass DEP/NX.
>    - Gadgets are short instruction sequences that end with a `ret` instruction, allowing the attacker to control the execution flow.
>    - The attacker identifies suitable gadgets in the program's code or linked libraries.
>    - By carefully manipulating the stack, the attacker can chain together gadgets to perform the desired actions, essentially creating a "program" using existing code snippets.
>


> [!example] Return-to-libc: `rm -rf /`
> Let's explore a more in-depth example of a return-to-libc attack that aims to execute the command `rm -rf /` using the `system()` function from libc.
> 
> Consider a vulnerable program with a buffer overflow:
> ```c
> void vulnerable_function(char *input) {
>     char buffer[100];
>     strcpy(buffer, input);
> }
> ```
> 
> The attacker's goal is to overwrite the return address on the stack to point to the `system()` function in libc, with the argument `"rm -rf /"`.
> 
> Here's how the stack would look before the overflow:
> ```
> +------------------+
> |  Return Address  |
> +------------------+
> |    Saved EBP     |
> +------------------+
> |   buffer[100]    |
> +------------------+
> ```
> 
> The attacker crafts a malicious input that includes:
> 1. A long string to overflow the buffer and overwrite the saved EBP and return address.
> 2. The address of the `system()` function in libc.
> 3. A dummy value for the return address after `system()`.
> 4. The address of the string `"rm -rf /"` as the argument to `system()`.
> 
> After the overflow, the stack looks like this:
> ```
> +------------------------+
> |  Address of "rm -rf /" |
> +------------------------+
> | Dummy return address   |
> +------------------------+
> |  Address of system()   |
> +------------------------+
> |   Overflowed buffer    |
> +------------------------+
> ```
> 
> When the `vulnerable_function()` returns, it will:
> 1. Jump to the address of `system()` in libc.
> 2. Use the address of `"rm -rf /"` as the argument to `system()`.
> 3. Execute the command `rm -rf /`, potentially causing significant harm to the system.
> 
> This example demonstrates how return-to-libc attacks can be used to execute arbitrary commands by reusing existing code in the C standard library, bypassing DEP/NX protection.


> [!example] Return-Oriented Programming (ROP)
> Let's dive deeper into Return-Oriented Programming and how it can be used to execute arbitrary shellcode by chaining together code gadgets.
> 
> Suppose we have a large codebase with sufficient code coverage. In this case, we can likely find enough gadgets to construct any desired shellcode.
> 
> For example, let's say we want to execute the shellcode `execve("/bin/sh", NULL, NULL)` to spawn a shell. We need to find gadgets that perform the following actions:
> 1. Set up the arguments for `execve()`.
> 2. Call the `execve()` system call.
> 
> Here's an example of how we might chain together gadgets to achieve this:
> ```
> Gadget 1: pop rdi; ret;        // Load "/bin/sh" into RDI (first argument)
> Gadget 2: xor rsi, rsi; ret;   // Set RSI (second argument) to NULL
> Gadget 3: xor rdx, rdx; ret;   // Set RDX (third argument) to NULL
> Gadget 4: mov rax, 0x3b; ret;  // Set RAX to 0x3b (execve system call number)
> Gadget 5: syscall; ret;        // Invoke the system call
> ```
> 
> To execute this ROP chain, we overflow the buffer to overwrite the return address and the stack with the following payload:
> ```
> buffer_overflow_padding
> address_of_gadget_1
> address_of_"/bin/sh"
> address_of_gadget_2
> address_of_gadget_3
> address_of_gadget_4
> address_of_gadget_5
> ```
> 
> When the vulnerable function returns, it will:
> 1. Jump to Gadget 1, which loads the address of "/bin/sh" into RDI.
> 2. Return to Gadget 2, which sets RSI to NULL.
> 3. Return to Gadget 3, which sets RDX to NULL.
> 4. Return to Gadget 4, which sets RAX to the `execve` system call number.
> 5. Return to Gadget 5, which invokes the system call, spawning a shell.
> 
> This example demonstrates how ROP can be used to construct arbitrary shellcode by chaining together small code gadgets, bypassing DEP/NX protection.
> 
> The larger and more complex the codebase, the more likely it is to find suitable gadgets for constructing any desired shellcode, making ROP a powerful technique for exploiting memory corruption vulnerabilities in the presence of DEP/NX.