> [!idea] Non-Executable Pages
> Non-executable pages, also known as Data Execution Prevention (DEP) or No-Execute (NX), **mark certain memory pages as non-executable, preventing code execution from those regions.** We achieve this by **setting write and execute bits on page tables.** 
> 
> Key points:
> - The stack is intended for storing data, not code, so making it executable is unnecessary and potentially dangerous.
> - By marking the stack and other data regions as non-executable, DEP/NX prevents attackers from executing injected shellcode via buffer overflow exploits.
> - DEP/NX does not prevent all types of attacks, such as heap overflows or return-oriented programming (ROP), which reuse existing code snippets.
> - DEP/NX is widely supported by modern processors and operating systems, making it a standard exploit mitigation technique.


> [!example] DEP/NX in Action
> Consider a simple buffer overflow vulnerability in a program:
> ```c
> void vulnerable_function(char *input) {
>     char buffer[100];
>     strcpy(buffer, input);
> }
> ```
> Without DEP/NX, an attacker could:
> 1. Send a long input that overflows the `buffer` and overwrites the return address on the stack.
> 2. Include shellcode in the input, which gets executed when the function returns.
>
> With DEP/NX enabled:
> 1. The stack is marked as non-executable.
> 2. If the attacker tries to execute shellcode on the stack, the program crashes due to a violation of the non-executable permission.
> 3. The exploit attempt is thwarted, protecting the system from arbitrary code execution.


> [!consider] Exploiting DEP/NX
> While DEP/NX makes it harder to execute injected shellcode, attackers have found ways to bypass this protection:
> 
> 1. **Denial-of-Service (DoS) attacks**: Triggering a crash by attempting to execute code on a non-executable page can be used as a DoS attack, even if arbitrary code execution is not achieved.
>
> 2. **Return-to-libc attacks**: Instead of injecting shellcode, attackers can redirect execution to existing code in the C standard library (libc), which is already loaded in executable memory. By carefully crafting the stack, attackers can chain together calls to libc functions to perform malicious actions.
>
> 3. **Return-Oriented Programming (ROP)**: ROP is an advanced technique that allows attackers to create custom "shellcode" using small code snippets (gadgets) that already exist in executable memory. By chaining together these gadgets, attackers can perform arbitrary computations and bypass DEP/NX.
>    - Gadgets are short instruction sequences that end with a `ret` instruction, allowing the attacker to control the execution flow.
>    - The attacker identifies suitable gadgets in the program's code or linked libraries.
>    - By carefully manipulating the stack, the attacker can chain together gadgets to perform the desired actions, essentially creating a "program" using existing code snippets.
>


> [!example] Return-to-libc: `rm -rf /`
> Let's explore a more in-depth example of a return-to-libc attack that aims to execute the command `rm -rf /` using the `system()` function from libc.
> 
> Consider a vulnerable program with a buffer overflow:
> ```c
> void vulnerable_function(char *input) {
>     char buffer[100];
>     strcpy(buffer, input);
> }
> ```
> 
> The attacker's goal is to overwrite the return address on the stack to point to the `system()` function in libc, with the argument `"rm -rf /"`.
> 
> Here's how the stack would look before the overflow:
> ```
> +------------------+
> |  Return Address  |
> +------------------+
> |    Saved EBP     |
> +------------------+
> |   buffer[100]    |
> +------------------+
> ```
> 
> The attacker crafts a malicious input that includes:
> 1. A long string to overflow the buffer and overwrite the saved EBP and return address.
> 2. The address of the `system()` function in libc.
> 3. A dummy value for the return address after `system()`.
> 4. The address of the string `"rm -rf /"` as the argument to `system()`.
> 
> After the overflow, the stack looks like this:
> ```
> +------------------------+
> |  Address of "rm -rf /" |
> +------------------------+
> | Dummy return address   |
> +------------------------+
> |  Address of system()   |
> +------------------------+
> |   Overflowed buffer    |
> +------------------------+
> ```
> 
> When the `vulnerable_function()` returns, it will:
> 1. Jump to the address of `system()` in libc.
> 2. Use the address of `"rm -rf /"` as the argument to `system()`.
> 3. Execute the command `rm -rf /`, potentially causing significant harm to the system.
> 
> This example demonstrates how return-to-libc attacks can be used to execute arbitrary commands by reusing existing code in the C standard library, bypassing DEP/NX protection.


> [!example] Return-Oriented Programming (ROP)
> 
> Let's dive deeper into Return-Oriented Programming and how it can be used to execute arbitrary shellcode by chaining together code gadgets.
> 
> Suppose we have a large codebase with sufficient code coverage. In this case, we can likely find enough gadgets to construct any desired shellcode.
> 
> For example, let's say we want to execute the shellcode `execve("/bin/sh", NULL, NULL)` to spawn a shell. We need to find gadgets that perform the following actions:
> 
> 1. Set up the arguments for `execve()`.
> 2. Call the `execve()` system call.
> 
> **General Workflow of a ROP Attack**:
> 1. **Identify a Vulnerability**: Locate a memory corruption vulnerability (e.g., buffer overflow) that allows overwriting the return address on the stack.
> 2. **Find Gadgets**: Analyze the program and its libraries to find small sequences of instructions (gadgets) ending in `ret` that perform useful operations.
> 3. **Construct the ROP Chain**: Chain these gadgets together to manipulate the CPU registers and memory in a way that performs the desired action.
> 4. **Craft the Payload**: Create a payload that includes buffer overflow padding followed by the addresses of the gadgets in the order they should be executed.
> 5. **Trigger the Exploit**: Overflow the buffer to overwrite the return address with the first gadget's address and execute the chain of gadgets.
>
> **Key Point: Importance of `ret`**:
> - The `ret` (return) instruction is crucial in ROP because it allows the attacker to chain gadgets together. Each gadget ends with `ret`, which pops the next address off the stack, transferring control to the next gadget. This chaining is what enables the attacker to perform complex operations step-by-step using only existing code.
>
> 
> Here's an example of how we might chain together gadgets to achieve this:
> 
> ```
> Gadget 1: pop rdi; ret;        // Load "/bin/sh" into RDI (first argument)
> --------------------------------
> Stack before Gadget 1 execution:
> [ Buffer Overflow Padding ]
> [ Address of Gadget 1 ]        // Return address after overflow
> [ Address of "/bin/sh" ]       // Value to be loaded into RDI
> [ Address of Gadget 2 ]        // Next return address (Gadget 2)
> [ Address of Gadget 3 ] 
> [ Address of Gadget 4 ] 
> [ Address of Gadget 5 ]
> 
> Explanation: 
> - `pop rdi` takes the value at the top of the stack (`Address of "/bin/sh"`) and loads it into the `RDI` register.
> - `ret` pops the next address from the stack (`Address of Gadget 2`) and jumps to it.
> --------------------------------
> Stack after Gadget 1 execution:
> [ Address of Gadget 2 ]        // Current instruction pointer (next gadget)
> [ Address of Gadget 3 ] 
> [ Address of Gadget 4 ] 
> [ Address of Gadget 5 ]
> 
> Gadget 2: xor rsi, rsi; ret;   // Set RSI (second argument) to NULL
> --------------------------------
> Stack before Gadget 2 execution:
> [ Address of Gadget 2 ]        // Return address
> [ Address of Gadget 3 ]
> [ Address of Gadget 4 ]
> [ Address of Gadget 5 ]
> 
> Explanation: 
> - `xor rsi, rsi` sets the `RSI` register to NULL (0).
> - `ret` pops the next address from the stack (`Address of Gadget 3`) and jumps to it.
> --------------------------------
> Stack after Gadget 2 execution:
> [ Address of Gadget 3 ]        // Current instruction pointer (next gadget)
> [ Address of Gadget 4 ]
> [ Address of Gadget 5 ]
> 
> Gadget 3: xor rdx, rdx; ret;   // Set RDX (third argument) to NULL
> --------------------------------
> Stack before Gadget 3 execution:
> [ Address of Gadget 3 ]        // Return address
> [ Address of Gadget 4 ]
> [ Address of Gadget 5 ]
> 
> Explanation: 
> - `xor rdx, rdx` sets the `RDX` register to NULL (0).
> - `ret` pops the next address from the stack (`Address of Gadget 4`) and jumps to it.
> --------------------------------
> Stack after Gadget 3 execution:
> [ Address of Gadget 4 ]        // Current instruction pointer (next gadget)
> [ Address of Gadget 5 ]
> 
> Gadget 4: mov rax, 0x3b; ret;  // Set RAX to 0x3b (execve system call number)
> --------------------------------
> Stack before Gadget 4 execution:
> [ Address of Gadget 4 ]        // Return address
> [ Address of Gadget 5 ]
> 
> Explanation: 
> - `mov rax, 0x3b` sets the `RAX` register to 0x3b, which is the syscall number for `execve`.
> - `ret` pops the next address from the stack (`Address of Gadget 5`) and jumps to it.
> --------------------------------
> Stack after Gadget 4 execution:
> [ Address of Gadget 5 ]        // Current instruction pointer (next gadget)
> 
> Gadget 5: syscall; ret;        // Invoke the system call
> --------------------------------
> Stack before Gadget 5 execution:
> [ Address of Gadget 5 ]        // Return address
> 
> Explanation: 
> - `syscall` uses the values in `RAX`, `RDI`, `RSI`, and `RDX` to make a system call. Here, it triggers `execve("/bin/sh", NULL, NULL)`, spawning a shell.
> - After `syscall`, control may not return if the process is replaced by the shell.
> ```


