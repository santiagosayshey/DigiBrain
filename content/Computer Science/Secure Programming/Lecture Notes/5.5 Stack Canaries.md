motivation - how can we tell that something is about to go wrong before it actually does?

consider - mining canaries
- miners used to protect themselves against toxic gas build-up by bringing canaries with them who were highly sensitive to toxic gases. The birds would chirp, letting the miners to get out of there asap. 

idea - stack canaries
- what if we did the same thing on the stack? we put some value we don't expect to change in there, and if it does, then we know someone has tampered with our code! 
- more specifically: at runtime, we generate a random secret value and save it in canary storage. In function prologue, place the canary on the stack reight below the function pointer. in the epilogue, check the canary value on the stack and compare it agianst the canary value in storage. since we never actually use this value in our code, if it changes then we know that an attacker has done something - a buffer overflow or some such
- properties:
	- different for every run time, but the same for every function during a run time.
	- uses a null byte as the first byte to migate string based attacks (show what this actually means using a simple example format string attack with %s)
	- some added but insignificant overhead


consider - how to stop canaries?
- leak it
	- format string attacks to print the stack
	- once found, overwrite the canary with itself so it appears as never unchanged
- bypass it
	- write AROUND the canary
	- format string vulnerabilities to choose where
	- heap overflows never overwrite a stack canary
- guess it
	- 24 bits to guess on 32 bit systems (first 8 bytes are a null byte) ~ 16 million guesses
	- 56 bits on a 64 bit system ~ a lot more. to claude - how long would this take?
	- small consider sentence of p=np. if we prove it, do stack canaries become obsolete? 