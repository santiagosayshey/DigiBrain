> [!idea] Stack and Function Calls
> Stacks are **first in, last out** data structures well suited to containing data used by processes. When a function is called, a dedicated space called a **stack frame** is created on the stack to hold the function's local variables and parameters.
> 
> Two crucial pointers manage this space:
> - The **EBP (Base Pointer)** points to the base of the current stack frame.
> - The **ESP (Stack Pointer)** points to the top of the current stack frame.
> 
> Both EBP and ESP are stored in CPU registers for quick access. As new functions are called, stack frames grow downwards in memory, with each new frame positioned below the previous one.
> 
> The stack operates primarily through two operations:
> - **push** decrements the ESP and stores a value at the new ESP location, effectively adding data to the top of the stack.
> - **pop** retrieves the value at the current ESP and then increments ESP, removing data from the top of the stack.
> 
> When a function is called:
> 1. **Arguments** are pushed onto the stack in reverse order, meaning the last argument is pushed first and the first argument last.
> 2. The **return address** (the location in the code to return to after the function executes) is pushed onto the stack.
> 3. The current **EBP** (the base pointer of the calling function) is pushed onto the stack to save the previous stack frame's base.
> 4. **EBP** is then set to the current value of ESP, establishing a new base for the called function's stack frame.
> 5. **Space for local variables** is allocated by decrementing ESP to reserve memory on the stack.
> 
> The stack at three key stages of a function call:
> 
> 1. **Right before a function call**:
> 
> | Pointer | Value       |
> |---------|-------------|
> |         | Argument 2  |
> |         | Argument 1  |
> | ESP →   |             |
> 
> 2. **After the function is called and setup is complete**:
> 
> | Pointer | Value          |
> |---------|----------------|
> |         | Argument 2     |
> |         | Argument 1     |
> |         | Return Address |
> | EBP →   | Old EBP        |
> |         | Local Variable 1 |
> |         | Local Variable 2 |
> | ESP →   |                |
> 
> When a function completes:
> 1. The **return value** is typically stored in a designated register (often EAX) rather than on the stack.
> 2. **ESP** is moved back to the current value of EBP, effectively deallocating the local variables by resetting the stack pointer.
> 3. The previous **EBP** value is **popped** from the stack, restoring the caller's stack frame.
> 4. The **return address** is **popped**, transferring control back to the calling function.
> 5. The calling function may **adjust ESP** to remove any pushed arguments, finalizing the cleanup of the stack.
> 
> 3. **When the function is done (just before returning)**:
> 
> | Pointer | Value          |
> |---------|----------------|
> |         | Argument 2     |
> |         | Argument 1     |
> |         | Return Address |
> | EBP →   | Old EBP        |
> | ESP →   |                |
> 
> This process ensures that the stack is properly maintained and that control is correctly returned to the calling function, with the stack in the same state it was before the function call.


1. Initial State: Caller's Frame Before Function Call

| Register | Content |
|----------|---------|
|          | Caller's local var 2 |
|          | Caller's local var 1 |
| EBP →    | Caller's saved EBP |
|          | Return addr to caller's caller |
|          | Param 2 for caller |
| ESP →    | Param 1 for caller |

What's happening: The caller's stack frame is fully set up. Local variables and parameters for the caller are in place. EBP points to the caller's saved base pointer, and ESP points to the top of the stack, which is the last parameter of the caller.

2. After CALL Instruction: Transition to Callee

| Register | Content |
|----------|---------|
|          | Caller's local var 2 |
|          | Caller's local var 1 |
| EBP →    | Caller's saved EBP |
|          | Return addr to caller's caller |
|          | Param 2 for caller |
|          | Param 1 for caller |
|          | Arg 2 for callee |
|          | Arg 1 for callee |
| ESP →    | Return addr to caller |

What's happening: The caller has pushed arguments for the callee onto the stack. The CALL instruction has been executed, pushing the return address onto the stack and jumping to the callee's code. ESP now points to this return address, while EBP still points to the caller's frame.

3. Callee's Frame Established: After Prologue

| Register | Content |
|----------|---------|
|          | Caller's local var 2 |
|          | Caller's local var 1 |
|          | Caller's saved EBP |
|          | Return addr to caller's caller |
|          | Param 2 for caller |
|          | Param 1 for caller |
|          | Arg 2 for callee |
|          | Arg 1 for callee |
|          | Return addr to caller |
| EBP →    | Caller's EBP |
| ESP →    | Callee's local var 1 |

What's happening: The callee's prologue has executed, pushing the old (caller's) EBP onto the stack, setting EBP to the current ESP to create a new stack frame, and allocating space for local variables by subtracting from ESP. EBP now points to the saved EBP (stack frame base), and ESP points to the top of the stack where local variables are allocated.

4. Return to Caller: After Callee's Epilogue

| Register | Content |
|----------|---------|
|          | Caller's local var 2 |
|          | Caller's local var 1 |
| EBP →    | Caller's saved EBP |
|          | Return addr to caller's caller |
|          | Param 2 for caller |
|          | Param 1 for caller |
| ESP →    | Return value from callee |

What's happening: The callee has finished execution. Its epilogue has restored the stack by setting ESP to EBP, popped the old EBP value to restore the caller's EBP, and executed RET to pop the return address and jump back to the caller. The caller's stack frame is restored, and the return value (if any) is typically in a register (e.g., EAX) or on top of the stack.