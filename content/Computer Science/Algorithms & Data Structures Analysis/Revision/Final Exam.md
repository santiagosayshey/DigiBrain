# Asymptotic Analysis
  
| Notation              | Meaning                                                                                 |
| --------------------- | --------------------------------------------------------------------------------------- |
| $f(n) = O(g(n))$      | Highest degree term of $f(n)$ is less than or equal to highest degree term of $g(n)$    |
| $f(n) = \Omega(g(n))$ | Highest degree term of $f(n)$ is greater than or equal to highest degree term of $g(n)$ |
| $f(n) = \Theta(g(n))$ | Highest degree terms of $f(n)$ and $g(n)$ are equal                                     |
| $f(n) = o(g(n))$      | Highest degree term of $f(n)$ is strictly less than highest degree term of $g(n)$       |
| $f(n) = \omega(g(n))$ | Highest degree term of $f(n)$ is strictly greater than highest degree term of $g(n)$    |
# Multiplication

| Algorithm                    | Process                                                                                                                                                                                                                                                                | Complexity                                                                      | Benefits                                                                                                                |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| School Method Multiplication | 1. Multiply each digit of the multiplicand by each digit of the multiplier<br>2. Sum up all the partial products (n^2 partial products)                                                                                                                                | $3n^2 + 2n = n^2$ primitive operations                                          | - Simple and intuitive<br>- Easy to understand and implement                                                            |
| Recursive Multiplication     | 1. Split integers into two halves<br>2. Calculate 4 partial products recursively<br>3. Add aligned partial products                                                                                                                                                    | For $n$ power of 2: $T(n) \leq 7n^2 - 6n$<br>For general $n$: $T(n) \leq 28n^2$ | - Applies Divide & Conquer approach<br>- Breaks down the problem into smaller subproblems                               |
| Karatsuba Multiplication     | 1. Split integers into two halves<br>2. Calculate 3 partial products recursively<br>3. Combine partial products using Karatsuba formula:<br>   $(a_1 \times b_1) B^{2k} + ((a_1 + a_0) \times (b_1 + b_0) - (a_1 \times b_1 + a_0 \times b_0)) B^{k} + a_0 \times b_0$ | $T_K(n) \leq 207 \cdot n^{\log_3 3} \approx O(n^{1.59})$                        | - Faster than recursive multiplication<br>- Reduces the number of recursive calls<br>- Achieves subquadratic complexity |

# AVL Rotations

| Imbalance Type   | Condition                              | Balance Factor of Node | Balance Factor of Node's Child    | Rotations Needed                                          |
| ---------------- | -------------------------------------- | ---------------------- | --------------------------------- | --------------------------------------------------------- |
| LL (Left-Left)   | Left subtree of left child is deeper   | Balance Factor: +2     | Balance Factor of Left Child: +1  | Single Right Rotation at Node                             |
| RR (Right-Right) | Right subtree of right child is deeper | Balance Factor: -2     | Balance Factor of Right Child: -1 | Single Left Rotation at Node                              |
| LR (Left-Right)  | Right subtree of left child is deeper  | Balance Factor: +2     | Balance Factor of Left Child: -1  | Left Rotation at Left Child, then Right Rotation at Node  |
| RL (Right-Left)  | Left subtree of right child is deeper  | Balance Factor: -2     | Balance Factor of Right Child: +1 | Right Rotation at Right Child, then Left Rotation at Node |
**NOTE:** When performing a x rotation, if a child node has two children, then the x child becomes the child of the root, where x can be left or right. 
You're right. The examples provided for the Linked List and Adjacency Array are not specific examples but rather general descriptions of their suitable use cases. Let me provide more concrete examples for those two:

| Data Structure   | Example                                                                         | Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------------|---------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Adjacency List   | Tracing ancestors in a family tree spanning several generations                 | - Sparse graphs (relatively few edges compared to the total number of possible edges)<br>- Nodes have varying degrees (different numbers of connections)<br>- Space-efficient for sparse graphs<br>- Efficient for traversals and following connections<br>- Suitable when the number of edges is much smaller than the square of the number of nodes                                                                                                                                                                                                                                                                                                                                 |
| Adjacency Matrix | Storing distances between cities in a densely connected transportation network | - Dense graphs (many edges relative to the number of nodes)<br>- Fixed number of nodes known in advance<br>- Efficient for quickly checking the presence or absence of an edge between two nodes<br>- Constant-time lookup for edge weights or properties<br>- Suitable when the number of edges is close to the square of the number of nodes<br>- Efficient for algorithms that require quick access to edge information, such as shortest path algorithms like Floyd-Warshall                                                                                                                                                                                                   |
| Linked List      | Representing a sparse social network with user profiles as nodes                | - Suitable for sparse graphs with a small number of edges<br>- Allows for dynamic allocation of nodes and edges<br>- Efficient insertion and deletion of nodes and edges<br>- Requires extra space for storing pointers or references<br>- Not efficient for accessing nodes or edges directly (requires traversal)<br>- Suitable when the graph structure frequently changes or when memory usage needs to be minimized                                                                                                                                                                                                                                                              |
| Adjacency Array  | Representing a dense computer network with a fixed number of connected devices  | - Suitable for dense graphs with a known number of nodes<br>- Efficient for accessing edge information between two specific nodes<br>- Requires a fixed amount of memory, allocated upfront<br>- Not efficient for graphs with a large number of nodes but few edges (sparse graphs)<br>- Suitable when the number of nodes is fixed and known in advance, and the graph is dense                                                                                                                                                                                                                                                                                                      |
