
| Notation              | Meaning                                                                                 |
| --------------------- | --------------------------------------------------------------------------------------- |
| $f(n) = O(g(n))$      | Highest degree term of $f(n)$ is less than or equal to highest degree term of $g(n)$    |
| $f(n) = \Omega(g(n))$ | Highest degree term of $f(n)$ is greater than or equal to highest degree term of $g(n)$ |
| $f(n) = \Theta(g(n))$ | Highest degree terms of $f(n)$ and $g(n)$ are equal                                     |
| $f(n) = o(g(n))$      | Highest degree term of $f(n)$ is strictly less than highest degree term of $g(n)$       |
| $f(n) = \omega(g(n))$ | Highest degree term of $f(n)$ is strictly greater than highest degree term of $g(n)$    |

| Imbalance Type   | Condition                              | Balance Factor of Node | Balance Factor of Node's Child    | Rotations Needed                                          |
| ---------------- | -------------------------------------- | ---------------------- | --------------------------------- | --------------------------------------------------------- |
| LL (Left-Left)   | Left subtree of left child is deeper   | Balance Factor: +2     | Balance Factor of Left Child: +1  | Single Right Rotation at Node                             |
| RR (Right-Right) | Right subtree of right child is deeper | Balance Factor: -2     | Balance Factor of Right Child: -1 | Single Left Rotation at Node                              |
| LR (Left-Right)  | Right subtree of left child is deeper  | Balance Factor: +2     | Balance Factor of Left Child: -1  | Left Rotation at Left Child, then Right Rotation at Node  |
| RL (Right-Left)  | Left subtree of right child is deeper  | Balance Factor: -2     | Balance Factor of Right Child: +1 | Right Rotation at Right Child, then Left Rotation at Node |
**NOTE:** When performing a x rotation, if a child node has two children, then the x child becomes the child of the root, where x can be left or right. 

| Data Structure   | Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Example                                                                        |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| Adjacency List   | - Sparse graphs (relatively few edges compared to the total number of possible edges)<br>- Nodes have varying degrees (different numbers of connections)<br>- Space-efficient for sparse graphs<br>- Efficient for traversals and following connections<br>- Suitable when the number of edges is much smaller than the square of the number of nodes                                                                                                                            | Tracing ancestors in a family tree spanning several generations                |
| Adjacency Matrix | - Dense graphs (many edges relative to the number of nodes)<br>- Fixed number of nodes known in advance<br>- Efficient for quickly checking the presence or absence of an edge between two nodes<br>- Constant-time lookup for edge weights or properties<br>- Suitable when the number of edges is close to the square of the number of nodes<br>- Efficient for algorithms that require quick access to edge information, such as shortest path algorithms like Floyd-Warshall | Storing distances between cities in a densely connected transportation network |
| Linked List      | - Suitable for sparse graphs with a small number of edges<br>- Allows for dynamic allocation of nodes and edges<br>- Efficient insertion and deletion of nodes and edges<br>- Requires extra space for storing pointers or references<br>- Not efficient for accessing nodes or edges directly (requires traversal)<br>- Suitable when the graph structure frequently changes or when memory usage needs to be minimized                                                         | Implementing a sparse graph with flexible node connections                     |
| Adjacency Array  | - Suitable for dense graphs with a known number of nodes<br>- Efficient for accessing edge information between two specific nodes<br>- Requires a fixed amount of memory, allocated upfront<br>- Not efficient for graphs with a large number of nodes but few edges (sparse graphs)<br>- Suitable when the number of nodes is fixed and known in advance, and the graph is dense                                                                                                | Representing a dense graph with a fixed number of nodes                        |
