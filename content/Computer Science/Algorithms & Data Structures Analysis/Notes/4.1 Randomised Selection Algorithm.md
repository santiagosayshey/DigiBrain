
> [!idea]+ The Idea
> Consider a scenario of finding the $i'th$ [[Order Statistics|order statstic]] in a set. We know we can find this element in $O(n \cdot \log(n))$ time using a divide and conquer comparison sort. Can we do this faster?
> 
> Using a selection algorithm rather than a sorting algorithm, we can do this in linear time - $O(n)$. We do this by modifying the [[6.5 Quick Sort|Quick Sort]] algorithm, and worrying only about one of partitions on either side of the pivot.
> 


> [!code] RSelect
> ```c
> RSelect(array A, length n, order_statistic i) {
> 	if n == 1
> 		return A[0]
> 		
> 	pivot = A[random]
> 	partition(A, pivot)           //  A = [   < pivot  | pivot |      > pivot      ]
> 	j = index of pivot
> 	
> 	if i == j
> 		return pivot        // since the pivot is in it's final position, it is the j'th smallest element
> 	else if j > i
> 		return RSelect(A[partition 1], j-1, i)
> 	else if j > i
> 		return RSelect(A[partition 2], n-j, i-j)
> }
>```


> [!consider] Consider the Running Time of `RSelect`
> Depends on how 'well' we pick the pivot. A poorly chosen pivot can result in an at worst $O(n^2)$ running time, but this incredibly unlikely. Your computer is more likely to be struck by a meteor than for this to happen.
> 
> **The best pivot is the median element.** 






