> [!motivation] Motivation
>
> In the realm of computational theory, determining whether a problem can be solved by an algorithm is a fundamental question. With the diversity of computational devices and programming languages, it becomes essential to have a unified way to understand what problems can be solved by any computational means.

> [!idea] Turing Machine
>
> A Turing Machine is a theoretical model of computation introduced by Alan Turing. It consists of an infinite tape, a tape head that can read and write symbols, and a set of rules (or a finite state machine) that **dictate the machine's actions based on the current state and tape symbol**.
> 
> - **Components**: The tape (divided into cells), the tape head (which reads and writes symbols), and the state register (which holds the current state).
> - **Operations**: The machine can move the tape head left or right, read a symbol from the tape, write a new symbol on the tape, and change its state according to the transition function.
> - **Purpose**: It abstracts the concept of computation and helps define what it means for a function to be computable. By specifying a set of rules that a machine follows to manipulate symbols, it **can be used to show that a problem is computable if a Turing Machine can be designed to solve it**. Conversely, if no Turing Machine can solve a problem, that problem is deemed non-computable.
> 
> ![[0 hupeBBgcYLauBXNr.png|500]]

> [!example] Example of a Turing Machine
>
> Consider a Turing Machine designed to decide whether a binary string has an even number of 1s. The tape alphabet consists of {0, 1, B}, where B represents a blank symbol.
> 
> - **Initial State**: The machine starts in the initial state with the tape head at the leftmost position of the input string.
> - **Transition Function**: 
>   - If in state `q0` and reading `1`, it writes `B`, moves right, and transitions to state `q1`.
>   - If in state `q0` and reading `0`, it moves right and stays in `q0`.
>   - If in state `q1` and reading `1`, it writes `B`, moves right, and transitions to `q0`.
>   - If in state `q1` and reading `0`, it moves right and stays in `q1`.
>   - If in state `q0` or `q1` and reading `B`, it halts.
> - **Result**: If the machine halts in state `q0`, the input string has an even number of 1s. If it halts in state `q1`, the string has an odd number of 1s.

> [!idea] Turing Completeness
>
> A system is Turing complete if it can simulate any Turing Machine. This means it can solve any problem that is computationally solvable, given enough time and resources.
> 
> - **Definition**: A programming language or computational system is Turing complete if it can simulate the computation of any Turing Machine.
> - **Criteria**: The system must have conditional branching (like `if` statements), a form of repetition or looping (like `while` or `for` loops), and the ability to read and write an arbitrary amount of data.

> [!example] Examples of Turing Complete Systems
>
> - **Programming Languages**: Most modern programming languages, such as Python, Java, and C++, are Turing complete because they can implement algorithms and solve any problem that a Turing Machine can.
> - **Cellular Automata**: The Game of Life, a cellular automaton devised by John Conway, is Turing complete because it can simulate a universal constructor.
> - **Lambda Calculus**: A formal system in mathematical logic and computer science for expressing computation based on function abstraction and application.

> [!consider] Additional Considerations
>
> - **Non-Turing Complete Systems**: Some computational systems, like regular expressions or finite automata, are not Turing complete. They can perform certain computations but cannot solve all problems that a Turing Machine can.
> - **Physical Realizability**: While Turing Machines are an abstract concept, real-world computers are limited by finite memory and processing power, which means they can only approximate Turing completeness within practical limits.
> - **Implications**: Understanding Turing completeness helps in the study of computational limits, complexity classes, and the feasibility of algorithmic solutions for various problems.