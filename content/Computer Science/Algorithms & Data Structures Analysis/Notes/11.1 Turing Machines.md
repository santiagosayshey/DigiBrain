> [!motivation] Motivation
>
> In the realm of computational theory, determining whether a problem can be solved by an algorithm is a fundamental question. With the diversity of computational devices and programming languages, it becomes essential to have a unified way to understand what problems can be solved by any computational means.

> [!idea] Turing Machine
>
> A Turing Machine is a theoretical model of computation introduced by Alan Turing. It consists of an infinite tape, a tape head that can read and write symbols, and a set of rules (or a finite state machine) that **dictate the machine's actions based on the current state and tape symbol**.
> 
> - **Components**: The tape (divided into cells), the tape head (which reads and writes symbols), and the state register (which holds the current state).
> - **Operations**: The machine can move the tape head left or right, read a symbol from the tape, write a new symbol on the tape, and change its state according to the transition function.
> - **Purpose**: It abstracts the concept of computation and helps define what it means for a function to be computable. By specifying a set of rules that a machine follows to manipulate symbols, it **can be used to show that a problem is computable if a Turing Machine can be designed to solve it**. Conversely, if no Turing Machine can solve a problem, that problem is deemed non-computable.
> 
> ![[0 hupeBBgcYLauBXNr.png|500]]

> [!example] Example of a Turing Machine
>
> Consider a Turing Machine designed to decide whether a binary string has an even number of 1s. The tape alphabet consists of {0, 1, B}, where B represents a blank symbol.
> 
> - **Initial State**: The machine starts in the initial state with the tape head at the leftmost position of the input string.
> - **Transition Function**: 
>   - If in state `q0` and reading `1`, it writes `B`, moves right, and transitions to state `q1`.
>   - If in state `q0` and reading `0`, it moves right and stays in `q0`.
>   - If in state `q1` and reading `1`, it writes `B`, moves right, and transitions to `q0`.
>   - If in state `q1` and reading `0`, it moves right and stays in `q1`.
>   - If in state `q0` or `q1` and reading `B`, it halts.
> - **Result**: If the machine halts in state `q0`, the input string has an even number of 1s. If it halts in state `q1`, the string has an odd number of 1s.

> [!idea] Turing Completeness
>
> A system is Turing complete if it can simulate any Turing Machine. This means it **can solve any problem that is computationally solvable, given enough time and resources**.
> 
> - **Definition**: A programming language or computational system is Turing complete if it can simulate the computation of any Turing Machine.
> - **Criteria**: The system must have conditional branching (like `if` statements), a form of repetition or looping (like `while` or `for` loops), and the ability to read and write an arbitrary amount of data.

> [!example] Examples of Turing Complete Systems
>
> - **Minecraft Redstone**: Believe it or not, you can build a fully functional computer inside Minecraft using Redstone circuits. Players have created everything from calculators to full-fledged CPUs, making Minecraft a playground for digital logic and Turing completeness.
> - **Magic: The Gathering**: In 2019, researchers proved that a sufficiently complex game of Magic: The Gathering can simulate a Turing Machine. This means you could, in theory, decide computational problems while battling with your favorite cards.
> - **Conway's Game of Life**: This cellular automaton, consisting of simple rules for cell survival and reproduction, can simulate a universal constructor. You could say it's like having a tiny, living computer on your screen!
> - **PowerPoint**: Yes, even PowerPoint can be Turing complete. By using slide transitions and hyperlinks in creative ways, you can simulate computational processes. Who knew your next presentation could double as a computing engine?
> - **Baking Recipes**: Imagine a cookbook that is Turing complete. By meticulously following a set of rules (steps), where each ingredient and instruction acts like a state transition, you can bake a cake while theoretically solving any computable problem. It might not be the most efficient way to compute, but it sure is delicious!
> - **Esoteric Programming Languages (Esolang)**: Languages like Brainfuck and Befunge are intentionally designed to be as confusing and impractical as possible, yet they are Turing complete. Writing code in these languages feels like solving a riddle wrapped in an enigma, but it's computationally powerful!

> [!consider] Additional Considerations
>
> - **Non-Turing Complete Systems**: Some computational systems, like regular expressions or finite automata, are not Turing complete. They can perform certain computations but cannot solve all problems that a Turing Machine can.
> - **Physical Realizability**: While Turing Machines are an abstract concept, real-world computers are limited by finite memory and processing power, which means they can only approximate Turing completeness within practical limits.
> - **Implications**: Understanding Turing completeness helps in the study of computational limits, complexity classes, and the feasibility of algorithmic solutions for various problems.