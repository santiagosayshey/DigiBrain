> [!motivation] Motivation
>
> In the realm of computational theory, **determining whether a problem can be solved by an algorithm is a fundamental question**. With the diversity of computational devices and programming languages, it becomes essential to have a unified way to **understand what problems can be solved** by any computational means.

> [!idea] Turing Machine
>
> A Turing Machine is a theoretical model of computation introduced by Alan Turing. It consists of an infinite tape, a tape head that can read and write symbols, and **a set of rules (or a finite state machine) that dictate the machine's actions based on the current state** and tape symbol.
> 
> - **Components**: The tape (divided into cells), the tape head (which reads and writes symbols), and the state register (which holds the current state).
> - **Operations**: The machine can move the tape head left or right, read a symbol from the tape, write a new symbol on the tape, and change its state according to the transition function.
> - **Purpose**: It **abstracts the concept of computation and helps define what it means for a function to be computable**. By specifying a set of rules that a machine follows to manipulate symbols, it can be used to show that a problem is computable if a Turing Machine can be designed to solve it. Conversely, if no Turing Machine can solve a problem, that problem is deemed non-computable.
> - **Computability**: Essentially, a Turing Machine acts as **a black box that takes inputs and processes them according to its rules**. If the machine halts and provides outputs for given inputs, it proves that the problem is computable. If no Turing Machine can be constructed to solve a problem, it is considered non-computable.
> 
> ![[Turing_Machine_Model_Davey_2012.jpg|500]]


> [!example] Example of a Turing Machine
>
> Consider a Turing Machine designed to decide whether a binary string has an even number of 1s. The tape alphabet consists of {0, 1, B}, where B represents a blank symbol.
> 
> - **Initial State**: The machine starts in the initial state with the tape head at the leftmost position of the input string.
> - **Transition Function**: 
>   - If in state `q0` and reading `1`, it writes `B`, moves right, and transitions to state `q1`.
>   - If in state `q0` and reading `0`, it moves right and stays in `q0`.
>   - If in state `q1` and reading `1`, it writes `B`, moves right, and transitions to `q0`.
>   - If in state `q1` and reading `0`, it moves right and stays in `q1`.
>   - If in state `q0` or `q1` and reading `B`, it halts.
> - **Result**: If the machine halts in state `q0`, the input string has an even number of 1s. If it halts in state `q1`, the string has an odd number of 1s.

> [!example] Hello World Turing Machine
>
> Creating a "Hello World" Turing Machine involves designing a set of states and transitions that write "Hello World" on the tape.
>
> - **Initial State**: The machine starts with a blank tape and the tape head at the leftmost position.
> - **Transition Function**: 
>   - State `q0`: Write `H`, move right, go to state `q1`
>   - State `q1`: Write `e`, move right, go to state `q2`
>   - State `q2`: Write `l`, move right, go to state `q3`
>   - State `q3`: Write `l`, move right, go to state `q4`
>   - State `q4`: Write `o`, move right, go to state `q5`
>   - State `q5`: Write ` ` (space), move right, go to state `q6`
>   - State `q6`: Write `W`, move right, go to state `q7`
>   - State `q7`: Write `o`, move right, go to state `q8`
>   - State `q8`: Write `r`, move right, go to state `q9`
>   - State `q9`: Write `l`, move right, go to state `q10`
>   - State `q10`: Write `d`, move right, go to state `q11`
>   - State `q11`: Halt
> - **Result**: The tape will have "Hello World" written on it, demonstrating the machine's ability to perform specific, predefined tasks.

> [!idea] Turing Completeness
>
> A system is Turing complete if it can simulate any Turing Machine. This means it can solve any problem that is computationally solvable, given enough time and resources.
> 
> - **Definition**: A programming language or computational system is Turing complete if it can simulate the computation of any Turing Machine.
> - **Criteria**: The system must have conditional branching (like `if` statements), a form of repetition or looping (like `while` or `for` loops), and the ability to read and write an arbitrary amount of data.

> [!example] Examples of Turing Complete Systems
>
> - **Minecraft Redstone**: Believe it or not, you can build a fully functional computer inside Minecraft using Redstone circuits. Players have created everything from calculators to full-fledged CPUs, making Minecraft a playground for digital logic and Turing completeness.
> - **Magic: The Gathering**: In 2019, researchers proved that a sufficiently complex game of Magic: The Gathering can simulate a Turing Machine. This means you could, in theory, decide computational problems while battling with your favorite cards.
> - **Conway's Game of Life**: This cellular automaton, consisting of simple rules for cell survival and reproduction, can simulate a universal constructor. You could say it's like having a tiny, living computer on your screen!
> - **PowerPoint**: Yes, even PowerPoint can be Turing complete. By using slide transitions and hyperlinks in creative ways, you can simulate computational processes. Who knew your next presentation could double as a computing engine?
> - **Baking Recipes**: Imagine a cookbook that is Turing complete. By meticulously following a set of rules (steps), where each ingredient and instruction acts like a state transition, you can bake a cake while theoretically solving any computable problem. It might not be the most efficient way to compute, but it sure is delicious!
> - **Esoteric Programming Languages (Esolang)**: Languages like Brainfuck and Befunge are intentionally designed to be as confusing and impractical as possible, yet they are Turing complete. Writing code in these languages feels like solving a riddle wrapped in an enigma, but it's computationally powerful!

> [!consider] Non-Computable Problems
>
> - **Halting Problem**: The Halting Problem asks **whether a given Turing Machine will halt on a specific input**. Alan Turing proved that no Turing Machine can solve this problem for all possible inputs, making it undecidable.
> - **Entscheidungsproblem**: Proposed by David Hilbert, this problem asks for an algorithm to determine the truth of any mathematical statement. Turing and Alonzo Church independently proved it to be undecidable.
> - **Busy Beaver Problem**: This problem involves finding the maximum number of steps a Turing Machine with a given number of states can execute before halting. It's non-computable because there is no general algorithm to solve it for all cases.
> - **Post Correspondence Problem**: Given two lists of strings, the problem asks whether there is a sequence that concatenates strings from both lists to form the same result. It is known to be undecidable.


> [!idea] Reductions
>
> Reductions are **used to prove non-computability by leveraging known foundational non-computable problems**.
> 
> - **Concept**: If problem A is known to be undecidable and we can show that solving problem B would allow us to solve problem A, then problem B is also undecidable.
> - **Foundation**: The process relies on foundational non-computable problems, such as the Halting Problem, which have been directly proven to be undecidable without reductions.

> [!example] Reducing the "Largest Number Problem" to the Halting Problem
>
> **Problem A (Halting Problem)**: Given a Turing Machine and an input, determine whether the Turing Machine halts on that input.
> 
> **Problem B (Largest Number Problem)**: Find a number that is larger than every other number.
> 
> **Reduction Concept**: To show that Problem B is undecidable, we assume that if we could solve Problem B, then we could solve Problem A. Since Problem A is undecidable, it implies that Problem B is also undecidable.
> 
> **Reduction Steps**:
> 
> 1. **Assume a Solution for Problem B**: Suppose we have a hypothetical Turing Machine, `M_B`, that can solve Problem B, i.e., it can find a number larger than every other number.
> 
> 2. **Construct a Turing Machine for Problem A**:
>    - We need to determine if a given Turing Machine, `M_A`, halts on a specific input, `w`.
>    - We use `M_B` to help with this by constructing a new Turing Machine, `M_C`, that operates as follows:
>      - `M_C` simulates `M_A` on input `w`.
>      - If `M_A` halts, `M_C` proceeds to invoke `M_B` to find the largest number.
>      - Since `M_B` is assumed to solve the "largest number problem," it will attempt to find a number larger than every other number.
>      - This leads to a logical contradiction because there is no largest number (you can always add 1 to any given number).
> 
> 3. **Conclusion**: Since assuming `M_B` solves Problem B leads to a contradiction, no such Turing Machine `M_B` can exist. Therefore, Problem B (finding a number larger than every other number) is undecidable.
