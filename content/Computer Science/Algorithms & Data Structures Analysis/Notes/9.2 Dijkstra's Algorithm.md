> [!idea] Dijkstra's Algorithm
>
> Dijkstra's algorithm **finds the shortest path between a starting node and all other nodes in a non-negative weighted graph**.
>
> The algorithm maintains two sets of nodes:
> - Visited nodes: Nodes for which the shortest path from the starting node has been found.
> - Unvisited nodes: Nodes for which the shortest path has not yet been determined.
>
> With the starting node and repeatedly performs the following steps:
> 1. Select the unvisited node with the smallest distance from the starting node.
> 2. Mark the selected node as visited.
> 3. Update the distances of the selected node's unvisited neighbors if a shorter path is found through the selected node.
>
> The algorithm continues this process until all nodes are visited or the desired destination node is reached.
>
> ![[Dijkstra's Algorithm.png|500]]
>
> By always selecting the unvisited node with the smallest distance and updating the distances of its neighbors, Dijkstra's algorithm gradually expands the set of visited nodes and finds the shortest paths from the starting node to all other nodes in the graph.
>
> The algorithm relies on the property that a segment of the shortest path between two nodes is itself the shortest path between any two nodes within that segment. This allows Dijkstra's algorithm to make locally optimal choices at each step, ultimately leading to the globally optimal shortest paths.



> [!consider] Dijkstra's Algorithm Intuition
>
> The intuition behind Dijkstra's algorithm can be understood using the analogy of a spreading ripple. Imagine dropping a pebble into a still pond. The ripple expands outward from the point of impact, reaching nearby locations before spreading further.
>
> Similarly, Dijkstra's algorithm starts from the starting node and expands the shortest path tree incrementally. It explores the graph by visiting the node with the shortest distance from the starting node and updating the distances of its neighbors. This process continues until all nodes are visited or the desired destination is reached.
>
> ![[Dijkstra's Algorithm Intuition.png|500]]

> [!idea] Dijkstra's Algorithm: Step-by-Step
>
> Here's a step-by-step explanation of Dijkstra's algorithm:
>
> 1. Initialize distances:
>    - Set the distance of the starting node to 0.
>    - Set the distances of all other nodes to infinity.
>
> 2. Create a priority queue to store nodes based on their distances.
>
> 3. While the priority queue is not empty:
>    - Extract the node with the minimum distance (current node) from the priority queue.
>    - For each unvisited neighbor of the current node:
>      - Calculate the tentative distance to the neighbor through the current node.
>      - If the tentative distance is smaller than the current distance, update the distance and add the neighbor to the priority queue.
>
> 4. Once the priority queue is empty, the shortest paths from the starting node to all other nodes have been found.

> [!example] Dijkstra's Algorithm Walkthrough
>
> Let's walk through an example of Dijkstra's algorithm on a small graph:
>
> ![[Dijkstra's Algorithm Walkthrough.png|500]]
>
> 1. Initialize distances: A = 0, B = ∞, C = ∞, D = ∞, E = ∞
>
> 2. Priority queue: (A, 0)
>
> 3. Extract A, update neighbors:
>    - B = min(∞, 0 + 4) = 4, priority queue: (B, 4)
>    - C = min(∞, 0 + 2) = 2, priority queue: (C, 2), (B, 4)
>
> 4. Extract C, update neighbors:
>    - D = min(∞, 2 + 3) = 5, priority queue: (B, 4), (D, 5)
>    - E = min(∞, 2 + 3) = 5, priority queue: (B, 4), (D, 5), (E, 5)
>
> 5. Extract B, update neighbors:
>    - D = min(5, 4 + 1) = 5, priority queue: (D, 5), (E, 5)
>
> 6. Extract D, update neighbors:
>    - E = min(5, 5 + 2) = 5, priority queue: (E, 5)
>
> 7. Extract E, priority queue is empty, algorithm terminates.
>
> The shortest paths from A are: A → B (cost 4), A → C (cost 2), A → D (cost 5), A → E (cost 5).

> [!idea] Dijkstra's Algorithm: Pseudocode
>
> Here's the pseudocode for Dijkstra's algorithm:
>
> ```
> function dijkstra(graph, startNode):
>     distances = {}
>     priorityQueue = empty priority queue
>     
>     for each node in graph:
>         distances[node] = infinity
>     distances[startNode] = 0
>     
>     priorityQueue.enqueue(startNode, 0)
>     
>     while priorityQueue is not empty:
>         currentNode = priorityQueue.dequeue()
>         
>         for each neighbor of currentNode:
>             tentativeDistance = distances[currentNode] + edgeWeight(currentNode, neighbor)
>             if tentativeDistance < distances[neighbor]:
>                 distances[neighbor] = tentativeDistance
>                 priorityQueue.enqueue(neighbor, tentativeDistance)
>     
>     return distances
> ```

> [!idea] Dijkstra's Algorithm: Time Complexity
>
> The time complexity of Dijkstra's algorithm depends on the implementation of the priority queue:
>
> - Using a binary heap: O((V + E) log V)
>   - Inserting and extracting nodes from the priority queue takes O(log V) time.
>   - In the worst case, we may insert and extract all nodes, resulting in O(V log V) time.
>   - We also process each edge once, which takes O(E) time.
>
> - Using a Fibonacci heap: O(V log V + E)
>   - Inserting nodes into the priority queue takes O(1) amortized time.
>   - Extracting nodes takes O(log V) amortized time.
>   - Processing edges takes O(E) time.
>
> Here, V represents the number of nodes (vertices) and E represents the number of edges in the graph.

> [!consider] Dijkstra's Algorithm: Limitations
>
> Dijkstra's algorithm has certain limitations:
>
> - It assumes non-negative edge weights. If the graph contains negative edge weights, Dijkstra's algorithm may not find the correct shortest paths.
>
> - It is not designed to handle graphs with negative cycles (cycles with a total negative weight). In the presence of negative cycles, the shortest path problem is not well-defined.
>
> For graphs with negative edge weights or negative cycles, alternative algorithms like the Bellman-Ford algorithm or the Floyd-Warshall algorithm can be used.

> [!idea] Dijkstra's Algorithm: Applications
>
> Dijkstra's algorithm has numerous real-world applications, including:
>
> - Routing in communication networks: Finding the shortest path for data transmission between network nodes.
>
> - GPS navigation: Determining the shortest route between two locations on a map.
>
> - Airline route optimization: Finding the most cost-effective or time-efficient routes between airports.
>
> - Robotics: Planning the optimal path for a robot to navigate through an environment.
>
> - Social networks: Finding the shortest path or the degree of separation between users.
>
> Dijkstra's algorithm serves as a fundamental building block in many shortest path and graph traversal problems, making it a crucial tool in various domains.

These callouts provide a comprehensive explanation of Dijkstra's algorithm, covering its intuition, step-by-step process, pseudocode, time complexity, limitations, and real-world applications. The motivations behind each callout ensure that readers grasp the significance and practical relevance of the algorithm in solving the single-source shortest path problem.