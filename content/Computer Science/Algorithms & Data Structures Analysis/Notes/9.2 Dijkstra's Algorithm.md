

> [!idea] Dijkstra's Algorithm
>
> Dijkstra's algorithm is a way to **find the shortest path from a starting node to all other nodes in a graph**, where each edge has a non-negative weight. The algorithm **keeps track of the distances from the starting node to each node in the graph** and updates these distances as it progresses.
>
> Here's how the algorithm works:
> 1. Maintain two sets - visited nodes and unvisited nodes. 
>
> 2. Choose a starting node and mark it as visited. Consider the distance from the starting node to itself as 0 and the distances to all other nodes as infinity.
>
> 3. Look at the edges coming out of the starting node. Update the distances to the nodes connected by these edges. If there's no edge between the starting node and a particular node, the distance remains infinity.
>
> 4. Pick the unvisited node with the smallest distance from the starting node and mark it as visited.
>
> 5. Update the distances to the other nodes by considering the edges coming out of the newly visited node. If the distance to a node through the newly visited node is smaller than the current distance, update the distance.
>
> 6. Repeat steps 3 and 4 until all nodes are visited or the destination node is reached.
>
> ![[Dijkstra Animation.mp4]]
>
> In the example above, we start at node 0. We mark 0 as visited and update the distances to its neighbours 1 and 2. Then, we pick the unvisited node with the smallest distance (2) and mark it as visited. We update the distances to B's neighbours (1, 3 and 4). We continue this process until all nodes are visited.
>
> By repeatedly selecting the unvisited node with the smallest distance and updating the distances based on the edges, Dijkstra's algorithm finds the shortest paths from the starting node to all other nodes in the graph.

> [!idea] Implementation
> 1. Maintain two sets - visited nodes and unvisited nodes:
>    - We can use a boolean array `visited` to keep track of visited nodes. Initially, all nodes are marked as unvisited (false).
>    - The unvisited nodes can be represented by the nodes in the graph that are not yet marked as visited.
> 
> 2. Choose a starting node and mark it as visited. Consider the distance from the starting node to itself as 0 and the distances to all other nodes as infinity:
>    - We can use an array `distances` to store the distances from the starting node to each node in the graph.
>    - Initialize `distances[startNode] = 0` and set the distances to all other nodes as infinity.
>    - Mark the starting node as visited in the `visited` array.
> 
> 3. Look at the edges coming out of the starting node. Update the distances to the nodes connected by these edges. If there's no edge between the starting node and a particular node, the distance remains infinity:
>    - Iterate through the neighbors of the starting node.
>    - For each neighbor, update the distance in the `distances` array if the distance through the starting node is smaller than the current distance.
> 
> 4. Pick the unvisited node with the smallest distance from the starting node and mark it as visited:
>    - This is where a priority queue comes into play. We use a priority queue to efficiently select the unvisited node with the smallest distance.
>    - The priority queue stores nodes along with their distances from the starting node.
>    - By using a priority queue, we can retrieve the node with the smallest distance in O(log n) time, which is faster than linearly searching through all unvisited nodes.
> 
> 5. Update the distances to the other nodes by considering the edges coming out of the newly visited node. If the distance to a node through the newly visited node is smaller than the current distance, update the distance:
>    - Iterate through the neighbors of the newly visited node.
>    - For each neighbor, calculate the distance through the newly visited node by adding the distance from the starting node to the newly visited node and the edge weight between the newly visited node and the neighbor.
>    - If the calculated distance is smaller than the current distance in the `distances` array, update the distance and add the neighbor to the priority queue with the updated distance.
> 
> 6. Repeat steps 4 and 5 until all nodes are visited or the destination node is reached:
>    - Continue selecting the unvisited node with the smallest distance from the priority queue and updating the distances until the priority queue is empty.
>    - At this point, the `distances` array will contain the shortest distances from the starting node to all other nodes in the graph.
> 
> ```c
> function dijkstra(graph, startNode):
>     visited = new Array(graph.size())
>     distances = new Array(graph.size())
>     priorityQueue = new PriorityQueue()
>     
>     for each node in graph:
>         visited[node] = false
>         distances[node] = INFINITY
>     
>     visited[startNode] = true
>     distances[startNode] = 0
>     priorityQueue.enqueue(startNode, 0)
>     
>     while priorityQueue is not empty:
>         currentNode = priorityQueue.dequeue()
>         
>         for each neighbor of currentNode:
>             if not visited[neighbor]:
>                 distance = distances[currentNode] + getEdgeWeight(currentNode, neighbor)
>                 
>                 if distance < distances[neighbor]:
>                     distances[neighbor] = distance
>                     priorityQueue.enqueue(neighbor, distance)
>         
>         visited[currentNode] = true
>     
>     return distances
> ```
> 
> The key points to note in the implementation are:
> - We use a boolean array `visited` to keep track of visited nodes.
> - We use an array `distances` to store the distances from the starting node to each node.
> - We use a priority queue to efficiently select the unvisited node with the smallest distance. The priority queue allows us to retrieve the node with the smallest distance in logarithmic time, which improves the overall efficiency of the algorithm.


> [!idea] Dijkstra's Algorithm: Time Complexity
>
> The time complexity of Dijkstra's algorithm depends on the implementation of the priority queue:
>
> - Using a binary heap: O((V + E) log V)
>   - Inserting and extracting nodes from the priority queue takes O(log V) time.
>   - In the worst case, we may insert and extract all nodes, resulting in O(V log V) time.
>   - We also process each edge once, which takes O(E) time.
>
> - Using a Fibonacci heap: O(V log V + E)
>   - Inserting nodes into the priority queue takes O(1) amortized time.
>   - Extracting nodes takes O(log V) amortized time.
>   - Processing edges takes O(E) time.
>
> Here, V represents the number of nodes (vertices) and E represents the number of edges in the graph.
