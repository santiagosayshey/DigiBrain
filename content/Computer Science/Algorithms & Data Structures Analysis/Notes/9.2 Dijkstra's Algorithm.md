

> [!idea] Dijkstra's Algorithm
>
> Dijkstra's algorithm is a way to **find the shortest path from a starting node to all other nodes in a graph**, where each edge has a non-negative weight. The algorithm **keeps track of the distances from the starting node to each node in the graph** and updates these distances as it progresses.
>
> Here's how the algorithm works:
> 1. Maintain two sets - visited nodes and unvisited nodes.
>
> 2. Choose a starting node and mark it as visited. Consider the distance from the starting node to itself as 0 and the distances to all other nodes as infinity.
>
> 3. Look at the edges coming out of the starting node. Update the distances to the nodes connected by these edges. If there's no edge between the starting node and a particular node, the distance remains infinity.
>
> 4. For each node updated in step 3, record the starting node as its predecessor.
>
> 5. Pick the unvisited node with the smallest distance from the starting node and mark it as visited.
>
> 6. Update the distances to the other nodes by considering the edges coming out of the newly visited node. If the distance to a node through the newly visited node is smaller than the current distance, update the distance and set the newly visited node as the predecessor for these nodes.
>
> 7. Repeat steps 3 through 6 until all nodes are visited or the destination node is reached.
>
> 8. To reconstruct the shortest path to any node, trace back from the node to the starting node using the predecessors recorded.
>
> ![[Dijkstra Animation.mp4]]
>
> In the example above, we start at node 0. We mark 0 as visited and update the distances to its neighbours 1 and 2. Then, we pick the unvisited node with the smallest distance (2) and mark it as visited. We update the distances to B's neighbours (1, 3 and 4). We continue this process until all nodes are visited.
>
> By repeatedly selecting the unvisited node with the smallest distance and updating the distances based on the edges, Dijkstra's algorithm finds the shortest paths from the starting node to all other nodes in the graph.


> [!consider] **Using a Priority Queue in Dijkstra's Algorithm**
>
> A **priority queue** implements efficient selection of the next node with the smallest tentative distance. 
>
> 1. **Initialize the Priority Queue:** Begin by adding the starting node into the priority queue with a distance of zero. All other nodes start with a distance of infinity.
>
> 2. **Process the Queue:** Remove the node with the smallest distance from the priority queue to process next.
>
> 3. **Update Distances:** For each neighboring node, if traveling to it from the current node offers a shorter path than previously known, update its distance and add it to the priority queue with this new shorter distance.
>
> 4. **Mark as Visited:** Nodes are marked as visited once they are removed from the queue to prevent reprocessing.
>
> 5. **Repeat:** Continue this process until the priority queue is empty.
>
> 6. **Path Reconstruction:** To determine the shortest path from the start node to any other, follow the predecessor links for each node.
>
> **Example:**
> - Suppose we have nodes `A`, `B`, and `C` where `A` connects to both `B` and `C`. `A` to `B` has a distance of 1, and `A` to `C` has a distance of 4. `B` also connects to `C` with a distance of 2.
> - **Initialization:** `A` is pushed into the priority queue with a distance of `0`, `B` and `C` with infinity.
> - **Processing `A`:** `A` is removed; distances to `B` (1) and `C` (4) are updated and added to the queue.
> - **Processing `B`:** `B` is next with a distance of `1`. Update `C`â€™s distance through `B` to `3` and adjust in the queue.
> - **Processing `C`:** Finally, `C` is processed with the shortest distance of `3`.
>
> This use of a priority queue reduces the computational complexity of finding the node with the smallest distance, making the algorithm faster and more suitable for large graphs.


> [!idea] Dijkstra's Algorithm: Time Complexity
>
> The time complexity of Dijkstra's algorithm depends on the implementation of the priority queue:
>
> - Using a binary heap: O((V + E) log V)
>   - Inserting and extracting nodes from the priority queue takes O(log V) time.
>   - In the worst case, we may insert and extract all nodes, resulting in O(V log V) time.
>   - We also process each edge once, which takes O(E) time.
>
> - Using a Fibonacci heap: O(V log V + E)
>   - Inserting nodes into the priority queue takes O(1) amortized time.
>   - Extracting nodes takes O(log V) amortized time.
>   - Processing edges takes O(E) time.
>
> Here, V represents the number of nodes (vertices) and E represents the number of edges in the graph.






