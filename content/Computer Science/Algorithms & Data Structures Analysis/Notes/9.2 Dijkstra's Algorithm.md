

> [!idea] Dijkstra's Algorithm
>
> Dijkstra's algorithm is a way to **find the shortest path from a starting node to all other nodes in a graph**, where each edge has a non-negative weight. The algorithm **keeps track of the distances from the starting node to each node in the graph** and updates these distances as it progresses.
>
> Here's how the algorithm works:
> 1. Maintain two sets - visited nodes and unvisited nodes. 
>
> 2. Choose a starting node and mark it as visited. Consider the distance from the starting node to itself as 0 and the distances to all other nodes as infinity.
>
> 3. Look at the edges coming out of the starting node. Update the distances to the nodes connected by these edges. If there's no edge between the starting node and a particular node, the distance remains infinity.
>
> 4. Pick the unvisited node with the smallest distance from the starting node and mark it as visited.
>
> 5. Update the distances to the other nodes by considering the edges coming out of the newly visited node. If the distance to a node through the newly visited node is smaller than the current distance, update the distance.
>
> 6. Repeat steps 3 and 4 until all nodes are visited or the destination node is reached.
>
> ![[Dijkstra Animation.mp4]]
>
> In the example above, we start at node 0. We mark 0 as visited and update the distances to its neighbours 1 and 2. Then, we pick the unvisited node with the smallest distance (2) and mark it as visited. We update the distances to B's neighbours (1, 3 and 4). We continue this process until all nodes are visited.
>
> By repeatedly selecting the unvisited node with the smallest distance and updating the distances based on the edges, Dijkstra's algorithm finds the shortest paths from the starting node to all other nodes in the graph.

> [!consider] Dijkstra's Algorithm and Edge Weights
>
> Dijkstra's algorithm relies on the edge weights to determine the shortest paths. The weight of an edge represents the cost or distance between two nodes. By considering the edges and their weights, the algorithm can find the path that minimizes the total cost from the starting node to each node in the graph.
>
> It's important to note that Dijkstra's algorithm assumes non-negative edge weights. If there are negative edge weights, the algorithm might not find the correct shortest paths, and other algorithms like the Bellman-Ford algorithm should be used instead.
>
> ![[Dijkstra's Algorithm Edge Weights.png|500]]
>
> In the example above, the edges have different weights. Dijkstra's algorithm takes these weights into account when updating the distances and determining the shortest paths. The algorithm ensures that the path with the smallest total weight is chosen as the shortest path.



> [!idea] Dijkstra's Algorithm: Step-by-Step
>
> Here's a step-by-step explanation of Dijkstra's algorithm:
>
> 1. Initialize distances:
>    - Set the distance of the starting node to 0.
>    - Set the distances of all other nodes to infinity.
>
> 2. Create a priority queue to store nodes based on their distances.
>
> 3. While the priority queue is not empty:
>    - Extract the node with the minimum distance (current node) from the priority queue.
>    - For each unvisited neighbor of the current node:
>      - Calculate the tentative distance to the neighbor through the current node.
>      - If the tentative distance is smaller than the current distance, update the distance and add the neighbor to the priority queue.
>
> 4. Once the priority queue is empty, the shortest paths from the starting node to all other nodes have been found.

> [!example] Dijkstra's Algorithm Walkthrough
>
> Let's walk through an example of Dijkstra's algorithm on a small graph:
>
> ![[Dijkstra's Algorithm Walkthrough.png|500]]
>
> 1. Initialize distances: A = 0, B = ∞, C = ∞, D = ∞, E = ∞
>
> 2. Priority queue: (A, 0)
>
> 3. Extract A, update neighbors:
>    - B = min(∞, 0 + 4) = 4, priority queue: (B, 4)
>    - C = min(∞, 0 + 2) = 2, priority queue: (C, 2), (B, 4)
>
> 4. Extract C, update neighbors:
>    - D = min(∞, 2 + 3) = 5, priority queue: (B, 4), (D, 5)
>    - E = min(∞, 2 + 3) = 5, priority queue: (B, 4), (D, 5), (E, 5)
>
> 5. Extract B, update neighbors:
>    - D = min(5, 4 + 1) = 5, priority queue: (D, 5), (E, 5)
>
> 6. Extract D, update neighbors:
>    - E = min(5, 5 + 2) = 5, priority queue: (E, 5)
>
> 7. Extract E, priority queue is empty, algorithm terminates.
>
> The shortest paths from A are: A → B (cost 4), A → C (cost 2), A → D (cost 5), A → E (cost 5).

> [!idea] Dijkstra's Algorithm: Pseudocode
>
> Here's the pseudocode for Dijkstra's algorithm:
>
> ```
> function dijkstra(graph, startNode):
>     distances = {}
>     priorityQueue = empty priority queue
>     
>     for each node in graph:
>         distances[node] = infinity
>     distances[startNode] = 0
>     
>     priorityQueue.enqueue(startNode, 0)
>     
>     while priorityQueue is not empty:
>         currentNode = priorityQueue.dequeue()
>         
>         for each neighbor of currentNode:
>             tentativeDistance = distances[currentNode] + edgeWeight(currentNode, neighbor)
>             if tentativeDistance < distances[neighbor]:
>                 distances[neighbor] = tentativeDistance
>                 priorityQueue.enqueue(neighbor, tentativeDistance)
>     
>     return distances
> ```

> [!idea] Dijkstra's Algorithm: Time Complexity
>
> The time complexity of Dijkstra's algorithm depends on the implementation of the priority queue:
>
> - Using a binary heap: O((V + E) log V)
>   - Inserting and extracting nodes from the priority queue takes O(log V) time.
>   - In the worst case, we may insert and extract all nodes, resulting in O(V log V) time.
>   - We also process each edge once, which takes O(E) time.
>
> - Using a Fibonacci heap: O(V log V + E)
>   - Inserting nodes into the priority queue takes O(1) amortized time.
>   - Extracting nodes takes O(log V) amortized time.
>   - Processing edges takes O(E) time.
>
> Here, V represents the number of nodes (vertices) and E represents the number of edges in the graph.

> [!consider] Dijkstra's Algorithm: Limitations
>
> Dijkstra's algorithm has certain limitations:
>
> - It assumes non-negative edge weights. If the graph contains negative edge weights, Dijkstra's algorithm may not find the correct shortest paths.
>
> - It is not designed to handle graphs with negative cycles (cycles with a total negative weight). In the presence of negative cycles, the shortest path problem is not well-defined.
>
> For graphs with negative edge weights or negative cycles, alternative algorithms like the Bellman-Ford algorithm or the Floyd-Warshall algorithm can be used.

> [!idea] Dijkstra's Algorithm: Applications
>
> Dijkstra's algorithm has numerous real-world applications, including:
>
> - Routing in communication networks: Finding the shortest path for data transmission between network nodes.
>
> - GPS navigation: Determining the shortest route between two locations on a map.
>
> - Airline route optimization: Finding the most cost-effective or time-efficient routes between airports.
>
> - Robotics: Planning the optimal path for a robot to navigate through an environment.
>
> - Social networks: Finding the shortest path or the degree of separation between users.
>
> Dijkstra's algorithm serves as a fundamental building block in many shortest path and graph traversal problems, making it a crucial tool in various domains.

These callouts provide a comprehensive explanation of Dijkstra's algorithm, covering its intuition, step-by-step process, pseudocode, time complexity, limitations, and real-world applications. The motivations behind each callout ensure that readers grasp the significance and practical relevance of the algorithm in solving the single-source shortest path problem.