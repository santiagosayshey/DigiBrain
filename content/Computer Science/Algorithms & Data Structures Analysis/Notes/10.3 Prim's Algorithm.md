> [!idea] Prim's Algorithm
>
> Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, weighted, and undirected graph.
>
> The algorithm operates by building the MST one vertex at a time, starting from an arbitrary vertex and greedily adding the lowest-cost edge that connects a vertex in the MST to a vertex not yet included.
>
> The steps of the algorithm are as follows:
>
> 1. Initialize an empty set `mst` to store the edges of the MST.
> 2. Select an arbitrary starting vertex, and add it to `mst`.
> 3. Create a priority queue `pq` to store the edges connecting vertices in `mst` to vertices not in `mst`, ordered by their weights.
> 4. While `mst` does not contain all vertices of the graph:
>    - Extract the minimum-cost edge `(u, v)` from `pq`, where `u` is in `mst` and `v` is not.
>    - Add `v` to `mst`.
>    - Add all edges connecting `v` to vertices not in `mst` to `pq`.
> 5. The set `mst` now contains all the edges of the MST.
>
> ```python
> def prim(graph):
>     mst = set()
>     start_vertex = graph.vertices[0]  # Choose an arbitrary starting vertex
>     mst.add(start_vertex)
>     pq = PriorityQueue()
>
>     for edge in graph.edges[start_vertex]:
>         pq.push(edge)
>
>     while len(mst) < len(graph.vertices):
>         min_edge = pq.pop()
>         u, v, weight = min_edge
>
>         if v not in mst:
>             mst.add(v)
>             for edge in graph.edges[v]:
>                 if edge.end not in mst:
>                     pq.push(edge)
>
>     return mst
> ```

> [!motivation] Motivation
>
> In many real-world scenarios, we need to connect a set of points or nodes in a way that minimizes the total cost or weight of the connections. For example:
>
> - **Computer Networks**: Connect devices (routers, switches, etc.) with minimal cabling or infrastructure cost.
> - **Transportation Networks**: Build roads or railways to connect cities or locations with minimal construction cost.
> - **Utility Networks**: Connect households or facilities to water, electricity, or communication services with minimal resource usage.
>
> In these situations, we want to **ensure that all points or nodes are connected (forming a single component), while minimizing the overall cost or weight of the connections**. This leads us to the Minimum Spanning Tree (MST) problem, which the Jarník-Prim Algorithm aims to solve efficiently.

> [!example] Example
>
> Consider a computer network where nodes represent computers, and edges represent possible connections. Edge costs/weights represent the cost of establishing connections. The goal is to connect all computers while minimizing the total infrastructure cost.
>
> ![[Prim Example.png]]
>
> Let's walk through the steps of Jarník-Prim Algorithm:
>
> 1. Initialize an empty set `mst` and a priority queue `pq`.
> 2. Choose an arbitrary starting vertex, say A, and add it to `mst`.
> 3. Add the edges (A, B) with cost 2, (A, C) with cost 3, and (A, D) with cost 5 to `pq`.
> 4. Extract the minimum-cost edge (A, B) from `pq`, add B to `mst`, and add the edges (B, C) with cost 1 and (B, D) with cost 4 to `pq`.
> 5. Extract the minimum-cost edge (B, C) from `pq`, add C to `mst`, and add the edge (C, D) with cost 5 to `pq`.
> 6. Extract the minimum-cost edge (B, D) from `pq`, add D to `mst`, and add no new edges since all vertices are now in `mst`.
>
> The resulting MST contains the edges (A, B), (B, C), and (B, D), with a total cost/weight of 2 + 1 + 4 = 7, which is the minimum among all possible spanning trees.

> [!consider] Time Complexity Analysis
>
> Let's analyze the time complexity of the Jarník-Prim Algorithm:
>
> - The initialization step takes $O(V)$ time, where $V$ is the number of vertices in the graph.
> - Adding the initial edges to the priority queue takes $O(E \log E)$ time, where $E$ is the number of edges in the graph. This is because we need to add at most $E$ edges to the priority queue, and each insertion operation takes $O(\log E)$ time.
> - The main loop of the algorithm runs $V - 1$ times, as we need to add $V - 1$ edges to the MST to connect all vertices.
>   - In each iteration, extracting the minimum-cost edge takes $O(\log E)$ time.
>   - Adding new edges to the priority queue takes $O(E_v \log E)$ time, where $E_v$ is the number of edges connected to the newly added vertex. Over all iterations, this step takes $O(E \log E)$ time, as each edge is added to the priority queue at most once.
> - Therefore, the overall time complexity of the Jarník-Prim Algorithm is $O((V + E) \log E)$, which simplifies to $O(E \log E)$ for a connected graph, where $E \geq V - 1$.

> [!consider] Comparison with Kruskal's Algorithm
>
> Both Kruskal's Algorithm and the Jarník-Prim Algorithm are greedy algorithms used to find the Minimum Spanning Tree (MST) of a connected, weighted, and undirected graph. However, they differ in their approach:
>
> **Kruskal's Algorithm**:
> - Kruskal's Algorithm processes edges in non-decreasing order of their weights, adding them to the MST if they do not create a cycle.
> - It uses a union-find data structure to efficiently detect cycles and maintain disjoint sets of vertices.
> - The time complexity of Kruskal's Algorithm is $O(E \log E)$, where $E$ is the number of edges in the graph.
>
> **Jarník-Prim Algorithm**:
> - The Jarník-Prim Algorithm builds the MST incrementally, starting from an arbitrary vertex and greedily adding the lowest-cost edge that connects a vertex in the MST to a vertex not yet included.
> - It uses a priority queue to efficiently retrieve the minimum-cost edge at each step.
> - The time complexity of the Jarník-Prim Algorithm is also $O(E \log E)$.
>
> While both algorithms have the same time complexity for dense graphs, Kruskal's Algorithm may be more efficient for sparse graphs, as it does not need to initialize and maintain a priority queue. On the other hand, the Jarník-Prim Algorithm may be more intuitive and easier to implement in practice.
>
> The choice between the two algorithms often depends on the specific problem constraints, the graph structure, and the available implementation resources.

I have followed the requested structure and formatting, and I have included examples, code snippets, and time complexity analysis. Please let me know if you need any clarification or have additional requirements.