

> [!idea] Prim's Algorithm
>
> Prim's Algorithm is a greedy algorithm that **finds a Minimum Spanning Tree (MST)** for a connected, undirected, and weighted graph. It operates by **iteratively building the MST**, starting from an arbitrary vertex and **adding the shortest possible edge at each step** that connects a new vertex to the growing tree.
>
> The algorithm follows these steps:
>
> 1. Initialize an empty set `visited` to keep track of visited vertices, and an empty set `mst` to store the edges in the Minimum Spanning Tree.
> 2. Choose an arbitrary starting vertex `A` and add it to `visited`.
> 3. Examine every node reachable from nodes inside `visited` and choose the smallest edge. Add the node that connects from this edge to `visited`, and add the edge to the `mst` set.
>    - If the smallest edge connects two nodes that have already been visited, we discard this edge.
> 4. Repeat this process until all nodes have been reached. The `mst` set will now contain all the edges in the Minimum Spanning Tree.
>
> More formally, the algorithm can be described as follows:
>
> 1. Initialize an empty set `visited` to keep track of visited vertices.
> 2. Initialize an empty set `mst` to store the edges in the Minimum Spanning Tree.
> 3. Initialize a priority queue `pq` to store the edges, ordered by their weights.
> 4. Add the starting vertex `s` to `visited`.
> 5. Add all the edges incident on `s` to `pq`.
> 6. While `visited` does not contain all vertices of `G`:
>     1. Extract the minimum edge `(u, v)` from `pq` such that `u` is in `visited` and `v` is not in `visited`.
>     2. Add `v` to `visited`.
>     3. Add `(u, v)` to `mst`.
>     4. Add all the edges incident on `v` (that are not already in `pq`) to `pq`.
> 7. Return `mst`.
>
> The final set `mst` will contain all the edges of the Minimum Spanning Tree.

> [!example] Example of Prim's Algorithm
>
> Let's consider the following example graph to illustrate how Prim's Algorithm works:
>
> ![[Prim Grapg.png|400]]
>
> Now, let's apply Prim's Algorithm to find the MST, starting from vertex 'A':
>
> 1. Initialize an empty set `mst` and choose the starting vertex 'A'.
> 2. Create a priority queue `pq` and add the edges connected to 'A': (A, B) with weight 2, (A, C) with weight 3, (A,D) with a weight of 3
> 3. Extract the minimum-weight edge (A, B) from `pq` and add it to `mst` (A,B)
> 4. Mark B as visited, and add the edges connected to 'B' but not in `mst` to `pq`: (B, C) with weight 4 and (B, E) with weight 3.
> 5. Extract the minimum-weight edge (A, C) from `pq` and add it to `mst`.
> 6. Mark C as visited, and add the edges connected to 'C' but not in `mst` to `pq`: (C,D) with weight 5, (C,F) with weight 6 and (C,E) with weight 1.
> 7. Extract the minimum weight edge (C,E) from `pq` and add it to `mst`.
> 8. Mark E as visited, and add the edges connected to 'E' but not in `mst` to `pq`: (E,F) with weight 8.
> 9. The minimum weight edge (B,E) connects two visited nodes. Discard this edge.
> 10. The minimum weight edge (B,C) connects two visited nodes. Discard this edge.
> 11. The minimum weight edge (C,D) connects two visited nodes. Discard this edge.
> 12. Extract the minimum weight edge (C,F) from `pq` and add it to `mst`.
> 13. Mark F as visited, and add the edges connected to 'F' but not in `mst` to `pq`: (F,G) with weight 9.
> 14. The minimum weight edge (D,F) connects two visited nodes. Discard this edge.
> 15. The minimum weight edge (E,F) connects two visited nodes. Discard this edge.
> 16. Extract the minimum weight edge (F,G) from `pq` and add it to `mst`.
> 17. Mark G as visited. This is the final node!
> 
> The resulting MST contains the edges: (A, B), (A, D), (A, C), (C, E), (C,F), (F,G) with a total weight of 2+3+3+1+6+9 = 25.
>
![[Prim Example 1.png]]

> [!consider] Time Complexity Analysis
>
> Let's analyze the time complexity of Prim's Algorithm and the priority queue data structure used in the algorithm.
>
> **Prim's Algorithm:**
> - The main loop of Prim's Algorithm iterates over the edges in the priority queue. In the worst case, it processes all edges in the graph, which takes $O(E)$ time, where $E$ is the number of edges.
> - For each processed edge, the following operations are performed:
>   - Extracting the minimum-weight edge from the priority queue takes $O(\log V)$ time, where $V$ is the number of vertices, assuming an efficient priority queue implementation like a binary heap or Fibonacci heap.
>   - Checking if the vertices are in the same connected component takes $O(\alpha(V))$ time using a union-find data structure, where $\alpha$ is the inverse Ackermann function, which grows very slowly.
>   - Adding edges to the priority queue takes $O(\log V)$ time per edge.
> - Therefore, the overall time complexity of Prim's Algorithm is $O((E + V) \log V)$ when using a binary heap for the priority queue and union-find for connected component tracking. This can be further optimized to $O(E \log V)$ using a Fibonacci heap for the priority queue.

> [!consider] Comparison with Kruskal's Algorithm
>
> Both Prim's Algorithm and Kruskal's Algorithm solve the Minimum Spanning Tree (MST) problem, but they take different approaches:
>
> **Kruskal's Algorithm:**
> - Kruskal's Algorithm is based on processing the edges in increasing order of their weights.
> - It starts with an empty set and iteratively adds edges that do not create cycles in the graph, using a union-find data structure to detect cycles.
> - The time complexity of Kruskal's Algorithm is $O(E \log E)$, where $E$ is the number of edges, due to the sorting step and the union-find operations.
>
> **Prim's Algorithm:**
> - Prim's Algorithm is based on growing a single tree from a starting vertex by adding the shortest possible edge that connects a new vertex to the growing tree.
> - It uses a priority queue to efficiently find the minimum-weight edge at each step.
> - The time complexity of Prim's Algorithm is $O((E + V) \log V)$ or $O(E \log V)$ when using a Fibonacci heap, where $V$ is the number of vertices.
>
> In terms of efficiency, Prim's Algorithm tends to be more efficient for dense graphs, where the number of edges $E$ is close to $V^2$, as its time complexity becomes $O(V^2 \log V)$. In contrast, Kruskal's Algorithm tends to be more efficient for sparse graphs, where the number of edges $E$ is much smaller than $V^2$, as its time complexity becomes $O(E \log E)$.
>
> Both algorithms share the same goal of finding the MST, but they differ in their approach and the underlying data structures used, leading to different time complexities and suitability for different graph densities.

> [!consider] Handling Disconnected Graphs
>
> Both Prim's Algorithm and Kruskal's Algorithm assume that the input graph is connected. However, in some cases, the input graph may be disconnected, consisting of multiple connected components.
>
> In such scenarios, both algorithms will produce a Minimum Spanning Forest (MSF) instead of a single Minimum Spanning Tree (MST). The MSF consists of the minimum spanning trees of each connected component in the graph.
>
> To handle disconnected graphs, we can modify the algorithms as follows:
>
> **Prim's Algorithm:**
> - Run Prim's Algorithm starting from an arbitrary vertex.
> - After the algorithm finishes, check if there are any remaining unvisited vertices in the graph.
> - If unvisited vertices exist, start the algorithm again from one of the unvisited vertices, and continue this process until all vertices are included in the MSF.
>
> **Kruskal's Algorithm:**
> - Run Kruskal's Algorithm as usual, adding edges that do not form cycles.
> - After the algorithm finishes, check if the resulting forest contains all vertices from the original graph.
> - If some vertices are not included, it means they belong to different connected components, and the resulting forest is the MSF.
>
> In both cases, the time complexity remains the same as for connected graphs, but the algorithms may need to be run multiple times, once for each connected component in the graph.

> [!consider] Handling Negative Edge Weights
>
> Both Prim's Algorithm and Kruskal's Algorithm assume that the edge weights in the input graph are non-negative. However, in some cases, the graph may have negative edge weights.
>
> When negative edge weights are present, the problem of finding the Minimum Spanning Tree (MST) becomes more complex, and the greedy approaches used by Prim's and Kruskal's algorithms may not work correctly.
>
> To handle negative edge weights, we need to use a different algorithm, such as the Bellman-Ford algorithm or the Chu-Liu/Edmonds' algorithm, which can handle negative edge weights and detect negative cycles in the graph.
>
> The Bellman-Ford algorithm has a time complexity of $O(VE)$, where $V$ is the number of vertices and $E$ is the number of edges. It can handle negative edge weights and detect negative cycles, but it is less efficient than Prim's and Kruskal's algorithms for graphs with non-negative edge weights.
>
> The Chu-Liu/Edmonds' algorithm is specific to finding the MST in graphs with negative edge weights. It has a time complexity of $O(V^2)$ or $O(E \log V)$, depending on the implementation.
>
> If the input graph is known to have non-negative edge weights, it is more efficient to use Prim's or Kruskal's algorithm. However, if negative edge weights are possible, alternative algorithms like Bellman-Ford or Chu-Liu/Edmonds' should be used to correctly handle the problem.

