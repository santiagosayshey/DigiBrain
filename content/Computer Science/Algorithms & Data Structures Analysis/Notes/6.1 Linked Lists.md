Sure! Here's the note on linked lists without nested callouts:

> [!idea] Linked Lists
>
> Linked lists are a fundamental data structure that consists of a sequence of nodes, where each node contains a value and a reference (or link) to the next node in the sequence. Unlike arrays, linked lists do not store elements in contiguous memory locations, allowing for dynamic memory allocation and efficient insertion and deletion operations.
>
> ```python
> class Node:
>     def __init__(self, data):
>         self.data = data
>         self.next = None
>
> class LinkedList:
>     def __init__(self):
>         self.head = None
> ```
>
> Linked lists can be classified into three main types:
>
> 1. **Singly Linked List**: Each node contains a single reference to the next node in the sequence.
> 2. **Doubly Linked List**: Each node contains references to both the next and previous nodes, allowing for traversal in both directions.
> 3. **Circular Linked List**: The last node in the sequence points back to the first node, forming a circular structure.

> [!consider] Consider the time complexity of linked list operations
>
> | Operation | Time Complexity |
> |-----------|----------------|
> | Access    | O(n)           |
> | Search    | O(n)           |
> | Insertion | O(1) (Start and End) O(n) (Between two nodes)           |
> | Deletion  | O(1) (Start and End) O(n) (Between two nodes)          |
>
> Accessing or searching for an element in a linked list requires traversing the nodes sequentially, resulting in a linear time complexity of O(n). However, insertion and deletion operations can be performed efficiently in constant time O(1) by adjusting the references between nodes.

> [!idea] Linked List Traversal
>
> Traversing a linked list involves visiting each node in the sequence and performing some operation on the node's data. Here's an example of a function to traverse and print the elements of a linked list:
>
> ```python
> def traverse(self):
>     current = self.head
>     while current is not None:
>         print(current.data, end=" ")
>         current = current.next
> ```

> [!idea] Linked List Insertion
>
> Inserting a new node into a linked list can be done at the beginning, end, or at a specific position. Here's an example of a function to insert a new node at the beginning of a linked list:
>
> ```python
> def insert_at_beginning(self, data):
>     new_node = Node(data)
>     new_node.next = self.head
>     self.head = new_node
> ```

> [!idea] Linked List Deletion
>
> Deleting a node from a linked list involves adjusting the references of the surrounding nodes. Here's an example of a function to delete a node with a specific value:
>
> ```python
> def delete_node(self, key):
>     current = self.head
>     if current and current.data == key:
>         self.head = current.next
>         current = None
>         return
>     prev = None
>     while current and current.data != key:
>         prev = current
>         current = current.next
>     if current is None:
>         return
>     prev.next = current.next
>     current = None
> ```

Linked lists offer flexibility and efficient insertion and deletion operations, making them suitable for scenarios where the size of the data is unknown or frequently changing. However, they have higher memory overhead compared to arrays due to the additional storage required for the references.

This note provides an overview of linked lists, their types, time complexity considerations, and examples of common operations like traversal, insertion, and deletion, without using nested callouts.

