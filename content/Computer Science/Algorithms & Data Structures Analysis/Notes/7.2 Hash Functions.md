> [!idea] Hash Functions
>
> A hash function **maps a given key to an index in the underlying array**. The goal is to distribute the keys evenly across the array. A well-designed hash function should be efficient to compute and provide a uniform distribution of keys.
>
> When a key is passed through the hash function, it generates a hash code, which is then mapped to an index within the bounds of the array. This allows for **direct access to the desired element without the need to search through the entire array**.
>
> **Example: Modulo Function**
>
> - The modulo function is a simple hash function that takes the remainder of the key divided by the size of the array.
> - Formula: `hash(key) = key % array_size`
> - Example: If the key is 42 and the array size is 10, the hash function would map the key to index 2 (42 % 10 = 2).
>
> ![[Hash table.png]]

> [!idea] Hash Functions
>
> A hash function **maps a given key to an index in the underlying array**. The goal is to distribute the keys evenly across the array. A well-designed hash function should be efficient to compute and provide a uniform distribution of keys.
>
> When a key is passed through the hash function, it generates a hash code, which is then mapped to an index within the bounds of the array. This allows for **direct access to the desired element without the need to search through the entire array**.
>
> **Example: Modulo Function**
>
> - The modulo function is a simple hash function that takes the remainder of the key divided by the size of the array.
> - Formula: `hash(key) = key % array_size`
> - Example: If the key is 42 and the array size is 10, the hash function would map the key to index 2 (42 % 10 = 2).
>
> ![[Hash table.png]]


> [!consider] Collisions and Hashing Techniques
>
> Hash **collisions** occur when multiple keys map to the same array index. There are two main approaches to handle collisions: open hashing (chaining) and closed hashing (open addressing).
>
> 1. **Open Hashing (Chaining)**
>    - Elements with the same hash are stored as a linked list in the same array slot.
>    - **Advantages**: 
>      - Ensures referential integrity by maintaining a correct and navigable link for each key-value pair, despite collisions.
>      - The average length of the list at a slot is n/m, where n is the number of elements and m is the array size.
>    - **Disadvantages**: 
>      - Can lead to wasted space if the array size is much larger than the number of elements.
>      - Requires additional memory for the linked list pointers.
>
> 2. **Closed Hashing (Open Addressing)**
>    - Elements with the same hash are stored in different array slots, determined by a probing sequence.
>    - **Advantages**: 
>      - Uses contiguous memory, which can be more cache-friendly.
>      - Does not require additional memory for pointers.
>    - **Disadvantages**:
>      - Can lead to clustering and longer probe sequences as the table fills up.
>      - Deletion is more complicated, as it requires marking slots as "deleted" to maintain the probing sequence.
>
> | Operation | Open Hashing (Chaining) |  | Closed Hashing (Open Addressing) |  |
> |-----------|-------------------------|--|----------------------------------|--|
> |           | **Average**                 | Worst | **Average**                          | Worst |
> | Find      | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
> | Insert    | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
> | Delete    | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
>
> Note: α (alpha) represents the load factor, which is the ratio of the number of elements to the array size (n/m). In practice, the load factor is kept below a certain threshold (e.g., 0.75) to maintain good performance.
>
> In the worst case, where a bad hash function maps all keys to the same index, the time complexity for find, insert, and delete operations becomes O(n) for both open hashing and closed hashing, as the entire array needs to be searched.
>
> The choice between open hashing and closed hashing depends on the specific requirements of the application, such as memory constraints, expected load factor, and the cost of collisions.

> [!idea] **Dynamic Resizing**
> 
> **Dynamic resizing** is a critical feature of modern hash table implementations, ensuring they can adapt to varying amounts of stored data while maintaining high performance and efficient space usage. This process is closely related to the concept of load factor and rehashing.
> 
> The main goals of dynamic resizing are:
> 
> - **Maintain optimal performance:** By adjusting the size of the hash table in response to changes in the number of stored elements, dynamic resizing helps maintain a low load factor, which is crucial for minimizing collisions and maintaining fast access times.
> 
> - **Efficient use of memory:** Dynamic resizing helps avoid excessive memory consumption when the number of elements is small, and ensures there's enough space to add more elements without significantly increasing the chance of collisions.
> 
> Implementations vary, but a common approach is to double the size of the hash table once the load factor exceeds a certain threshold (e.g., 0.75). Conversely, if a large number of elements are removed, reducing the size of the hash table can reclaim unused space.
> 
> While dynamic resizing is a powerful mechanism for maintaining efficiency, it's important to handle it carefully to minimize the computational cost of rehashing all keys during resize operations.