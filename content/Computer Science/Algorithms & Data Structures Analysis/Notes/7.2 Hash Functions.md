> [!idea] Hash Functions
>
> A hash function **maps a given key to an index in the underlying array**. The goal is to distribute the keys evenly across the array. A well-designed hash function should be efficient to compute and provide a uniform distribution of keys.
>
> When a key is passed through the hash function, it generates a hash code, which is then mapped to an index within the bounds of the array. This allows for **direct access to the desired element without the need to search through the entire array**.
>
> **Example: Modulo Function**
>
> - The modulo function is a simple hash function that takes the remainder of the key divided by the size of the array.
> - Formula: `hash(key) = key % array_size`
> - Example: If the key is 42 and the array size is 10, the hash function would map the key to index 2 (42 % 10 = 2).
>
> ![[Hash table.png]]

You're absolutely right! I apologize for the oversight. Here's the updated callout with the corrected time complexity table, including both average and worst cases:

> [!idea] Hash Functions
>
> A hash function **maps a given key to an index in the underlying array**. The goal is to distribute the keys evenly across the array. A well-designed hash function should be efficient to compute and provide a uniform distribution of keys.
>
> When a key is passed through the hash function, it generates a hash code, which is then mapped to an index within the bounds of the array. This allows for **direct access to the desired element without the need to search through the entire array**.
>
> **Example: Modulo Function**
>
> - The modulo function is a simple hash function that takes the remainder of the key divided by the size of the array.
> - Formula: `hash(key) = key % array_size`
> - Example: If the key is 42 and the array size is 10, the hash function would map the key to index 2 (42 % 10 = 2).
>
> ![[Hash table.png]]


> [!consider] Collisions and Hashing Techniques
>
> Hash **collisions** occur when multiple keys map to the same array index. There are two main approaches to handle collisions: open hashing (chaining) and closed hashing (open addressing).
>
> 1. **Open Hashing (Chaining)**
>    - Elements with the same hash are stored as a linked list in the same array slot.
>    - **Advantages**: 
>      - Ensures referential integrity by maintaining a correct and navigable link for each key-value pair, despite collisions.
>      - The average length of the list at a slot is n/m, where n is the number of elements and m is the array size.
>    - **Disadvantages**: 
>      - Can lead to wasted space if the array size is much larger than the number of elements.
>      - Requires additional memory for the linked list pointers.
>
> 2. **Closed Hashing (Open Addressing)**
>    - Elements with the same hash are stored in different array slots, determined by a probing sequence.
>    - **Advantages**: 
>      - Uses contiguous memory, which can be more cache-friendly.
>      - Does not require additional memory for pointers.
>    - **Disadvantages**:
>      - Can lead to clustering and longer probe sequences as the table fills up.
>      - Deletion is more complicated, as it requires marking slots as "deleted" to maintain the probing sequence.
>
> | Operation | Open Hashing (Chaining) |  | Closed Hashing (Open Addressing) |  |
> |-----------|-------------------------|--|----------------------------------|--|
> |           | Average                 | Worst | Average                          | Worst |
> | Find      | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
> | Insert    | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
> | Delete    | O(1 + α)                | O(n)  | O(1 + α)                         | O(n)  |
>
> Note: α (alpha) represents the load factor, which is the ratio of the number of elements to the array size (n/m). In practice, the load factor is kept below a certain threshold (e.g., 0.75) to maintain good performance.
>
> In the worst case, where a bad hash function maps all keys to the same index, the time complexity for find, insert, and delete operations becomes O(n) for both open hashing and closed hashing, as the entire array needs to be searched.
>
> The choice between open hashing and closed hashing depends on the specific requirements of the application, such as memory constraints, expected load factor, and the cost of collisions.

