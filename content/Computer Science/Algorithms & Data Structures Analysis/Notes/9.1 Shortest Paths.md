> [!idea] Shortest Paths
> 
> In a graph, the **route that minimises the total weight of the edges between any two nodes** is the shortest path between those two nodes.
 > 
> In mathematical terms: 
> - We have a graph $G$ with nodes $V$ and edges $E$. 
> - Each edge has a weight associated with it. 
> 	- Weight can be distance, cost, etc.
> - The shortest path **minimises the sum of the edge weights along the path**.
> 


> [!example] Shortest Path Example
> ![[Shortest Path Example.png|500]]
> 
>    - A -> B -> E -> G = 3 + 4 + 1 = 8
>   - **A -> C -> E -> G = 2 + 1 + 1 = 4**
>   - A -> C -> F -> G = 2 + 4 + 1 = 7


> [!consider] Real-World Applications
>
> Shortest path algorithms have numerous practical applications:
> 
> - **Navigation systems**: Finding the quickest route between locations.
> - **Network routing**: Determining efficient paths for data packets in computer networks.
> - **Robot motion planning**: Calculating optimal paths for robots to navigate environments.
> 
> In these scenarios, the graph represents the network or environment, vertices represent locations or nodes, and edge weights represent distances or costs. Finding the shortest path helps optimize routes, minimize travel time, or reduce resource consumption.

> [!idea] Properties of Shortest Paths
>
> **A segment of the shortest path between two nodes is itself the shortest path between any two nodes located within that segment.**
> 
> Mathematically, if the shortest path from node $s$ to node $v$ passes through an intermediate node $u$, then:
> - The portion of the path from s to u is the shortest path from s to u.
> - The portion of the path from u to v is the shortest path from u to v.
> 
> This property is crucial for understanding and developing shortest path algorithms. It allows algorithms to build shortest paths incrementally by extending known shortest paths.

> [!example] Subpath Property Illustration
>
> ![[Subpaths.png|500]]
>
> In the image, if the shortest path from s to v is s → a → b → v, then:
> - The subpath s → a → b is the shortest path from s to b.
> - The subpath a → b → v is the shortest path from a to v.
>
> The subpath property ensures that the shortest path from s to v can be constructed by combining the shortest paths from s to b and from a to v.



Motivation: To introduce the assumption of non-negative edge costs and its implications for shortest path algorithms.

> [!consider] Non-Negative Edge Costs
>
> Many shortest path algorithms, such as Dijkstra's algorithm, assume that all edge weights in the graph are non-negative. This means that the weight of each edge is greater than or equal to zero.
>
> In mathematical terms:
> - For every edge (u, v) in the graph, the weight w(u, v) ≥ 0.
>
> The assumption of non-negative edge weights simplifies the problem and allows for more efficient algorithms. It ensures that as we explore the graph, the shortest path distances cannot decrease.
>
> ![[Non-Negative Edge Costs.png|500]]
>
> In the example above, all edge weights are non-negative, allowing algorithms like Dijkstra's to efficiently find the shortest paths.
>
> However, some graphs may contain negative edge weights. In such cases, specialized algorithms like the Bellman-Ford algorithm are used to handle negative weights and detect negative cycles (paths with a total negative weight that lead back to the starting node).

> [!idea] Importance of Non-Negative Edge Costs
>
> The assumption of non-negative edge costs is crucial for the correctness and efficiency of many shortest path algorithms. Here's why:
>
> 1. **Shortest Path Property**: With non-negative edge weights, the shortest path property holds: any subpath of a shortest path is also a shortest path. This allows algorithms to build shortest paths incrementally.
>
> 2. **Monotonicity**: Non-negative edge weights ensure that as we explore the graph, the shortest path distances from the starting node to any other node can only increase or remain the same. This monotonicity property is essential for the convergence and optimality of algorithms like Dijkstra's.
>
> 3. **Efficiency**: Algorithms that assume non-negative edge weights, such as Dijkstra's algorithm, can leverage the monotonicity property to efficiently update shortest path distances and terminate when the shortest paths are found. This leads to faster running times compared to algorithms that handle negative weights.

> [!consider] Handling Negative Edge Weights
>
> While the assumption of non-negative edge weights is common, there are scenarios where negative edge weights are present. In such cases, specialized algorithms are used:
>
> - **Bellman-Ford Algorithm**: This algorithm can handle graphs with negative edge weights and can detect negative cycles. It has a higher time complexity compared to Dijkstra's algorithm but is more versatile.
>
> - **Floyd-Warshall Algorithm**: This algorithm can find the shortest paths between all pairs of nodes in a graph, even with negative edge weights. It can also detect negative cycles.
>
> When negative edge weights are present, the shortest path problem becomes more complex, and the assumptions and properties that hold for non-negative weights may no longer apply.

By discussing non-negative edge costs, we highlight the assumptions and properties that simplify the shortest path problem and enable efficient algorithms. Understanding the significance of non-negative edge weights helps in selecting the appropriate algorithm based on the characteristics of the graph.