> [!idea] Introduction to All-Pairs Shortest Paths (APSP)
>
> The All-Pairs Shortest Paths (APSP) problem aims to find the shortest paths between all pairs of vertices in a weighted graph. In other words, for every pair of vertices $(i, j)$ in the graph, we want to find the shortest path from vertex $i$ to vertex $j$.
>
> The APSP problem has several important applications, such as:
> - Finding the shortest routes between all locations in a transportation network
> - Analyzing social networks to determine the shortest connections between individuals
> - Identifying the most efficient paths for data flow in computer networks
>
> There are various algorithms to solve the APSP problem, including:
> - Running Dijkstra's algorithm or Bellman-Ford algorithm for each vertex as the source
> - Floyd-Warshall algorithm, which uses dynamic programming to solve APSP
> - Johnson's algorithm, which combines Dijkstra's algorithm with the Bellman-Ford algorithm
>
> The choice of algorithm depends on factors such as the graph's structure, the presence of negative edge weights, and the desired time complexity.

> [!consider] Applications of APSP
>
> The All-Pairs Shortest Paths (APSP) problem has numerous practical applications across different domains:
>
> 1. **Transportation Networks:**
>    - Finding the shortest routes between all locations in a city or country
>    - Optimizing delivery routes for logistics companies
>    - Analyzing traffic patterns and congestion in urban planning
>
> 2. **Social Network Analysis:**
>    - Determining the shortest paths between individuals in social networks
>    - Identifying influential nodes and communities within the network
>    - Studying information propagation and the spread of ideas or diseases
>
> 3. **Computer Networks:**
>    - Identifying the most efficient paths for data flow between all pairs of nodes
>    - Optimizing routing protocols and network topology
>    - Analyzing network resilience and identifying potential bottlenecks
>
> 4. **Bioinformatics:**
>    - Finding the shortest paths between all pairs of genes or proteins in biological networks
>    - Analyzing metabolic pathways and identifying key enzymes or compounds
>    - Studying the evolution of species and constructing phylogenetic trees
>
> 5. **Recommendation Systems:**
>    - Determining the shortest paths between all pairs of items or users in a recommendation graph
>    - Identifying similar items or users based on their shortest path distances
>    - Enhancing personalized recommendations and improving user experience
>
> These are just a few examples of how the APSP problem is applied in various fields. By finding the shortest paths between all pairs of vertices, APSP algorithms provide valuable insights and enable efficient decision-making in complex networks and systems.

> [!consider] Solving APSP with Repeated Dijkstra's Algorithm
>
> One straightforward approach to solve the All-Pairs Shortest Paths (APSP) problem is to run Dijkstra's algorithm repeatedly, considering each vertex as the source vertex.
>
> Here's how the repeated Dijkstra's algorithm approach works:
>
> 1. Initialize a distance matrix `dist` of size $|V| \times |V|$ to store the shortest path distances between all pairs of vertices. Set `dist[i][i] = 0` for all vertices $i$, and `dist[i][j] = ∞` for all pairs of vertices $(i, j)$ where $i ≠ j$.
>
> 2. For each vertex $i$ in the graph:
>    - Run Dijkstra's algorithm with vertex $i$ as the source vertex.
>    - Update the $i$-th row of the distance matrix `dist` with the shortest path distances from vertex $i$ to all other vertices.
>
> 3. After running Dijkstra's algorithm for all vertices, the distance matrix `dist` will contain the shortest path distances between all pairs of vertices.
>
> The time complexity of this approach depends on the implementation of Dijkstra's algorithm:
> - If Dijkstra's algorithm is implemented using a binary heap, the time complexity is $O(|V| \cdot ((|V| + |E|) \cdot \log |V|))$, which simplifies to $O(|V|^2 \log |V| + |V| \cdot |E| \cdot \log |V|)$.
> - If Dijkstra's algorithm is implemented using a Fibonacci heap, the time complexity is $O(|V| \cdot (|V| \cdot \log |V| + |E|))$, which simplifies to $O(|V|^2 \log |V| + |V| \cdot |E|)$.
>
> While the repeated Dijkstra's algorithm approach is simple to understand and implement, it may not be the most efficient solution for dense graphs or graphs with negative edge weights. In such cases, algorithms like Floyd-Warshall or Johnson's algorithm might be more suitable.
>
> However, for sparse graphs with non-negative edge weights, running Dijkstra's algorithm for each vertex can be a practical and efficient approach to solve the APSP problem.
