
> [!motivation] Motivation for Union-Find Data Structure
> 
> We need to **determine whether adding an edge would create a cycle.** This requires keeping track of connected components in the graph and quickly checking if two vertices belong to the same component.
> 
> We can achieve this using a **union-find data structure**. 

> [!idea] Union-Find Data Structure
>
> A union-find data structure is a way to **keep track of elements that belong to different sets**. It's like having a bunch of boxes, and each element is placed in one of these boxes. Initially, each element starts in its own separate box.
>
> The union-find data structure provides two main operations:
>
> 1. **Find(x)**: It's like asking, "Which box is element x in?" The Find operation tells you the representative or label of the box that contains element x. Elements in the same box have the same representative.
>
> 2. **Union(x, y)**: It's like saying, "Let's merge the boxes containing elements x and y into a single bigger box." The Union operation combines the boxes (sets) that contain elements x and y, so they become part of the same group.
>
> You can think of the union-find data structure as a way to partition elements into different groups and keep track of which elements belong together.
>
> In Kruskal's Algorithm, we use the union-find data structure to keep track of connected components in the graph. Each vertex starts in its own separate "box" (set). As we process the edges:
>
> 1. We use the **Find** operation to determine which "boxes" (sets) the two vertices of the current edge belong to.
>
> 2. If the vertices are in different "boxes" (sets), it means they aren't connected yet, so we can safely add the edge to the MST. We then use the **Union** operation to merge the "boxes" (sets) containing the vertices, indicating that they are now connected.
>
> 3. If the vertices are already in the same "box" (set), it means they are already connected, and adding the edge would create a cycle. In this case, we discard the edge.
>

> [!idea] Implementation of Union-Find Using List-Oriented Approach
>
> This union-find implementation utilizes an array and lists within a class structure, allowing efficient management of disjoint sets. The structure uses a list for each set and an array to quickly map elements to their corresponding set identifiers.
>
> **Class Structure**:
> - **Array R**: Stores the set identifier for each element. This direct mapping allows for O(1) complexity for the `find` operation.
> - **List L(A)**: Maintains a list of elements for each set `A`, which helps in efficient merging of sets.
>
> **Pseudocode**:
> ```c
> class UnionFind:
>     function __init__(n):
>         self.R = new array of size n
>         self.L = new array of lists of size n
>         for i from 0 to n-1 do
>             self.R[i] = i  // Initially, each element is its own set
>             self.L[i] = new list containing i  // Initialize list for each element
>
>     function find(x):
>         return self.R[x]  // Direct lookup of the set identifier
>
>     function union(x, y):
>         rootX = self.find(x)
>         rootY = self.find(y)
>         if rootX â‰  rootY then
>             if length(self.L[rootX]) < length(self.L[rootY]) then
>                 self.merge(rootX, rootY)  // Merge smaller list into the larger one
>             else
>                 self.merge(rootY, rootX)  // Merge smaller list into the larger one
>
>     function merge(smaller, larger):
>         for element in self.L[smaller] do
>             self.R[element] = larger  // Update the set identifier in R
>         self.L[larger].extend(self.L[smaller])  // Extend the larger list with elements of the smaller
>         self.L[smaller] = []  // Clear the smaller list after merging
> ```
>
> **Explanation**:
> - The `UnionFind` class initializes with every element in its own set. The `find` method provides an efficient way to determine the set identifier for any element.
> - The `union` method checks if two elements belong to different sets and merges the smaller set into the larger one to maintain a balanced structure. This minimizes the number of elements that need to be moved during a merge, optimizing the process.
> - The `merge` method handles the actual merging of two sets. It updates the set identifiers for all elements in the smaller set and transfers these elements to the larger set's list, ensuring the structure remains efficient for future operations.
