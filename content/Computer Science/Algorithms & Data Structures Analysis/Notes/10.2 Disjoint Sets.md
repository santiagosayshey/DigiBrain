
> [!motivation] Motivation for a Disjoint Set
> 
> We need to **determine whether adding an edge would create a cycle.** This requires keeping track of connected components in the graph and quickly checking if two vertices belong to the same component.
> 
> We can achieve this using a **Disjoint Set data structure**. 

> [!idea] Disjoint Sets
>
> A Disjoint Set is a way to **keep track of elements that belong to different sets**. It's like having a bunch of boxes, and each element is placed in one of these boxes. Initially, each element starts in its own separate box.
>
> The union-find data structure provides two main operations:
>
> 1. **Find(x)**: It's like asking, "Which box is element x in?" The Find operation tells you the representative or label of the box that contains element x. Elements in the same box have the same representative.
>
> 2. **Union(x, y)**: It's like saying, "Let's merge the boxes containing elements x and y into a single bigger box." The Union operation combines the boxes (sets) that contain elements x and y, so they become part of the same group.
>
> You can think of the union-find data structure as a way to partition elements into different groups and keep track of which elements belong together.
>
> In Kruskal's Algorithm, we use the union-find data structure to keep track of connected components in the graph. Each vertex starts in its own separate "box" (set). As we process the edges:
>
> 1. We use the **Find** operation to determine which "boxes" (sets) the two vertices of the current edge belong to.
>
> 2. If the vertices are in different "boxes" (sets), it means they aren't connected yet, so we can safely add the edge to the MST. We then use the **Union** operation to merge the "boxes" (sets) containing the vertices, indicating that they are now connected.
>
> 3. If the vertices are already in the same "box" (set), it means they are already connected, and adding the edge would create a cycle. In this case, we discard the edge.
>


> [!idea] Implementation of a Disjoint Set Data Structure
>
> To efficiently perform find and union operations on disjoint sets, we can use the data structure and functions outlined in the image:
>
> ```
> Class UnionFind(n : N)                    // Main
>     parent = ⟨1, 2, . . . , n⟩ : Array [1..n] of 1..n
>     seniority = ⟨0, . . . , 0⟩ : Array [1..n] of 0.. log n // set size or depth
> ```
> 
> `parent` is an array where parent[i] stores the parent of element i. 
> `seniority` tracks either the size of each set or the depth of the tree representing each set.
>
> ```
> Function find(i : 1..n) : 1..n 
>     if parent[i] = i then return i
>     else i' :=find(parent[i])
>     parent[i] := i'
>     return i'
> ```
>
> `find(i)` finds the representative element of the set that contains element i, performing path compression along the way to flatten the tree structure.
> 
> ```
> Procedure link(i, j : 1..n) 
>     assert i and j are representatives of different blocks
>     if seniority[i] < seniority[j] then parent[i] := j
>     else
>         parent[j] := i
>         if seniority[i] = seniority[j] then seniority[i] ++
> ```        
>
> `link(i, j)` combines the sets containing elements i and j, attaching the shorter tree to the root of the taller tree and updating seniority accordingly.
>  
> ```
> Procedure union(i, j : 1..n)
>     if find(i) ̸= find(j) then link(find(i), find(j))
> ```
>
> `union(i, j)` first finds the representatives of the sets containing i and j using `find()`, then links them together using `link()` if they are in different sets.

