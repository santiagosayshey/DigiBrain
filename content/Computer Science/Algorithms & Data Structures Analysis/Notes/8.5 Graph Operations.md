
> [!idea] Graph Operations and Storage
>
> Working with graphs computationally involves a variety of operations that require efficient execution for practical use. It is essential to select an appropriate data structure that allows for the following operations:
>
> - **Accessing associated information**: Retrieve data associated with specific nodes and edges.
> - **Navigation**: Explore the graph by following edges from one node to another.
> - **Edge queries**: Determine if a connection exists between two nodes.
> - **Construction, conversion, and output**: Build new graphs, transform one graph representation into another, and output graph data.
> - **Update**: Add or remove nodes and edges to reflect changes in the graph.
>
> Different storage structures offer various trade-offs in terms of memory usage and the efficiency of operations. Choosing the right one depends on the specific needs of the application and the nature of the graph.

> [!consider] Unordered Edge Sequences
 >
 > This structure involves storing edges in an unordered sequence, such as a linked list. While it's suitable for simply outputting the edges of a graph, most operations, like checking the existence of an edge, require \(O(m)\) time, where \(m\) is the number of edges.


> [!consider]  Adjacency Arrays (Static Graphs Only)
>
> Imagine organizing the connections of a graph into a neatly indexed library. An adjacency array does something similar for static graphs, which means the graphs don't change over time. It uses two principal arrays:
>
> - The **Vertex Array (V)** acts like an index, where each entry corresponds to a node and points to where that node's edges start in the Edge Array.
> - The **Edge Array (E)** is like a list of books on a shelf. It sequentially lists all the edges of the graph, one node's edges after another, without any gaps in between.
>
> For example, if node 1 has edges connecting it to nodes 2 and 3, and node 2 connects to nodes 3 and 4, the Edge Array might look like this: [2, 3, 3, 4], with the Vertex Array telling you where the edges for each node begin. If the Vertex Array for node 1 starts at index 1 and for node 2 at index 3, then the edges for node 1 are in the Edge Array from indices 1 to 2, and the edges for node 2 are from indices 3 to 4.
>
> This setup allows you to quickly jump to any node's connections, providing fast access for reading the graph. However, since the graph is static, adding or removing edges isn't as simple, because it might require shifting many elements in the Edge Array, similar to adding or removing books in the middle of the tightly packed shelf.
 
 
 > [!consider] Adjacency Lists
 >
 > Adjacency lists are widely used due to their balance between memory usage and performance. Each node has a list of all nodes it's directly connected to. This structure is particularly efficient for sparse graphs and makes it easy to add or remove edges.
 
 
 > [!consider] Adjacency Matrices
>
 > An adjacency matrix represents the graph with a 2-dimensional array where each cell at position (i, j) indicates the presence or absence of an edge between nodes i and j. Operations such as insertion, removal, and edge queries can be performed in constant time. However, for large and sparse graphs, this structure can be memory-intensive.
 >
 > The choice among these structures is a trade-off between memory efficiency and operation complexity. For dynamic graphs where updates are frequent, adjacency lists are often preferred, while adjacency matrices provide quicker access for edge queries at the cost of higher memory consumption in sparse graphs. Unordered edge sequences and adjacency arrays can serve well in scenarios where graph updates are infrequent and operation efficiency is less critical.

> [!consider]  Adjacency Arrays (Static Graphs Only)
>
> The adjacency array organizes the edges of a static graph using two main components, which we can represent as follows:
>
> - The **Vertex Array (V)** serves as a guide, indicating the starting point for each vertex's edges in the Edge Array. 
> $$
> V = \begin{bmatrix}
> 1 & 3 & \ldots
> \end{bmatrix}
> $$
> In this array, the number at each position tells us where the edges for that vertex start in the Edge Array. For instance, if the first vertex's edges start at index 1 in the Edge Array, that's where we'll find it in \( V \).
> 
>
> - The **Edge Array (E)** lists all the edges in the graph sequentially:
> $$
> E = \begin{bmatrix}
> 2 & 3 & 3 & 4 & \ldots
> \end{bmatrix}
> $$
> Here, the edges are arranged one after another for each vertex. If vertex 1 is connected to vertices 2 and 3, and vertex 2 to vertices 3 and 4, these edges are laid out in \( E \) just as listed.
>
> Together, these arrays allow for efficient traversal and querying of the graph. However, keep in mind that inserting or deleting edges would necessitate adjustments throughout the Edge Array, which is why this structure is best suited for graphs that do not change often.

