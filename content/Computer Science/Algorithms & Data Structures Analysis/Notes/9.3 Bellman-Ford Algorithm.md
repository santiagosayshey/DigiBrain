> [!idea] Introduction to Bellman-Ford Algorithm
> 
> The Bellman-Ford algorithm is an **alternative shortest path algorithm** that can:
> 
> - Handle graphs with **negative edge weights**.
> - Detect and report negative-weight cycles in the graph.
> - It has a **slower time complexity** compared to Dijkstra's algorithm.
> 
> The algorithm works by **iteratively updating the shortest path distances**. It performs this process for a **maximum of |V| - 1 iterations**, where |V| is the number of vertices in the graph.

> [!example] Bellman-Ford Algorithm Example
> 
> Let's consider the following graph:
> 
> ![[Bellman - Ford.png|300]]
> 
> We want to find the shortest paths from vertex A to all other vertices.
> 
> The Bellman-Ford algorithm will perform the following steps:
> 
> 1. Initialize distances:
>    - Distance to A: 0
>    - Distance to B, C, D, E: ∞
> 
> 2. Perform updates for |V| - 1 iterations:
>    - Iteration 1:
>      - Update edge A → B: distance[B] = min(∞, 0 + 4) = 4
>      - Update edge A → C: distance[C] = min(∞, 0 + 2) = 2
>      - Update edge B → E: distance[E] = min(∞, 4 + 1) = 5
>      - Update edge C → D: distance[D] = min(∞, 2 + 3) = 5
>      - Update edge C → E: distance[E] = min(5, 2 + 1) = 3
>      - Update edge D → B: distance[B] = min(4, 5 + 1) = 4
>      - Update edge E → D: distance[D] = min(5, 3 + 1) = 4
>    - Iteration 2, 3, 4: No further updates
> 
> 3. Check for negative-weight cycles:
>    - Perform updates for all edges once more
>    - If any distance values change, there is a negative-weight cycle
> 
> The final shortest path distances from A are:
> - Distance to A: 0
> - Distance to B: 4
> - Distance to C: 2
> - Distance to D: 4
> - Distance to E: 3

```python
function BellmanFordShortestPath(Graph, startNode):
   startNode.distance = 0                                 # O(1)
   for each node in Graph:                                # O(V)
       if node != startNode:
           node.distance = infinity                       # O(1)
           node.previousNode = null                       # O(1)

   for i from 1 to |V| - 1:                               # O(V)
       for each edge (u, v) in Graph:                     # O(E)
           if u.distance + edgeWeight(u, v) < v.distance: # O(1)
               v.distance = u.distance + edgeWeight(u, v) # O(1)
               v.previousNode = u                         # O(1)

   for each edge (u, v) in Graph:                         # O(E)
       if u.distance + edgeWeight(u, v) < v.distance:     # O(1)
           return "Graph contains a negative-weight cycle"

   return distances, previousNodes
```

> [!idea] Time Complexity of Bellman-Ford Algorithm
> 
> The time complexity of the Bellman-Ford algorithm is $O(|V| \cdot |E|)$, where $|V|$ is the number of vertices and $|E|$ is the number of edges in the graph.
> 
> The algorithm performs $|V| - 1$ iterations, and in each iteration, it updates all the edges in the graph. Updating an edge takes constant time, so the total time complexity is $O((|V| - 1) \cdot |E|)$, which simplifies to $O(|V| \cdot |E|)$.
> 
> This time complexity is higher than Dijkstra's algorithm with a binary heap, which has a time complexity of $O((|V| + |E|) \cdot \log |V|)$. However, the Bellman-Ford algorithm's ability to handle negative edge weights makes it useful in certain scenarios where Dijkstra's algorithm is not applicable.


Here's a plan for separate notes and their callouts to discuss various shortest path algorithms and concepts:

1. Bellman-Ford Algorithm
    
    > [!idea] Introduction to Bellman-Ford Algorithm [!example] Bellman-Ford Algorithm Example [!consider] Handling Negative Edge Weights [!complexity] Time Complexity of Bellman-Ford Algorithm
    
2. All-Pairs Shortest Paths (APSP)
    
    > [!idea] Introduction to All-Pairs Shortest Paths [!consider] Applications of APSP [!consider] Solving APSP with Repeated Dijkstra's Algorithm
    
3. Dynamic Programming
    
    > [!idea] Introduction to Dynamic Programming [!consider] Characteristics of Dynamic Programming Problems [!consider] Solving Shortest Path Problems with Dynamic Programming
    
4. Floyd-Warshall Algorithm
    
    > [!idea] Introduction to Floyd-Warshall Algorithm [!example] Floyd-Warshall Algorithm Example [!complexity] Time Complexity of Floyd-Warshall Algorithm [!consider] Reconstructing Shortest Paths in Floyd-Warshall Algorithm
    
5. Comparing Shortest Path Algorithms
    
    > [!consider] Dijkstra's Algorithm vs. Bellman-Ford Algorithm [!consider] Floyd-Warshall Algorithm vs. Repeated Dijkstra's Algorithm for APSP [!consider] Trade-offs and Choosing the Right Algorithm
    

These notes will cover a range of shortest path algorithms and concepts, including Bellman-Ford algorithm for handling negative edge weights, all-pairs shortest paths (APSP) problem, dynamic programming approach to shortest path problems, Floyd-Warshall algorithm for APSP, and comparisons between different shortest path algorithms.

The callouts will provide introductions, examples, complexity analysis, and considerations for each topic, allowing for a comprehensive understanding of shortest path algorithms and their applications.