> [!idea] Introduction to Bellman-Ford Algorithm
> 
> The Bellman-Ford algorithm is an alternative shortest path algorithm that can handle graphs with negative edge weights, unlike Dijkstra's algorithm. It is capable of finding the shortest paths from a single source vertex to all other vertices in a weighted directed graph.
> 
> Key points about the Bellman-Ford algorithm:
> - It can handle graphs with negative edge weights.
> - It can detect and report negative-weight cycles in the graph.
> - It has a slower time complexity compared to Dijkstra's algorithm.
> 
> The algorithm works by iteratively relaxing the edges of the graph and updating the shortest path distances. It performs this relaxation process for a maximum of |V| - 1 iterations, where |V| is the number of vertices in the graph.
> 
> > [!example] Bellman-Ford Algorithm Example
> 
> Let's consider the following graph:
> 
> ![Bellman-Ford Example Graph](https://i.imgur.com/NLNXBvQ.png)
> 
> We want to find the shortest paths from vertex A to all other vertices.
> 
> The Bellman-Ford algorithm will perform the following steps:
> 
> 1. Initialize distances:
>    - Distance to A: 0
>    - Distance to B, C, D, E: ∞
> 
> 2. Perform relaxation for |V| - 1 iterations:
>    - Iteration 1:
>      - Relax edge A → B: distance[B] = min(∞, 0 + 4) = 4
>      - Relax edge A → C: distance[C] = min(∞, 0 + 2) = 2
>      - Relax edge B → E: distance[E] = min(∞, 4 + 1) = 5
>      - Relax edge C → D: distance[D] = min(∞, 2 + 3) = 5
>      - Relax edge C → E: distance[E] = min(5, 2 + 1) = 3
>      - Relax edge D → B: distance[B] = min(4, 5 + 1) = 4
>      - Relax edge E → D: distance[D] = min(5, 3 + 1) = 4
>    - Iteration 2, 3, 4: No further updates
> 
> 3. Check for negative-weight cycles:
>    - Perform relaxation for all edges once more
>    - If any distance values change, there is a negative-weight cycle
> 
> The final shortest path distances from A are:
> - Distance to A: 0
> - Distance to B: 4
> - Distance to C: 2
> - Distance to D: 4
> - Distance to E: 3
> 
> > [!consider] Handling Negative Edge Weights
> 
> The Bellman-Ford algorithm's ability to handle negative edge weights is a significant advantage over Dijkstra's algorithm. Negative edge weights can occur in various scenarios, such as:
> 
> - Currency exchange rates
> - Energy consumption in physical systems
> - Shortest paths in space-time graphs
> 
> When negative edge weights are present, Dijkstra's algorithm may fail to find the correct shortest paths. The Bellman-Ford algorithm, on the other hand, can accurately compute the shortest paths as long as there are no negative-weight cycles in the graph.
> 
> > [!complexity] Time Complexity of Bellman-Ford Algorithm
> 
> The time complexity of the Bellman-Ford algorithm is $O(|V| \cdot |E|)$, where $|V|$ is the number of vertices and $|E|$ is the number of edges in the graph.
> 
> The algorithm performs $|V| - 1$ iterations, and in each iteration, it relaxes all the edges in the graph. Relaxing an edge takes constant time, so the total time complexity is $O((|V| - 1) \cdot |E|)$, which simplifies to $O(|V| \cdot |E|)$.
> 
> This time complexity is higher than Dijkstra's algorithm with a binary heap, which has a time complexity of $O((|V| + |E|) \cdot \log |V|)$. However, the Bellman-Ford algorithm's ability to handle negative edge weights makes it useful in certain scenarios where Dijkstra's algorithm is not applicable.

