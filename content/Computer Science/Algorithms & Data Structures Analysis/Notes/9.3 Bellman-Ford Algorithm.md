Here's the revised callout with the updated last paragraph:

> [!idea] Introduction to Bellman-Ford Algorithm
>
> The Bellman-Ford algorithm is an **alternative shortest path algorithm** that **iteratively updates the shortest path distances**. It does this by performing a series of iterations, where the number of iterations is equal to **one less than the total number of nodes** in the graph.
>
> In each iteration, the algorithm goes through each of the nodes inside the graph, and looks at all the outgoing edges. If the distance to any other outgoing node is smaller than what's been recorded, this distance gets updated.
>
> This method is **similar to Dijkstra's algorithm**, but with one key difference: it's not greedy. Bellman-Ford checks every path, rather than just the smallest distance at any given moment. This allows processing of negative edge weights and detection of negative cycles at the cost of increased complexity. 


> [!example] Bellman-Ford Algorithm Example
> 
> Let's consider the following graph:
> 
> ![['.png|300]]
> 
> We want to find the shortest paths from vertex S to all other vertices.



| Iteration | S   | A   | B   | C   | D   | E   | Notes                                                                                   |
| --------- | --- | --- | --- | --- | --- | --- | --------------------------------------------------------------------------------------- |
| 0         | 0   | ∞   | ∞   | ∞   | ∞   | ∞   |                                                                                         |
| 1         | 0   | 10  | 10  | 12  | 9   | 8   |                                                                                         |
| 2         | 0   | 5   | 10  | 8   | 9   | 8   | Because we now have a way to node D, we can use **it's** edges to reach A and C faster! |
| 3         | 0   | 5   | 10  | 7   | 9   | 8   | Because we have a faster way to A from D, we can use **it's** edges to reach C fas      |




```python
function BellmanFordShortestPath(Graph, startNode):
   startNode.distance = 0                                 # O(1)
   for each node in Graph:                                # O(V)
       if node != startNode:
           node.distance = infinity                       # O(1)
           node.previousNode = null                       # O(1)

   for i from 1 to |V| - 1:                               # O(V)
       for each edge (u, v) in Graph:                     # O(E)
           if u.distance + edgeWeight(u, v) < v.distance: # O(1)
               v.distance = u.distance + edgeWeight(u, v) # O(1)
               v.previousNode = u                         # O(1)

   for each edge (u, v) in Graph:                         # O(E)
       if u.distance + edgeWeight(u, v) < v.distance:     # O(1)
           return "Graph contains a negative-weight cycle"

   return distances, previousNodes
```

> [!idea] Time Complexity of Bellman-Ford Algorithm
> 
> The time complexity of the Bellman-Ford algorithm is $O(|V| \cdot |E|)$, where $|V|$ is the number of vertices and $|E|$ is the number of edges in the graph.
> 
> The algorithm performs $|V| - 1$ iterations, and in each iteration, it updates all the edges in the graph. Updating an edge takes constant time, so the total time complexity is $O((|V| - 1) \cdot |E|)$, which simplifies to $O(|V| \cdot |E|)$.
> 
> This time complexity is higher than Dijkstra's algorithm with a binary heap, which has a time complexity of $O((|V| + |E|) \cdot \log |V|)$. However, the Bellman-Ford algorithm's ability to handle negative edge weights makes it useful in certain scenarios where Dijkstra's algorithm is not applicable.

