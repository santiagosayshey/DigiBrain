> [!motivation] Significance of Decidability
>
> Determining whether a computational problem is decidable  has profound implications for understanding the capabilities and limitations of computational systems. It allows us to:
>
> 1. Identify problems that can be solved algorithmically, guiding resource allocation towards developing efficient solutions.
> 2. Recognize inherently unsolvable problems, preventing futile efforts in seeking algorithmic solutions.
> 3. Explore the fundamental boundaries of computability, advancing our theoretical understanding of what is computable.

> [!idea] Decidable and Undecidable Decision Problems
>
> A decision problem is a **type of computational problem with a binary (yes/no) answer**. Decision problems are classified as either decidable or undecidable:
>
> **Decidable decision problems have an algorithm that can provide a definite yes or no** answer in finite time for any valid input instance. Examples include determining if a string is a palindrome or checking if a number is prime.
>
> **Undecidable decision problems are those for which no algorithm can exist** that can solve the problem for all possible inputs. For some inputs, no computational solution can provide a definite answer. The Halting Problem and determining program equivalence are well-known undecidable problems.

> [!example] Decidability of Printing "Hello World"
>
> Let's consider the problem of determining if a given program can print the string "Hello World":
>
> **Simple Case:**
> ```python
> print("Hello World")
> ```
> This program is decidable since we can easily analyze the code and conclude that it will definitely print "Hello World".
>
> **Complex Case:**
> ```python
> def print_hello_world():
>     n = 3
>     while True:
>         for a in range(1, n+1):
>             for b in range(1, n+1):
>                 for c in range(1, n+1):
>                     if a**n + b**n == c**n:
>                         print("Hello World")
>                         return
>         n += 1
>
> print_hello_world()
> ```
> This program attempts to find a counterexample to Fermat's Last Theorem, which states that the equation $a^n + b^n = c^n$ has no solutions for integers $a$, $b$, $c$, and $n > 2$. It does this by iterating through all possible values of $n$, $a$, $b$, and $c$ to find integers satisfying $a^n + b^n = c^n$ for $n > 2$. If such a counterexample exists, it would print "Hello World".
>
> However, since Fermat's Last Theorem has been proven true for all $n > 2$, the program will run indefinitely without printing "Hello World" for inputs where $n > 2$.
>
> In this case, determining if the program can print "Hello World" becomes an undecidable problem. No algorithm can provide a definite answer for inputs where $n > 2$, as the program will never terminate or print the desired string.
>
> This example highlights how the decidability of a problem can depend on the specific program implementation and the presence of undecidable components or infinite loops within the code.


> [!example] The Halting Problem
>
> The Halting Problem is a famous undecidable decision problem in computer science. It asks the following question: "Given a program and its input, can a general algorithm be written to determine if it halts or loops forever?"
>
> Consider this Python program:
>
> ```python
> def loop_forever():
>     while True:
>         pass
>
> def maybe_halts(x):
>     if x > 0:
>         return x * x
>     else:
>         loop_forever()
>
> # What if we call maybe_halts(2)?
> # What if we call maybe_halts(-1)?
> ```
>
> In the `maybe_halts` function, if the input `x` is positive, the function will return `x * x` and terminate. However, if `x` is non-positive, the function will call `loop_forever`, which runs an infinite loop, causing the program to never halt.
>
> For the input `maybe_halts(2)`, we can determine that the program will halt and return `4`. However, for the input `maybe_halts(-1)`, it is impossible to decide whether the program will halt or run forever based solely on analyzing the code.
>
> This simple example illustrates the crux of the Halting Problem. While it may be possible to determine the halting behavior for specific inputs, there is no general algorithm that can analyze an arbitrary program and input and provide a definite yes-or-no answer as to whether the program will halt or run indefinitely.
>
> The undecidability of the Halting Problem has profound implications for computation theory and the limitations of what can be computed algorithmically.

This example highlights the core idea of the Halting Problem by providing a program where the halting behavior depends on the input value. It demonstrates that while we can determine the halting behavior for certain inputs, there is no general algorithm that can solve the problem for all possible programs and inputs.