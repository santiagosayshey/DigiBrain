
> [!idea]+ Imbalanced BSTs
> Recall than an imbalanced Binary Search Tree can degrade into a structure similar to a linked list, resulting in a worst-case time complexity of $O(n)$ for common operations. To address this issue and ensure optimal performance, we can proactively balance the BST during its construction and modification. By **maintaining a balanced structure with a height of $\log n$, the time complexity of key operations becomes $O(\log n)$** in the worst case, significantly improving upon the linear time complexity of an imbalanced tree. One type of these self balancing trees is an **AVL Tree.**
> 
>An AVL tree says that for any node, the height of it's two subtrees differs by at most, 1 node.
>
>![[Pasted image 20240318161818.png]]
>
>![[Pasted image 20240318162022.png]]

> [!idea]+ AVL Search
> 
> Search for a key $k$ in a tree $t$ is the same as it is for a regular BST.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchAVL(node root, int k)
>     if root is NULL
>         return NULL // Tree is empty or key not found
> 
>     if k == root.key
>         return root // Key found
> 
>     if k < root.key
> 		return searchAVL(root.left, k) // Recurse on left subtree
> 
>     if k > root.key
> 		return searchAVL(root.right, k) // Recurse on right subtree
> ```



![[Pasted image 20240318164026.png]]