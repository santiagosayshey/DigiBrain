
> [!idea]+ Imbalanced BSTs
> Recall than an imbalanced Binary Search Tree can degrade into a structure similar to a linked list, resulting in a worst-case time complexity of $O(n)$ for common operations. To address this issue and ensure optimal performance, we can proactively balance the BST during its construction and modification. By **maintaining a balanced structure with a height of $\log n$, the time complexity of key operations becomes $O(\log n)$** in the worst case, significantly improving upon the linear time complexity of an imbalanced tree. One type of these self balancing trees is an **AVL Tree.**
> 
>An AVL tree says that for any node, the height of it's two subtrees differs by at most, 1 node, i.e. $Balance \; Factor \in {-1,0,1}$
>
> ![[Pasted image 20240318164026.png]]
> ![[Pasted image 20240318164943.png]]
>


Sure! Here's the updated callout with the code turned into a function and parameters explained:

> [!consider] How do we balance BSTs?
>
> In an AVL Tree, rotations are used to fix imbalance.
>
> There are four types of rotations:
> 1. Left Rotation (LL): Used when the tree is right-heavy and the right subtree is right-heavy.
> 2. Right Rotation (RR): Used when the tree is left-heavy and the left subtree is left-heavy.
> 3. Left-Right Rotation (LR): Used when the tree is left-heavy and the left subtree is right-heavy.
> 4. Right-Left Rotation (RL): Used when the tree is right-heavy and the right subtree is left-heavy.
>
> To determine which rotation to use, we look at the balance factor.
>
> ```python
> def balance(self, root, key, balance_factor):
>     """
>     Balances the AVL tree based on the balance factor and the key.
>
>     :param root: The root node of the subtree to be balanced.
>     :param key: The key of the newly inserted or deleted node.
>     :param balance_factor: The balance factor of the root node.
>     :return: The new root of the balanced subtree.
>     """
>     if balance_factor > 1 and key < root.left.key:
>         return self.right_rotate(root)
>
>     if balance_factor < -1 and key > root.right.key:
>         return self.left_rotate(root)
>
>     if balance_factor > 1 and key > root.left.key:
>         root.left = self.left_rotate(root.left)
>         return self.right_rotate(root)
>
>     if balance_factor < -1 and key < root.right.key:
>         root.right = self.right_rotate(root.right)
>         return self.left_rotate(root)
>
>     return root
> ```
>
> The `balance` function takes three parameters:
> - `root`: The root node of the subtree to be balanced.
> - `key`: The key of the newly inserted or deleted node.
> - `balance_factor`: The balance factor of the root node.
>
> The function returns the new root of the balanced subtree after performing the necessary rotations based on the balance factor and the key.
>
> These rotations adjust the tree structure to maintain the AVL tree's balance factor between -1 and 1, ensuring the tree remains balanced after insertions and deletions.

> [!idea]+ Left Rotation
>
> A left rotation is performed when a node's right subtree is causing an imbalance. The node is rotated to the left, making its right child the new root of the subtree, and the old node becomes the left child of the new root. The new root's left subtree becomes the right subtree of the old node.
> 
> ![[Pasted image 20240318172119.png]]
>
> ```python
> def left_rotate(self, node):
>     B = node.right
>     Y = B.left
>     
>     B.left = node
>     node.right = Y
>     
>     node.height = 1 + max(self.get_height(node.left),
>                           self.get_height(node.right))
>     B.height = 1 + max(self.get_height(B.left),
>                        self.get_height(B.right))
>     
>     return B
> ```

> [!idea]+ Right Rotation
>
> A right rotation is performed when a node's left subtree is causing an imbalance. The node is rotated to the right, making its left child the new root of the subtree, and the old node becomes the right child of the new root. The new root's right subtree becomes the left subtree of the old node.
>
> ```python
> def right_rotate(self, node):
>     A = node.left
>     Y = A.right
>     
>     A.right = node
>     node.left = Y
>     
>     node.height = 1 + max(self.get_height(node.left),
>                           self.get_height(node.right))
>     B.height = 1 + max(self.get_height(B.left),
>                        self.get_height(B.right))
>     
>     return B
> ```
>
> ![[Pasted image 20240318172149.png]]




> [!idea]+ AVL Search
> 
> Search for a key $k$ in a tree $t$ is the same as it is for a regular BST.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchAVL(node root, int k)
>     if root is NULL
>         return NULL // Tree is empty or key not found
> 
>     if k == root.key
>         return root // Key found
> 
>     if k < root.key
> 		return searchAVL(root.left, k) // Recurse on left subtree
> 
>     if k > root.key
> 		return searchAVL(root.right, k) // Recurse on right subtree
> ```


