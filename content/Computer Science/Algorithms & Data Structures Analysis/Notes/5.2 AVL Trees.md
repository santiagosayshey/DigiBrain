
> [!idea]+ Imbalanced BSTs
> Recall than an imbalanced Binary Search Tree can degrade into a structure similar to a linked list, resulting in a worst-case time complexity of $O(n)$ for common operations. To address this issue and ensure optimal performance, we can proactively balance the BST during its construction and modification. By **maintaining a balanced structure with a height of $\log n$, the time complexity of key operations becomes $O(\log n)$** in the worst case, significantly improving upon the linear time complexity of an imbalanced tree. One type of these self balancing trees is an **AVL Tree.**
> 
>An AVL tree says that for any node, the height of it's two subtrees differs by at most, 1 node, i.e. $Balance \; Factor \in {-1,0,1}$
>
> ![[Pasted image 20240318164026.png]]
> ![[Pasted image 20240318164943.png]]
>


> [!consider] How do we balance BSTs?
> 
> In an AVL Tree, rotations are used to fix imbalance.
>
> There are four types of rotations:
> 1. Left Rotation (LL): Used when the tree is right-heavy and the right subtree is right-heavy.
> 2. Right Rotation (RR): Used when the tree is left-heavy and the left subtree is left-heavy.
> 3. Left-Right Rotation (LR): Used when the tree is left-heavy and the left subtree is right-heavy.
> 4. Right-Left Rotation (RL): Used when the tree is right-heavy and the right subtree is left-heavy.
>
> These rotations adjust the tree structure to maintain the AVL tree's balance factor between -1 and 1, ensuring the tree remains balanced after insertions and deletions.





> [!idea]+ AVL Search
> 
> Search for a key $k$ in a tree $t$ is the same as it is for a regular BST.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchAVL(node root, int k)
>     if root is NULL
>         return NULL // Tree is empty or key not found
> 
>     if k == root.key
>         return root // Key found
> 
>     if k < root.key
> 		return searchAVL(root.left, k) // Recurse on left subtree
> 
>     if k > root.key
> 		return searchAVL(root.right, k) // Recurse on right subtree
> ```


