
> [!idea]+ Imbalanced BSTs
> Recall than an imbalanced Binary Search Tree can degrade into a structure similar to a linked list, resulting in a worst-case time complexity of $O(n)$ for common operations. To address this issue and ensure optimal performance, we can proactively balance the BST during its construction and modification. By **maintaining a balanced structure with a height of $\log n$, the time complexity of key operations becomes $O(\log n)$** in the worst case, significantly improving upon the linear time complexity of an imbalanced tree. One type of these self balancing trees is an **AVL Tree.**
> 
>An AVL tree says that for any node, the height of it's two subtrees differs by at most, 1 node, i.e. $Balance \; Factor \in {-1,0,1}$
>
> ![[Pasted image 20240318164026.png]]
> ![[Pasted image 20240318164943.png]]
>

> [!consider] How do we balance BSTs?
>
> In an AVL Tree, rotations are used to fix imbalance.
>
> There are four types of rotations:
> 1. Left Rotation (LL): Used when the tree is right-heavy and the right subtree is right-heavy.
> 2. Right Rotation (RR): Used when the tree is left-heavy and the left subtree is left-heavy.
> 3. Left-Right Rotation (LR): Used when the tree is left-heavy and the left subtree is right-heavy.
> 4. Right-Left Rotation (RL): Used when the tree is right-heavy and the right subtree is left-heavy.
>
> To determine which rotation to use, we look at the balance factor.
>
> ```python
> def balance(self, root, key, balance_factor):
>     if balance_factor > 1 and key < root.left.key:
>         return self.right_rotate(root)
>
>     if balance_factor < -1 and key > root.right.key:
>         return self.left_rotate(root)
>
>     if balance_factor > 1 and key > root.left.key:
>         root.left = self.left_rotate(root.left)
>         return self.right_rotate(root)
>
>     if balance_factor < -1 and key < root.right.key:
>         root.right = self.right_rotate(root.right)
>         return self.left_rotate(root)
>
>     return root
> ```
>
> The `balance` function is a method of the AVL tree class and takes four parameters:
> - `self`: The instance of the AVL tree class.
> - `root`: The root node of the subtree to be balanced.
> - `key`: The key of the newly inserted or deleted node.
> - `balance_factor`: The balance factor of the root node.
>
> The function returns the new root of the balanced subtree after performing the necessary rotations based on the balance factor and the key.

> [!idea]+ Left Rotation
>
> A left rotation is performed when a node's right subtree is causing an imbalance. The node is rotated to the left, making its right child the new root of the subtree, and the old node becomes the left child of the new root. The new root's left subtree becomes the right subtree of the old node.
> 
> ![[Pasted image 20240318172119.png]]
>
> ```python
> def left_rotate(self, node):
>     B = node.right
>     Y = B.left
>     
>     B.left = node
>     node.right = Y
>     
>     node.height = 1 + max(self.get_height(node.left),
>                           self.get_height(node.right))
>     B.height = 1 + max(self.get_height(B.left),
>                        self.get_height(B.right))
>     
>     return B
> ```

> [!idea]+ Right Rotation
>
> A right rotation is performed when a node's left subtree is causing an imbalance. The node is rotated to the right, making its left child the new root of the subtree, and the old node becomes the right child of the new root. The new root's right subtree becomes the left subtree of the old node.
>
> ```python
> def right_rotate(self, node):
>     A = node.left
>     Y = A.right
>     
>     A.right = node
>     node.left = Y
>     
>     node.height = 1 + max(self.get_height(node.left),
>                           self.get_height(node.right))
>     B.height = 1 + max(self.get_height(B.left),
>                        self.get_height(B.right))
>     
>     return B
> ```
>
> ![[Pasted image 20240318172149.png]]




> [!idea]+ AVL Search
> 
> Search for a key $k$ in a tree $t$ is the same as it is for a regular BST.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchAVL(node root, int k)
>     if root is NULL
>         return NULL // Tree is empty or key not found
> 
>     if k == root.key
>         return root // Key found
> 
>     if k < root.key
> 		return searchAVL(root.left, k) // Recurse on left subtree
> 
>     if k > root.key
> 		return searchAVL(root.right, k) // Recurse on right subtree
> ```



> [!idea]+ AVL Insertion
> 
> Insert a node $k$ in a tree $t$.
> 
> - Call `search(k)`
> - If `not found` is returned, insert node $k$ as child of the last visited node in `search(k)`
> ```c
> function insertBST(node root, int k)
>     node toInsert = newNode(k) // Assume newNode creates a new node with key k
>     if root is NULL
>         return toInsert // New tree with k as root if tree is empty
> 
>     node parent = NULL
>     node current = root
>     while current is not NULL
>         parent = current
>         if k < current.key
>             current = current.left
>         else if k > current.key
>             current = current.right
>         else
>             return root // Key already exists, do not insert
> 
>     if k < parent.key
>         parent.left = toInsert // Insert as left child
>     else
>         parent.right = toInsert // Insert as right child
> 
>     return root // Return the root of the modified tree
> ```