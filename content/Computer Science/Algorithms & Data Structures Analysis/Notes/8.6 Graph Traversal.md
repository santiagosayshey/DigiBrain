> [!consider] Graph Traversal
> 
> Graph traversal is the process of **visiting each node in a graph**. It is a fundamental operation in graph algorithms and is used for tasks such as searching for a specific vertex, determining connectivity, or exploring the structure of the graph.
>
> Efficient graph traversal algorithms should be able to visit all vertices in a graph in **linear time, i.e., $O(V + E)$**, where $V$ is the number of vertices and E is the number of edges.
>
> There are two primary approaches to graph traversal:
> 1. Breadth-First Search (BFS)
> 2. Depth-First Search (DFS)
>


> [!idea] Breadth-First Search (BFS)
>
> Breadth-First Search is a graph traversal algorithm that **explores the graph level by level**, ensuring it visits all vertices at the present "breadth" or layer before moving on to nodes at the next layer.
>
> The key idea behind BFS is to use a queue data structure to keep track of the vertices to be visited. The algorithm works as follows:
>
> 1. Choose a starting node and add it to the queue.
> 2. While the queue is not empty:
>    - Dequeue a vertex from the queue.
>    - Mark the dequeued vertex as visited.
>    - Enqueue all the unvisited neighbours of the dequeued vertex.
> 3. Repeat step 2 until the queue is empty.
>
> ![[BFS Animation.mp4]]
>
> **Implementation Details:**
> - We can use an Adjacency Array representation of the graph to efficiently access the neighbors of each node.
> - We introduce each node into the Priority Queue only once, which takes $O(n)$ time, where $n$ is the number of nodes.
> - We only consider a node in the Priority Queue together with its edges once, which takes $O(n+m)$ time, where m is the number of edges.
> - Updating the distance vector and the parent vector is done once for every node, taking O(n) time.
> - The total runtime of BFS is $O(n+m)$.
>
> **Pseudocode:**
> ```c
> function BFS(graph, startNode):
>     queue = new Queue()
>     visited = new Array(graph.numNodes).fill(false)
>     distance = new Array(graph.numNodes).fill(infinity)
>     parent = new Array(graph.numNodes).fill(null)
>     
>     queue.enqueue(startNode)
>     visited[startNode] = true
>     distance[startNode] = 0
>     
>     while queue is not empty:
>         currentNode = queue.dequeue()
>         
>         for each neighbor of currentNode:
>             if not visited[neighbor]:
>                 queue.enqueue(neighbor)
>                 visited[neighbor] = true
>                 distance[neighbor] = distance[currentNode] + 1
>                 parent[neighbor] = currentNode
>     
>     return (visited, distance, parent)
> ```
>
> The `BFS` function takes the graph and the starting node as input. It initializes a queue, a visited array, a distance array (to store the shortest distance from the start node to each node), and a parent array (to store the parent of each node in the BFS tree).
>
> The starting node is enqueued, marked as visited, and its distance is set to 0. Then, the algorithm enters a loop that continues until the queue is empty. In each iteration, it dequeues a node, marks it as visited, and enqueues all its unvisited neighbors. It also updates the distance and parent information for each newly visited node.
>
> Finally, the function returns the visited array, distance array, and parent array, which can be used for further analysis or to reconstruct the shortest paths from the start node to any other node in the graph.

