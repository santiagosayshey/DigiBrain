
> [!idea]+ Sorting So Far
> So far, we've seen sorting algorithms that in the worst case can sort in **$O(n\cdot \log{n})$** time. 


| Algorithm      | Best Time Complexity | Average Time Complexity | Worst Time Complexity | Space Complexity      | Stable | Notes                                      |
| -------------- | -------------------- | ----------------------- | --------------------- | --------------------- | ------ | ------------------------------------------ |
| Bubble Sort    | $O(n)$               | $O(n^2)$                | $O(n^2)$              | $O(1)$                | Yes    | Simple, but inefficient for large lists    |
| Selection Sort | $O(n^2)$             | $O(n^2)$                | $O(n^2)$              | $O(1)$                | No     | Simple, but not suitable for large lists   |
| Insertion Sort | $O(n)$               | $O(n^2)$                | $O(n^2)$              | $O(1)$                | Yes    | Efficient for small or nearly sorted lists |
| Merge Sort     | $O(n \log n)$        | $O(n \log n)$           | $O(n \log n)$         | $O(n)$                | Yes    | Efficient and stable, good for large lists |
| Quick Sort     | $O(n \log n)$        | $O(n \log n)$           | $O(n^2)$              | $O(\log n)$ to $O(n)$ | No     | Fast on average, but worst-case can be bad |
| Heap Sort      | $O(n \log n)$        | $O(n \log n)$           | $O(n \log n)$         | $O(1)$                | No     | In-place, but not stable                   |



> [!idea]+ Stability
> A sorting algorithm is considered **stable** if it preserves the relative order of records with equal keys (or values) in the sorted output, as it was in the input.
> - **Stable Sort:** If two elements `A` and `B` are identical in the sorting key (e.g., two people with the same name), and `A` appears before `B` in the original list, then `A` will also appear before `B` in the sorted list if the sorting algorithm is stable.

