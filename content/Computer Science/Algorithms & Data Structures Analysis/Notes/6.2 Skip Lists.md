
Here's the callout with the pseudocode implementation of the Node and SkipList classes added:

> [!idea] Skip Lists
> 
> Skip lists are a probabilistic data structure that provides efficient **search, insertion, and deletion operations with complexity of $O(\log n)$**. They are a variation of [[6.1 Linked Lists|linked lists]] that offer improved performance by maintaining multiple levels of linked lists, allowing for faster traversal.
> 
> Key characteristics of skip lists:
> 
> 1. **Balanced**: Skip lists are designed to maintain a balanced structure, ensuring efficient search and insertion operations.
> 
> 2. **Ordered**: Elements in a skip list are stored in sorted order, enabling efficient search and retrieval.
> 
> 3. **Dynamic**: Skip lists support dynamic insertion and deletion of elements, allowing the data structure to adapt to changes in the dataset.
> 
> 4. **Randomized**: The levels of each node in a skip list are determined randomly, providing a probabilistic guarantee of efficiency.
> 
> 5. **Probabilistic Structure**: Skip lists are built based on probabilistic principles. Each element in the skip list has a probability $p$ (usually 1/2) of being promoted to the next higher level. This probabilistic promotion of elements creates a hierarchical structure with multiple levels, where the expected number of nodes at each level decreases geometrically.
> 
> Skip lists consist of **multiple levels of linked lists**, with **each level being a subset of the level below it**. The bottom level (level 0) contains all the elements, while higher levels contain fewer elements, acting as express lanes for faster traversal. The topmost level typically consists of a single node. Each node contains pointers to every node on it's side (left, right, above and below)
> 
> 
> 
> ![[Pasted image 20240324040036.png]]
> 
> Pseudocode implementation of Node and SkipList classes:
> 
> ```c
> class Node:
>     value
>     left
>     right
>     above
>     below
> 
> class SkipList:
>     head
>     tail
>     maxLevel
>     
>     constructor():
>         this.head = new Node(null)
>         this.tail = new Node(null)
>         this.maxLevel = 0
>         this.head.right = this.tail
>         this.tail.left = this.head


> [!idea]+ Searching
> 
> To search a skip list, start with the top most level. If the next element in the current level is less than the target element, go to that element. Otherwise, go down a level.
> 
> ![[Pasted image 20240324035945.png]]
> 
> Pseudocode implementation of the search operation:
> 
> ```c
> search(value):
>     current = this.head
>     
>     for level from maxLevel downto 0:
>         while current.right != null and current.right.value <= value:
>             current = current.right
>         
>         if current.value == value:
>             return current
>         
>         if level > 0:
>             current = current.below
>     
>     return null
> ```


> [!idea]+ Splitting / Concatenating
> Search through list, and update pointers. A 2nd head points to where the end of the first list used to point to.  End of the first list points to null.
> 
> ![[Pasted image 20240324030509.png]]
> 
> Do the opposite for concatenating.
> 
> ![[Pasted image 20240324030521.png]]


> [!idea]+ Deletion
> Search for the predecessor of the node to be deleted. Update pointers for this node to be what the deleted node points to.
> 
> ![[Pasted image 20240324030649.png]]
> 
> ![[Pasted image 20240324030706.png]]

