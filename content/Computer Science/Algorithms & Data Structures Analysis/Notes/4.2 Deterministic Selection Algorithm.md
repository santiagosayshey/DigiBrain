
> [!idea]+ Idea
> We already found a selection algorithm in [[4.1 Randomised Selection Algorithm|RSelect]] that can sort on average in $O(n)$ time, why bother with anything else? Because DSelect is fucking cool, that's why. Ok but really, DSelect provides an at worst $O(n)$ running time by carefully selecting the pivot, rather than at random.

> [!consider] Guaranteeing a Good Pivot
>
> Use the **Median of Medians** strategy as it ensures a good pivot by selecting a pivot that is not too extreme. This strategy divides the array into smaller groups, sorts these groups, and takes the median of each. By recursively finding the median of these medians, we guarantee a pivot that is reasonably central. This method significantly improves the efficiency of quicksort and selection algorithms by ensuring that the partitioning is relatively balanced, avoiding the worst-case performance associated with choosing poor pivots.

> [!code] ChoosePivot
> ```c
> ChoosePivot(array A, length n) {
>     array C[n / 5]; // Create an array to store medians
>     for (int i = 0; i < n / 5; i++) {
>         sort(A + i * 5, 5); // Sort each group of 5 elements
>         C[i] = A[i * 5 + 2]; // Pick the median and store it in C
>     }
> 
>     // Recursively find the median of the medians
>     return ChoosePivot(C, n / 5);
> }
> ```

> [!code] DSelect
> ```c
> RSelect(array A, length n, order_statistic i) {
> 	if n == 1
> 		return A[0]
> 		
> 	pivot = ChoosePivot(A, n)
> 	partition(A, pivot)           //  A = [   < pivot  | pivot |      > pivot      ]
> 	j = index of pivot
> 	
> 	if i == j
> 		return pivot        // since the pivot is in it's final position, it is the j'th smallest element
> 	else if j > i
> 		return RSelect(A[partition 1], j-1, i)
> 	else if j > i
> 		return RSelect(A[partition 2], n-j, i-j)
> }
>```
