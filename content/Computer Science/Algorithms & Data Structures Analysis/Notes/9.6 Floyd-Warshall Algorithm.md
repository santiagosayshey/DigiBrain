> [!idea] Floyd-Warshall Algorithm
>
> The Floyd-Warshall algorithm is an [[9.4 All-Pairs Shortest Path|All-Pairs Shortest Path]] algorithm that finds the shortest paths between all pairs of vertices in a weighted graph. It is an example of [[9.5 Dynamic Programming|dynamic programming]], where the shortest path problem is solved by breaking it down into smaller subproblems.
>
> The key idea behind the Floyd-Warshall algorithm is to gradually **build up the solution by considering the intermediate vertices in the paths**. It starts by considering paths that use no intermediate vertices, then paths that use vertex 1 as an intermediate, then paths that use vertices 1 and 2, and so on, until all vertices have been considered as intermediates.
>
> The algorithm maintains a distance matrix that stores the shortest path distances between all pairs of vertices. It iteratively updates the distance matrix by considering the effect of including each vertex as an intermediate node in the paths.
>
> The Floyd-Warshall algorithm can handle graphs with negative edge weights but not negative cycles. If a negative cycle is present, the algorithm will detect it and report that no solution exists.

> [!example] Floyd-Warshall Algorithm Example
>
> Let's consider the following weighted graph:
>
> ![[Floyd-Warshall Example.png|400]]
>
> We want to find the shortest path distances between all pairs of vertices using the Floyd-Warshall algorithm.
>
> The algorithm starts by initializing the distance matrix with the direct edge weights between vertices. If there is no direct edge between two vertices, the distance is set to infinity.
>
> Initial distance matrix:
>
> |   | A   | B   | C   | D   |
> |---|-----|-----|-----|-----|
> | A | 0   | 8   | ∞   | 1   |
> | B | ∞   | 0   | 1   | ∞   |
> | C | 4   | ∞   | 0   | ∞   |
> | D | ∞   | 2   | 9   | 0   |
>
> The algorithm then iteratively considers each vertex as an intermediate and updates the distance matrix accordingly.
>
> After considering vertex A as an intermediate:
>
> |   | A   | B   | C   | D   |
> |---|-----|-----|-----|-----|
> | A | 0   | 8   | ∞   | 1   |
> | B | ∞   | 0   | 1   | ∞   |
> | C | 4   | 12  | 0   | 5   |
> | D | ∞   | 2   | 9   | 0   |
>
> After considering vertex B as an intermediate:
>
> |   | A   | B   | C   | D   |
> |---|-----|-----|-----|-----|
> | A | 0   | 8   | 9   | 1   |
> | B | ∞   | 0   | 1   | ∞   |
> | C | 4   | 5   | 0   | 5   |
> | D | ∞   | 2   | 3   | 0   |
>
> After considering vertex C as an intermediate:
>
> |   | A   | B   | C   | D   |
> |---|-----|-----|-----|-----|
> | A | 0   | 7   | 9   | 1   |
> | B | 11  | 0   | 1   | 12  |
> | C | 4   | 5   | 0   | 5   |
> | D | 6   | 2   | 3   | 0   |
>
> After considering vertex D as an intermediate (final distance matrix):
>
> |   | A   | B   | C   | D   |
> |---|-----|-----|-----|-----|
> | A | 0   | 3   | 4   | 1   |
> | B | 6   | 0   | 1   | 7   |
> | C | 4   | 5   | 0   | 5   |
> | D | 6   | 2   | 3   | 0   |
>
> The final distance matrix gives the shortest path distances between all pairs of vertices in the graph.

> [!idea] Time Complexity of Floyd-Warshall Algorithm
>
> The Floyd-Warshall algorithm has a time complexity of $O(V^3)$, where $V$ is the number of vertices in the graph.
>
> The algorithm uses three nested loops, each iterating over the vertices of the graph. In each iteration, it performs a constant number of operations to update the distance matrix. Therefore, the total number of operations is proportional to $V^3$.
> 
> The space complexity of the Floyd-Warshall algorithm is $O(V^2)$ since it uses a distance matrix of size $V \times V$ to store the shortest path distances between all pairs of vertices.
>
> Here's the pseudocode for the Floyd-Warshall algorithm:

```python
function FloydWarshall(graph):
    n = number of vertices in graph
    dist = n x n matrix initialized with infinity
    
    # Initialize the distance matrix
    for each edge (u, v) with weight w in graph:
        dist[u][v] = w
    
    for each vertex v in graph:
        dist[v][v] = 0
    
    # Update the distance matrix considering each vertex as intermediate
    for k from 1 to n:
        for i from 1 to n:
            for j from 1 to n:
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
```


