> [!motivation] Efficient Algorithms
> An algorithm is **considered efficient if it RUNS in polynomial time**. This means that for an input of size $n$, the execution time is bounded by $O(p(n))$, where $p(n)$ is a polynomial function. Problems that can be solved in polynomial time are said to be in the class P.

> [!idea] Class NP (Nondeterministic Polynomial Time)
> A problem is in the class NP if it has the following characteristics:
> 1. When the answer to the problem is "yes," there is a way to prove it by providing some additional information (called a "witness" or "certificate"). The size of this additional information should not be too large â€“ it should be at most polynomially larger than the size of the original problem input.
> 2. When the answer to the problem is "no," no such proof or additional information exists.
> 3. If someone claims to have a proof or witness for a "yes" answer, it should be possible to check whether the proof is correct in polynomial time.
>
> In other words, **a problem is in NP if it's possible to VERIFY a "yes" answer efficiently** (in polynomial time), given the right proof or additional information. However, there might not be an efficient way to find the proof or solve the problem from scratch.

> [!example] Examples of Problems in NP
> - Hamiltonian Cycle Problem: Given an undirected graph $G$, decide if it contains a Hamiltonian cycle (a cycle that visits each node exactly once).
> - Traveling Salesman Problem: Given a complete edge-weighted undirected graph $G$ and an integer $C$, decide if $G$ contains a Hamiltonian cycle of cost at most $C$.
> - Graph Coloring Problem: Given an undirected graph $G$ and an integer $k$, decide if there exists a coloring of the nodes with $k$ colors such that adjacent nodes have different colors.
> - Boolean Satisfiability Problem (SAT): Given a Boolean expression, decide if there exists an assignment of truth values to the variables that makes the expression true.
> - Clique Problem: Given an undirected graph $G$ and an integer $k$, decide if $G$ contains a clique (a complete subgraph) of size $k$.


> [!idea] NP-Hardness
> **A problem $X$ is said to be NP-hard if every problem in NP can be reduced to $X$ in polynomial time**. In other words, if we have a polynomial-time algorithm that solves $X$, we can use it to solve any problem in NP in polynomial time by first reducing the NP problem to $X$ and then solving $X$.
>
> Formally, a problem $X$ is NP-hard if, for every problem $Y$ in NP, there exists a polynomial-time reduction from $Y$ to $X$. This means that we can transform any instance of $Y$ into an instance of $X$ in polynomial time, such that a solution to the $X$ instance gives us a solution to the original $Y$ instance.
>
> It's important to note that NP-hard problems don't necessarily have to be in NP themselves. In fact, some NP-hard problems, like the Halting Problem, are undecidable, meaning there is no algorithm that can always give a correct answer for every instance of the problem.

> [!example] NP-Hardness: The Party Problem
> Imagine you're planning a party and want to invite a group of friends. However, some of your friends don't get along with each other. You want to invite the maximum number of friends possible while ensuring that no two friends who don't get along are invited together.
>
> This problem is similar to the Maximum Independent Set problem, which is NP-hard. In this context, each friend represents a node in a graph, and an edge between two nodes means that those two friends don't get along. Finding the largest group of friends who can attend the party without any conflicts is equivalent to finding the maximum independent set in the graph, which is an NP-hard problem.
>
> The party problem illustrates the concept of NP-hardness because if you had a polynomial-time algorithm to solve this problem, you could use it to solve many other hard problems in NP by reducing them to the party problem.

> [!idea] NP-Completeness
> A problem is NP-complete if it is both in NP and NP-hard. In other words, an NP-complete problem is a problem in NP that is at least as hard as any other problem in NP.
>
> To prove that a problem $X$ is NP-complete, we need to show two things:
> 1. $X$ is in NP, meaning that given a solution, we can verify its correctness in polynomial time.
> 2. $X$ is NP-hard, meaning that every problem in NP can be reduced to $X$ in polynomial time.
>
> NP-complete problems are the hardest problems in NP because if we find a polynomial-time algorithm for any NP-complete problem, we would have a polynomial-time algorithm for all problems in NP, proving that P = NP.

> [!example] NP-Completeness: The Jigsaw Puzzle Problem
> Consider a jigsaw puzzle with a large number of pieces. The goal is to determine whether it's possible to assemble the puzzle in a specific way, given a picture of the completed puzzle.
>
> This problem is NP-complete because:
> 1. Given a proposed solution (an arrangement of the puzzle pieces), you can easily verify whether it matches the completed picture in polynomial time, so the problem is in NP.
> 2. The problem is also NP-hard, as many other problems in NP, such as the Hamiltonian Cycle problem, can be reduced to the jigsaw puzzle problem. For example, you could encode a Hamiltonian Cycle problem as a jigsaw puzzle, where each piece represents a node in the graph, and the connections between pieces represent the edges. Solving the puzzle would then be equivalent to finding a Hamiltonian cycle in the original graph.
>
> The jigsaw puzzle problem demonstrates the concept of NP-completeness because it is both in NP (verifiable in polynomial time) and NP-hard (other NP problems can be reduced to it).

> [!consider] Implications of NP-completeness
> The concept of NP-completeness has significant implications for problem-solving in computer science and beyond. If a problem is proven to be NP-complete, it means that finding an efficient (polynomial-time) algorithm for it is unlikely, and we should instead focus on developing approximation algorithms, heuristics, or solving special cases of the problem.
>
> Additionally, if we manage to find a polynomial-time algorithm for any NP-complete problem, it would immediately imply that all problems in NP have polynomial-time solutions, proving that P = NP. This would be a groundbreaking result in computer science and would have profound consequences for fields like cryptography, optimization, and artificial intelligence.


> [!motivation] The P vs. NP Problem
> The question of whether $P = NP$ is one of the most important open problems in computer science. If $P = NP$, it would have significant implications for cryptography, optimization, and many other fields. However, most experts believe that $P \neq NP$, meaning that there are problems in NP that cannot be solved efficiently.


Sure! Let me provide you with intuitive examples to help clarify the concepts of NP-hardness and NP-completeness.





> [!consider] Implications of NP-hardness and NP-completeness
> The party problem and the jigsaw puzzle problem showcase the difficulty of NP-hard and NP-complete problems. While these examples may seem simple, they represent a class of problems for which no efficient (polynomial-time) algorithms are known.
>
> If you were to find a polynomial-time algorithm to solve either of these problems, you would essentially be solving all problems in NP efficiently, proving that P = NP. This is why NP-hard and NP-complete problems are considered the most challenging problems in computer science, and why the P vs. NP question is one of the most important open problems in the field.

These examples provide an intuitive understanding of NP-hardness and NP-completeness, demonstrating how these complex concepts can be related to real-world scenarios. The implications of these problem classes highlight their significance in computer science and the ongoing quest to understand the relationship between P and NP.