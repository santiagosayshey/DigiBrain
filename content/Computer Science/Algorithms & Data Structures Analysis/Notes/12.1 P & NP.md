> [!motivation] Efficient Algorithms
> An algorithm is **considered efficient if it RUNS in polynomial time**. This means that for an input of size $n$, the execution time is bounded by $O(p(n))$, where $p(n)$ is a polynomial function. Problems that can be solved in polynomial time are said to be in the class P.

> [!idea] Class NP (Nondeterministic Polynomial Time)
> A problem is in the class NP if it has the following characteristics:
> 1. When the answer to the problem is "yes," there is a way to prove it by providing some additional information (called a "witness" or "certificate"). The size of this additional information should not be too large â€“ it should be at most polynomially larger than the size of the original problem input.
> 2. When the answer to the problem is "no," no such proof or additional information exists.
> 3. If someone claims to have a proof or witness for a "yes" answer, it should be possible to check whether the proof is correct in polynomial time.
>
> In other words, **a problem is in NP if it's possible to VERIFY a "yes" answer efficiently** (in polynomial time), given the right proof or additional information. However, there might not be an efficient way to find the proof or solve the problem from scratch.

> [!example] Examples of Problems in NP
> - Hamiltonian Cycle Problem: Given an undirected graph $G$, decide if it contains a Hamiltonian cycle (a cycle that visits each node exactly once).
> - Traveling Salesman Problem: Given a complete edge-weighted undirected graph $G$ and an integer $C$, decide if $G$ contains a Hamiltonian cycle of cost at most $C$.
> - Graph Coloring Problem: Given an undirected graph $G$ and an integer $k$, decide if there exists a coloring of the nodes with $k$ colors such that adjacent nodes have different colors.
> - Boolean Satisfiability Problem (SAT): Given a Boolean expression, decide if there exists an assignment of truth values to the variables that makes the expression true.
> - Clique Problem: Given an undirected graph $G$ and an integer $k$, decide if $G$ contains a clique (a complete subgraph) of size $k$.

> [!consider] NP-Completeness and NP-Hardness
> A problem $X$ is NP-hard if every problem in NP can be reduced to $X$ in polynomial time. A problem is NP-complete if it is both in NP and NP-hard. NP-complete problems are the hardest problems in NP, and finding a polynomial-time algorithm for any one of them would imply $P = NP$.

> [!motivation] The P vs. NP Problem
> The question of whether $P = NP$ is one of the most important open problems in computer science. If $P = NP$, it would have significant implications for cryptography, optimization, and many other fields. However, most experts believe that $P \neq NP$, meaning that there are problems in NP that cannot be solved efficiently.



I hope these revised notes meet your expectations! Let me know if you need any further assistance.