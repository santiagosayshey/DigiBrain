> [!motivation] Efficient Algorithms
> An algorithm is **considered efficient if it runs in polynomial time**. This means that for an input of size $n$, the execution time is bounded by $O(p(n))$, where $p(n)$ is a polynomial function. Problems that can be solved in polynomial time are said to be in the class P.

> [!example] Examples of Problems in P
> - Integer Addition: $O(n)$
> - Integer Multiplication: $O(n^2)$
> - Testing if a graph is acyclic
> - Shortest paths (Dijkstra's Algorithm): $O(m + n^2)$
> - Minimum Spanning Trees (Kruskal's Algorithm): $O(m \log m)$

> [!idea] Class NP
> A decision problem is in the class NP (nondeterministic polynomial time) if there exists a predicate $Q(x, y)$ and a polynomial $p$ such that:
> 1. For every $x$ in the language $L$, there exists a witness $y$ of length at most $p(|x|)$ such that $Q(x, y)$ is true.
> 2. For every $x$ not in $L$, there is no witness $y$ such that $Q(x, y)$ is true.
> 3. The predicate $Q(x, y)$ can be verified in polynomial time.
>
> In simpler terms, a problem is in NP if we can guess a solution and verify its correctness in polynomial time.

> [!example] Examples of Problems in NP
> - Hamiltonian Cycle Problem: Given an undirected graph $G$, decide if it contains a Hamiltonian cycle (a cycle that visits each node exactly once).
> - Traveling Salesman Problem: Given a complete edge-weighted undirected graph $G$ and an integer $C$, decide if $G$ contains a Hamiltonian cycle of cost at most $C$.
> - Graph Coloring Problem: Given an undirected graph $G$ and an integer $k$, decide if there exists a coloring of the nodes with $k$ colors such that adjacent nodes have different colors.
> - Boolean Satisfiability Problem (SAT): Given a Boolean expression, decide if there exists an assignment of truth values to the variables that makes the expression true.
> - Clique Problem: Given an undirected graph $G$ and an integer $k$, decide if $G$ contains a clique (a complete subgraph) of size $k$.

> [!consider] NP-Completeness and NP-Hardness
> A problem $X$ is NP-hard if every problem in NP can be reduced to $X$ in polynomial time. A problem is NP-complete if it is both in NP and NP-hard. NP-complete problems are the hardest problems in NP, and finding a polynomial-time algorithm for any one of them would imply $P = NP$.

> [!motivation] The P vs. NP Problem
> The question of whether $P = NP$ is one of the most important open problems in computer science. If $P = NP$, it would have significant implications for cryptography, optimization, and many other fields. However, most experts believe that $P \neq NP$, meaning that there are problems in NP that cannot be solved efficiently.

> [!example] Difficult Problems
> Despite extensive research, no polynomial-time algorithms have been found for many problems in NP, such as:
> - Hamiltonian Cycle Problem
> - Traveling Salesman Problem
> - Boolean Satisfiability Problem
> - Clique Problem
> - Graph Coloring Problem
>
> These problems are believed to be intrinsically hard, and finding efficient algorithms for them remains a major challenge in computer science.

I hope these revised notes meet your expectations! Let me know if you need any further assistance.