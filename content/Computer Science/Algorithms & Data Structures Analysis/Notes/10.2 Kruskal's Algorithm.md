
> [!idea] Kruskal's Algorithm
>
> Kruskal's algorithm is a greedy approach to find the MST of a given graph. It works by sorting the edges in ascending order of their costs/weights and iteratively adding edges that do not form a cycle to the growing MST.

> [!example] Kruskal's Algorithm Example
>
> Given the following graph:
>
> ```
>      3
>   1 --- 2
>   |     |
>   5     4
>   |     |
>   3 --- 4 --- 7
>       2
> ```
>
> Sorted edges: [(1, 2, 1), (2, 4, 2), (1, 3, 3), (3, 4, 3), (2, 3, 4), (1, 5, 5), (4, 5, 7)]
>
> 1. Start with an empty MST.
> 2. Add the edge (1, 2, 1) to the MST.
> 3. Add the edge (2, 4, 2) to the MST.
> 4. Skip the edge (1, 3, 3) as it forms a cycle.
> 5. Add the edge (3, 4, 3) to the MST.
> 6. Skip the edge (2, 3, 4) as it forms a cycle.
> 7. Add the edge (1, 5, 5) to the MST.
> 8. Skip the edge (4, 5, 7) as it forms a cycle.
>
> The resulting MST has a total cost of 1 + 2 + 3 + 5 = 11.

> [!consider] Additional Considerations for Kruskal's Algorithm
>
> - **Time Complexity:** Kruskal's algorithm has a time complexity of O(m log m), where m is the number of edges. This is due to the sorting step, which takes O(m log m) time using a comparison-based sorting algorithm.
> - **Union-Find Data Structure:** To efficiently detect cycles during the algorithm's execution, Kruskal's algorithm uses a Union-Find data structure. This data structure supports efficient `FIND` and `UNION` operations, which are used to determine if adding an edge would create a cycle.
> - **Implementation Details:** The Union-Find data structure can be implemented using various techniques, such as a list-oriented approach or a tree-based approach. The choice of implementation can affect the overall time complexity and performance of the algorithm.

> [!idea] Prim's Algorithm (JarnÃ­k's Algorithm)
>
> Prim's algorithm is another greedy approach to find the MST of a given graph. It starts with an arbitrary vertex and grows the MST by iteratively adding the minimum-cost edge that connects a vertex in the MST to a vertex outside the MST.

> [!example] Prim's Algorithm Example
>
> Given the following graph:
>
> ```
>      4
>   1 --- 9
>   |     |
>   3     2
>   |     |
>   6 --- 5 --- 7
>       2
> ```
>
> 1. Start with an arbitrary vertex, say 1, and initialize the MST with vertex 1.
> 2. Add the minimum-cost edge (1, 3, 3) to the MST, connecting vertex 3.
> 3. Add the minimum-cost edge (3, 6, 6) to the MST, connecting vertex 6.
> 4. Add the minimum-cost edge (6, 5, 2) to the MST, connecting vertex 5.
> 5. Add the minimum-cost edge (5, 2, 2) to the MST, connecting vertex 2.
> 6. Add the minimum-cost edge (2, 4, 1) to the MST, connecting vertex 4.
> 7. Add the minimum-cost edge (4, 9, 4) to the MST, connecting vertex 9.
>
> The resulting MST has a total cost of 3 + 6 + 2 + 2 + 1 + 4 = 18.

> [!consider] Additional Considerations for Prim's Algorithm
>
> - **Time Complexity:** Prim's algorithm has a time complexity of O((m + n) log n), where m is the number of edges, and n is the number of vertices. This is due to the use of a priority queue data structure to efficiently find the minimum-cost edge at each step.
> - **Priority Queue Implementation:** The choice of priority queue implementation, such as a binary heap or a Fibonacci heap, can impact the overall time complexity and performance of the algorithm.
> - **Comparison with Kruskal's Algorithm:** Prim's algorithm is generally more efficient than Kruskal's algorithm for dense graphs, where the number of edges (m) is close to n^2. For sparse graphs, Kruskal's algorithm may be more efficient.

> [!consider] General Considerations for MSTs
>
> - **Parallel Algorithms:** Both Kruskal's and Prim's algorithms can be parallelized to take advantage of multi-core or distributed computing environments, potentially improving their performance for large graphs.
> - **Approximation Algorithms:** In some cases, finding an exact MST may be computationally expensive or infeasible. Approximation algorithms can be used to find near-optimal solutions in a reasonable amount of time.
> - **Dynamic Graphs:** In scenarios where the graph structure or edge costs/weights change over time, incremental algorithms or dynamic data structures may be needed to efficiently update the MST.
> - **Variations:** There are variations of the MST problem, such as the Euclidean MST problem, where the edge costs are Euclidean distances between points in a plane or higher-dimensional space. These variations may require specialized algorithms or techniques.

