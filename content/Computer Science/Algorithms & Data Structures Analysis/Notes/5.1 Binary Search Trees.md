

> [!idea] Binary Search Trees
>
> Balanced Binary Search Trees (BSTs) offer a dynamic, highly efficient way to store data that is always sorted, allowing for fast retrieval similar to that of a sorted array. However, unlike arrays, balanced BSTs are designed to maintain optimal balance through various algorithms, such as AVL trees or Red-Black trees, ensuring that operations like **search, insertion and deletion can be performed in logarithmic time complexity**.
>
> A BST has exactly one node per key, which forms the most basic version of the tree.
> ```c
> struct Node {
>     int element;
>     Node* left;
>     Node* right;
> };
> ```
>
> The **Search Tree Property** is a fundamental characteristic of a Binary Search Tree. It states that for any node x in the BST, **all keys in the left subtree of x must be less than x** , and **all keys in the right subtree of x must be greater than x**. This property should hold at every node of the tree, ensuring that the keys are stored in a sorted manner. By maintaining the Search Tree Property, BSTs enable efficient searching, insertion, and deletion operations.
>
> In-Order Traversal is a way to **visit all the nodes of a BST in ascending order of their keys**. It follows a specific sequence: first, it recursively traverses the left subtree, then visits the current node, and finally, it recursively traverses the right subtree. The in-order traversal of a BST produces a sorted sequence of keys, which is particularly useful when you need to process the nodes in sorted order. Some common applications of in-order traversal include printing the keys in ascending order, performing range queries efficiently by leveraging the sorted order of keys, and validating the correctness of a BST by checking if the in-order traversal produces a sorted sequence. The time complexity of in-order traversal is O(n), where n is the number of nodes in the tree, as it visits each node exactly once.
> 
> ![[Pasted image 20240311115816.png]]

> [!consider] Consider the height of a BST
> It's important to note that there are multiple possible binary search trees for the same set of keys. The structure of a BST can vary widely, depending on the order of insertion and deletion of keys. The image above shows valid BSTs for a set of elements.
> 
> The height of a Binary Search Tree (BST) is a crucial factor in determining the running time of search, insertion, and deletion operations. In a **perfectly balanced BST** of height $\log{n}$, the height is logarithmic in relation to the number of nodes, resulting in efficient **$O(\log n)$** time complexity for these operations.
>
> However, in the worst-case scenario, when the **BST is skewed or unbalanced,** the height can become linear, leading to a time complexity of **$O(n)$** for search, insertion, and deletion. This occurs when the BST resembles a linked list, with each node having only one child.
>
> | Operation | Best Case | Average Case | Worst Case |
> |-----------|-----------|--------------|------------|
> | Search    | O(1)      | O(log n)     | O(n)       |
> | Insertion | O(1)      | O(log n)     | O(n)       |
> | Deletion  | O(1)      | O(log n)     | O(n)       |

> [!idea]+ BST Search
> 
> Search for a key $k$ in a tree $t$.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchBST(node, key):
>     if node is null or key equals node.element:
>         return node
>     
>     if key is less than node.element:
>         return searchBST(node.left, key)
>     else:
>         return searchBST(node.right, key)
> ```

![[5.1.1]]

> [!idea]+ BST Insertion
> Insert a node $k$ in a tree $t$.
> - Call `search(k)`
> - If not found is returned, insert node $k$ as child of last visited node of `search(k)`

![[5.1.2]]

> [!idea]+ BST Removal
> Remove a node $k$ from a tree $t$
> - `searck(k)`
> 	- If k is stored at a leaf, delete this leaf and the incoming edge
> 	- If k has 1 child, redirect pointer pointing to k to x and delete k
> 	- If k has 2 children:
> 		- Search in the three for the largest element x smaller than k
> 			- In the left subtree, follow the right path as long as possible
> 		- Swap x and k and delete k

![[5.1.3]]

![[5.1.4]]

![[5.1.5]]









> [!idea]+ BST Search
>
> Search for a key $k$ in a tree $t$.
>
> - Start at the root
>
> - At node x, compare x and k
>
> 1. If `k = x`, then found
>
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
>
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
>
> ```c
> function searchBST(node, key):
>     if node is null or key equals node.element:
>         return node
>     
>     if key is less than node.element:
>         return searchBST(node.left, key)
>     else:
>         return searchBST(node.right, key)
> ```

> [!idea]+ BST Insertion
>
> Insert a node $k$ in a tree $t$.
>
> - Call `search(k)`
>
> - If not found is returned, insert node $k$ as child of last visited node of `search(k)`
>
> ```c
> function insertBST(node, key):
>     if node is null:
>         create a new node with key
>         return the new node
>     
>     if key is less than node.element:
>         node.left = insertBST(node.left, key)
>     else if key is greater than node.element:
>         node.right = insertBST(node.right, key)
>     
>     return node
> ```

> [!idea]+ BST Removal
>
> Remove a node $k$ from a tree $t$
>
> - `search(k)`
>
> - If k is stored at a leaf, delete this leaf and the incoming edge
>
> - If k has 1 child, redirect pointer pointing to k to x and delete k
>
> - If k has 2 children:
>
>   - Search in the tree for the largest element x smaller than k
>
>   - In the left subtree, follow the right path as long as possible
>
>   - Swap x and k and delete k
>
> ```c
> function deleteBST(node, key):
>     if node is null:
>         return null
>     
>     if key is less than node.element:
>         node.left = deleteBST(node.left, key)
>     else if key is greater than node.element:
>         node.right = deleteBST(node.right, key)
>     else:
>         if node.left is null:
>             return node.right
>         else if node.right is null:
>             return node.left
>         
>         // node has two children
>         successor = findMinimum(node.right)
>         node.element = successor.element
>         node.right = deleteBST(node.right, successor.element)
>     
>     return node
>
> function findMinimum(node):
>     while node.left is not null:
>         node = node.left
>     return node
> ```

The pseudocode for insertion and deletion follows the logic described in the respective sections. The insertion process uses recursion to traverse the BST and find the appropriate position to insert the new node, while maintaining the BST property. The deletion process handles three cases: deleting a leaf node, deleting a node with one child, and deleting a node with two children. In the case of two children, the largest element smaller than the node to be deleted (the successor) is found, swapped with the node, and then the node is deleted.