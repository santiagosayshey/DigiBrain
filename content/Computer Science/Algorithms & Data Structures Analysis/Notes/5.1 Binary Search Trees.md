
> [!idea]
> Balanced Binary Search Trees (BSTs) offer a dynamic, highly efficient way to store data that is always sorted, allowing for fast retrieval similar to that of a sorted array. However, unlike arrays, balanced BSTs are designed to maintain optimal balance through various algorithms, such as AVL trees or Red-Black trees, ensuring that operations like **search, insertion and deletion can be performed in logarithmic time complexity**.
> 
> - A BST has exactly one node per key, which forms the most basic version of the tree.
> - Each node in the BST contains:
>   - A left child pointer.
>   - A right child pointer.
>   - An element
> - **Search Tree Property:**
>   - This property should hold at every node of the tree.
>   - For any node `x`, all keys in the left subtree of `x` are less than the key value of `x`.
>   - For any node `x`, all keys in the right subtree of `x` are greater than the key value of `x`.
> - **Key Point:**
>   - It's important to note that there are multiple possible binary search trees for the same set of keys. The structure of a BST can vary widely, depending on the order of insertion and deletion of keys. The image below shows valid BSTs for a set of elements
> - **Height:**
> 	- The longest root - leaf path can be anywhere from $n$ to $log_2{n}$

 ![[Pasted image 20240311115816.png]]

> [!idea]+ BST Search
> Search for a key $k$ in a tree $t$.
> - Start at the root
> - At node x, compare x and k
> 	1. If `k = x`, then gound
> 	2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 	3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> 	3. 
