> [!idea]
> 
> Balanced Binary Search Trees (BSTs) offer a dynamic, highly efficient way to store data that is always sorted, allowing for fast retrieval similar to that of a sorted array. However, unlike arrays, balanced BSTs are designed to maintain optimal balance through various algorithms, such as AVL trees or Red-Black trees, ensuring that operations like **search, insertion and deletion can be performed in logarithmic time complexity**.
> 
> - A BST has exactly one node per key, which forms the most basic version of the tree.
> 
> - Each node in the BST contains:
>   - A left child pointer.
>   - A right child pointer.
>   - An element
> 
> - **Search Tree Property:**
>   - This property should hold at every node of the tree.
>   - For any node `x`, all keys in the left subtree of `x` are less than the key value of `x`.
>   - For any node `x`, all keys in the right subtree of `x` are greater than the key value of `x`.
> 
> - **Key Point:**
>   - It's important to note that there are multiple possible binary search trees for the same set of keys. The structure of a BST can vary widely, depending on the order of insertion and deletion of keys. The image below shows valid BSTs for a set of elements.
> 
> - **Height:**
>   - The longest root-leaf path can be anywhere from $n$ to $log_2{n}$. A perfectly balanced BST has a height of $log_2{n}$.
> 
> - **In-Order Traversal:**
>   - In-order traversal is a way to visit all the nodes of a BST in ascending order of their keys.
>   - The in-order traversal of a BST produces a sorted sequence of keys.
>   - This property is particularly useful when you need to process the nodes of a BST in sorted order, such as:
>     - Printing the keys in ascending order.
>     - Performing range queries efficiently by leveraging the sorted order of keys.
>     - Validating the correctness of a BST by checking if the in-order traversal produces a sorted sequence.
>   - The time complexity of in-order traversal is O(n), where n is the number of nodes in the tree, as it visits each node exactly once.


 ![[Pasted image 20240311115816.png]]

> [!idea]+ BST Search
> Search for a key $k$ in a tree $t$.
> - Start at the root
> - At node x, compare x and k
> 	1. If `k = x`, then gound
> 	2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 	3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`

![[5.1.1]
> [!consider] Consider the height of a BST
> 
> The height of a Binary Search Tree (BST) is a crucial factor in determining the running time of search, insertion, and deletion operations. In a perfectly balanced BST of height l, the height is logarithmic in relation to the number of nodes, resulting in efficient O(log n) time complexity for these operations.
>
> However, in the worst-case scenario, when the BST is skewed or unbalanced, the height can become linear, leading to a time complexity of O(n) for search, insertion, and deletion. This occurs when the BST resembles a linked list, with each node having only one child.



> [!idea]+ BST Insertion
> Insert a node $k$ in a tree $t$.
> - Call `search(k)`
> - If not found is returned, insert node $k$ as child of last visited node of `search(k)`

![[5.1.2]]

> [!idea]+ BST Removal
> Remove a node $k$ from a tree $t$
> - `searck(k)`
> 	- If k is stored at a leaf, delete this leaf and the incoming edge
> 	- If k has 1 child, redirect pointer pointing to k to x and delete k
> 	- If k has 2 children:
> 		- Search in the three for the largest element x smaller than k
> 			- In the left subtree, follow the right path as long as possible
> 		- Swap x and k and delete k

![[5.1.3]]

![[5.1.4]]

![[5.1.5]]













