

> [!idea] Binary Search Trees
>
> Balanced Binary Search Trees (BSTs) offer a dynamic, highly efficient way to store data that is always sorted, allowing for fast retrieval similar to that of a sorted array. However, unlike arrays, balanced BSTs are designed to maintain optimal balance through various algorithms, such as [[5.2 AVL Trees|AVL trees]] or Red-Black trees, ensuring that operations like **search, insertion and deletion can be performed in logarithmic time complexity**.
>
> A BST has exactly one node per key, which forms the most basic version of the tree.
> ```python
> class Node:
 >    def __init__(self, key):
 >        self.key = key
 >        self.left = None
 >        self.right = None
 >        self.height = 1
> ```
>
> The **Search Tree Property** is a fundamental characteristic of a Binary Search Tree. It states that for any node x in the BST, **all keys in the left subtree of x must be less than x** , and **all keys in the right subtree of x must be greater than x**. This property should hold at every node of the tree, ensuring that the keys are stored in a sorted manner. By maintaining the Search Tree Property, BSTs enable efficient searching, insertion, and deletion operations.
>
> In-Order Traversal is a way to **visit all the nodes of a BST in ascending order of their keys**. It follows a specific sequence: first, it recursively traverses the left subtree, then visits the current node, and finally, it recursively traverses the right subtree. The in-order traversal of a BST produces a sorted sequence of keys, which is particularly useful when you need to process the nodes in sorted order. Some common applications of in-order traversal include printing the keys in ascending order, performing range queries efficiently by leveraging the sorted order of keys, and validating the correctness of a BST by checking if the in-order traversal produces a sorted sequence. The time complexity of in-order traversal is O(n), where n is the number of nodes in the tree, as it visits each node exactly once.
> 
> ![[Pasted image 20240311115816.png]]

> [!consider] Consider the height of a BST
> It's important to note that there are multiple possible binary search trees for the same set of keys. The structure of a BST can vary widely, depending on the order of insertion and deletion of keys. The image above shows valid BSTs for a set of elements.
> 
> The height of a Binary Search Tree (BST) is a crucial factor in determining the running time of search, insertion, and deletion operations. In a **perfectly balanced BST** of height $\log{n}$, the height is logarithmic in relation to the number of nodes, resulting in efficient **$O(\log n)$** time complexity for these operations.
>
> However, in the worst-case scenario, when the **BST is skewed or unbalanced,** the height can become linear, leading to a time complexity of **$O(n)$** for search, insertion, and deletion. This occurs when the BST resembles a linked list, with each node having only one child.
> 
>
> | Operation | Best Case | Average Case | Worst Case |
> |-----------|-----------|--------------|------------|
> | Search    | O(1)      | O(log n)     | O(n)       |
> | Insertion | O(1)      | O(log n)     | O(n)       |
> | Deletion  | O(1)      | O(log n)     | O(n)       |


> [!idea]+ Left RotationA
> Content


> [!idea]+ BST Search
> 
> Search for a key $k$ in a tree $t$.
> 
> - Start at the root
> 
> - At node x, compare x and k
> 
> 1. If `k = x`, then found
> 
> 2. If `k < x`, search in the left subtree of x. If subtree does not exist, return `not found`
> 
> 3. If `k > x`, search in the right subtree of x. If subtree does not exist, return `not found`
> ```c
> function searchBST(node root, int k)
>     if root is NULL
>         return NULL // Tree is empty or key not found
> 
>     if k == root.key
>         return root // Key found
> 
>     if k < root.key
> 		return searchBST(root.left, k) // Recurse on left subtree
> 
>     if k > root.key
> 		return searchBST(root.right, k) // Recurse on right subtree
> ```


![[5.1.1]]

Apologies for the oversight. Here's the insertion process with a call to `search`, formatted according to your specifications:

> [!idea]+ BST Insertion
> 
> Insert a node $k$ in a tree $t$.
> 
> - Call `search(k)`
> - If `not found` is returned, insert node $k$ as child of the last visited node in `search(k)`
> ```c
> function insertBST(node root, int k)
>     node toInsert = newNode(k) // Assume newNode creates a new node with key k
>     if root is NULL
>         return toInsert // New tree with k as root if tree is empty
> 
>     node parent = NULL
>     node current = root
>     while current is not NULL
>         parent = current
>         if k < current.key
>             current = current.left
>         else if k > current.key
>             current = current.right
>         else
>             return root // Key already exists, do not insert
> 
>     if k < parent.key
>         parent.left = toInsert // Insert as left child
>     else
>         parent.right = toInsert // Insert as right child
> 
>     return root // Return the root of the modified tree
> ```


![[5.1.2]]

> [!idea]+ BST Removal
> 
> Remove a node $k$ from a tree $t$.
> 
> - Call `search(k)` to find the node to remove.
>     - If `k` is stored at a leaf, delete this leaf and the incoming edge.
>     - If `k` has 1 child, redirect the pointer pointing to `k` to `k`'s child and delete `k`.
>     - If `k` has 2 children:
>         - Search in the tree for the largest element `x` smaller than `k`.
>             - In the left subtree of `k`, follow the right path as long as possible to find `x`.
>         - Swap `x` and `k` and delete `k`.
> 
> ```c
> function removeBST(node root, int k) {
>     if root is NULL
>         return NULL // k not found, nothing to do
> 
>     if k < root.key
>         root.left = removeBST(root.left, k) // Go left
>     else if k > root.key
>         root.right = removeBST(root.right, k) // Go right
>     else {
>         // Node with only one child or no child
>         if root.left is NULL {
>             node temp = root.right
>             free(root)
>             return temp
>         }
>         else if root.right is NULL {
>             node temp = root.left
>             free(root)
>             return temp
>         }
> 
>         // Node with two children
>         // Copy the inorder predecessor's content to this node
>         root.key = temp.key
> 
>         // Delete the inorder predecessor
>         root.left = removeBST(root.left, temp.key)
>     }
>     return root
> }
> 
> // Function to find the largest node in a tree
> function maxValueNode(node node) {
>     node current = node
>     while (current.right is not NULL)
>         current = current.right
> 
>     return current
> }
> ```


![[5.1.3]]

![[5.1.4]]

![[5.1.5]]













