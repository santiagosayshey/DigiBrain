
> [!idea]
> Balanced Binary Search Trees (BSTs) offer a dynamic, highly efficient way to store data that is always sorted, allowing for fast retrieval similar to that of a sorted array. However, unlike arrays, balanced BSTs are designed to maintain optimal balance through various algorithms, such as AVL trees or Red-Black trees, ensuring that operations like **search, insertion and deletion can be performed in logarithmic time complexity**.
> 
> - A BST has exactly one node per key, which forms the most basic version of the tree.
> - Each node in the BST contains:
>   - A left child pointer.
>   - A right child pointer.
>   - An element
> - **Search Tree Property:**
>   - This property should hold at every node of the tree.
>   - For any node `x`, all keys in the left subtree of `x` are less than the key value of `x`.
>   - For any node `x`, all keys in the right subtree of `x` are greater than the key value of `x`.
> - **Key Point:**
>   - It's important to note that there are multiple possible binary search trees for the same set of keys. The structure of a BST can vary widely, depending on the order of insertion and deletion of keys.

```
Tree 1:    Tree 2:    Tree 3:
    3          2          4
   / \        / \        / \
  1   4      1   3      2   5
     /          \      /
    2            4    1
                 \   
                  5   
```

| Operation          | Description                                    |         Running Time         |
| ------------------ | ---------------------------------------------- | :--------------------------: |
| Search             | Find a node with a given value                 | <center>$O(\log n)$</center> |
| Select             | Find the k-th smallest value in the tree       | <center>$O(\log n)$</center> |
| Min / Max          | Find the smallest/largest value in the tree    | <center>$O(\log n)$</center> |
| Predecessor        | Find the next smaller value before a given key | <center>$O(\log n)$</center> |
| Successor          | Find the next larger value after a given key   | <center>$O(\log n)$</center> |
| Rank               | Number of keys less than a given value         | <center>$O(\log n)$</center> |
| In-Order Traversal | Output values in sorted order                  |   <center>$O(n)$</center>    |
| **Insert**         | Add a node with a given value                  | <center>$O(\log n)$</center> |
| **Delete**         | Remove a node with a given value               | <center>$O(\log n)$</center> |

