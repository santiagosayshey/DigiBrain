
![[Computer Memory]]


> [!idea]+ Heap Overflow Vulnerabilities
>  
> A heap overflow vulnerability occurs when a program writes more data to a heap-allocated buffer than it can hold, causing the excess data to overflow into adjacent memory locations.
>
> Why heap overflows are dangerous:
> - The overflowed data can corrupt important program data stored in adjacent heap memory
> - Attackers can intentionally overflow heap buffers to overwrite critical data like function pointers or object metadata
> - By carefully crafting their input, attackers can manipulate heap structures to execute arbitrary code
>
> **Example:** Consider a simple program in C that copies user input into a heap buffer:
>
> ```c
> void processInput(char *input) {
>     char *buffer = (char *)malloc(8);
>     strcpy(buffer, input);
>     // ...
> }
> ```
>
> The heap `buffer` is only allocated 8 bytes, but `strcpy` allows copying an arbitrary length string. An attacker could input a very long string:
>
> ```
> AAAAAAAABBBBBBBBCCCCCCCC...
> ```
>
> The input overflows the buffer, corrupting adjacent heap memory. This could overwrite function pointers or heap metadata.
>
> **Potential outcomes of heap overflow attacks**:
> - Crashing the program by corrupting heap metadata
> - Overwriting function pointers to redirect execution flow
> - Manipulating other heap-allocated objects and their behavior
> - Bypassing security checks by overwriting heap-based flags or authorization data
>

> [!idea]+ Virtual Table (vtable) Corruption
>
> Virtual tables (vtables) are used in C++ to support dynamic dispatch of virtual functions in polymorphic objects. However, if an attacker can corrupt an object's vtable pointer, they can hijack the object's behavior.
>
> How vtable exploitation works:
> 1. In C++, each object with virtual functions has a pointer to a vtable, which contains function pointers to the object's virtual methods.
> 2. If an attacker can overwrite an object's vtable pointer (e.g., via a heap overflow), they can redirect it to a malicious vtable.
> 3. When a virtual function is called on the corrupted object, it will invoke the attacker's chosen method instead of the intended one.
>  
> **Example:** Consider a simple C++ object with a virtual `print()` method:
>
> ```cpp
> class MyObject {
> public:
>     virtual void print() { cout << "Legitimate print" << endl; }
> };
> ```
>
> If an attacker can overwrite `MyObject`'s vtable pointer to a fake vtable containing a malicious `print()` implementation:
>
> ```cpp
> class FakeObject {
> public:
>     void maliciousPrint() { cout << "Hacked print!" << endl; launchAttack(); }
> };
> ```
>
> Calling `print()` on the corrupted `MyObject` will invoke `FakeObject::maliciousPrint()` instead.
>  
> **Mitigations:**
> - Use secure coding practices to prevent memory corruption vulnerabilities
> - Enable vtable verification features in compilers (e.g., Microsoft Visual C++'s `/GS` flag)
> - Utilize vtable pointer protection schemes, like XFI (eXtreme Function Interposition)
> - Perform extensive testing and security audits on C++ codebases
>
> Vtable corruption is a powerful exploitation technique that allows attackers to manipulate object behavior in C++ applications. Preventing memory corruption and enabling vtable protections are essential to mitigating this risk.

> [!idea]+ Heap Spraying
>
> Heap spraying is a technique used by attackers to increase the reliability and exploitability of memory corruption vulnerabilities, particularly in web browsers and JavaScript engines.
>
> How heap spraying works:
> 1. The attacker allocates many large blocks on the heap, filling them with malicious code (typically NOP slides and shellcode).
> 2. This "sprays" the heap with the attacker's payload, increasing the probability that a memory corruption vulnerability will land on the malicious code.
> 3. If the attacker can trigger a vulnerability (e.g., a use-after-free or heap overflow) to corrupt a code pointer, there's a high likelihood it will point to the sprayed payload.
> 4. When the corrupted pointer is used, it will execute the attacker's shellcode instead of crashing.
>
> **Example:** A web-based heap spraying attack:
> 1. The attacker crafts a malicious webpage containing JavaScript that sprays the browser heap with NOP slides and shellcode.
> 2. The page also contains a heap-based vulnerability, such as a use-after-free bug in the browser's DOM implementation.
> 3. When a victim visits the page, the JavaScript sprays the heap and triggers the vulnerability.
> 4. The bug corrupts a function pointer on the heap, which now likely points to the attacker's NOP slide.
> 5. The browser dereferences the corrupted pointer, sliding down the NOPs to the shellcode, which then executes in the browser's context.
>
> **Mitigations:**
> - Deploy address space layout randomization (ASLR) to randomize the heap layout
> - Utilize NOP slide detection and prevention mechanisms in allocators and engines
> - Employ strict control flow integrity (CFI) to prevent unexpected control flows
> - Expedite patching of memory corruption vulnerabilities, especially in web-facing attack surfaces
>
> Heap spraying is a powerful technique that increases the chances of successful exploitation, even with hard-to-reach vulnerabilities. A multi-layered mitigation strategy is necessary to prevent heap spraying and reduce its impact.
