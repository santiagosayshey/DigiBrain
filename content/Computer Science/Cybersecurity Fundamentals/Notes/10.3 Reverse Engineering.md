> [!motivation] Need for Reverse Engineering
> 
> Often, we encounter **software or systems without documentation or access to the original source code**. This situation presents several challenges:
> 
> - **Identifying and fixing bugs or vulnerabilities** in the software
> - Integrating the software with other systems or components
> - Assessing the software's security and reliability
> - **Learning from the software's design** and implementation techniques


> [!idea] Reverse Engineering
>
> Reverse engineering is the **process of analysing a software system to identify the system's components** and their interrelationships, **creating representations of the system at a higher level** of abstraction (i.e. binary to source code). This process involves:
> 
> - **Disassembly**: Breaking down compiled executable code into assembly code.
> - **Decompilation**: Transforming machine code back into high-level code.
> - **Static Analysis**: Examining the code without executing it to understand its structure and behavior.
> - **Dynamic Analysis**: Running the code and observing its behavior during execution to understand its functionality.
> 
> Reverse engineering is crucial for understanding undocumented software, integrating systems, and assessing security, but it also has legal and ethical implications.

> [!example] Example: Hello World in Assembly
>
> Consider a simple "Hello World" program in C and its equivalent in assembly language. This illustrates the translation from high-level code to low-level instructions:
> 
> **C Code**:
> ```c
> #include <stdio.h>
> int main() {
>     printf("Hello, World!\n");
>     return 0;
> }
> ```
> 
> **Assembly Code**:
> ```assembly
> section .data
>     hello db 'Hello, World!', 0
> 
> section .text
> global _start
> _start:
>     mov edx, 13        ; message length
>     mov ecx, hello     ; message to write
>     mov ebx, 1         ; file descriptor (stdout)
>     mov eax, 4         ; system call number (sys_write)
>     int 0x80           ; call kernel
> 
>     mov eax, 1         ; system call number (sys_exit)
>     int 0x80           ; call kernel
> ```
> 
> **Explanation**:
> 
> | Instruction           | Description |
> |-----------------------|-------------|
> | `mov edx, 13`         | Set the length of the message to 13 bytes |
> | `mov ecx, hello`      | Point to the message string |
> | `mov ebx, 1`          | Set the file descriptor to stdout |
> | `mov eax, 4`          | Set the system call number for write |
> | `int 0x80`            | Invoke the kernel to perform the write |
> | `mov eax, 1`          | Set the system call number for exit |
> | `int 0x80`            | Invoke the kernel to exit the program |

> [!consider] Legal and Ethical Aspects
> 
> Reverse engineering involves several legal and ethical considerations. It can be used for legitimate purposes, such as:
> 
> - **Security analysis**: Finding and fixing vulnerabilities
> - **Interoperability**: Ensuring compatibility between different systems
> - **Research and learning**: Understanding software design and implementation
> 
> However, it can also be used maliciously:
> 
> - **Software piracy**: Creating unauthorized copies of software
> - **Exploiting vulnerabilities**: Finding and using flaws for malicious purposes
> - **Intellectual property theft**: Stealing proprietary algorithms and techniques

> [!idea] x86 Architecture and Assembly Language
> 
> **What is an Architecture?**
> 
> An architecture **specifies how software and hardware interact, determining how instructions are processed and data is managed.**
> 
> **Why x86 for Reverse Engineering?**
> 
> - **Prevalence**: x86 is widely used in many devices and systems, making it a frequent target for reverse engineering.
> - **Documentation**: Extensive documentation and community support make it easier to learn and understand.
> - **Compatibility**: Understanding x86 helps in analyzing and modifying a wide range of software.
> 
> **Special Registers in x86**:
> 
> - **EIP (Extended Instruction Pointer)**: Points to the current instruction being executed. Crucial for tracing program execution.
> - **ESP (Extended Stack Pointer)**: Points to the top of the stack. Important for managing function calls and local variables.
> - **EBP (Extended Base Pointer)**: Used to reference function parameters and local variables in the stack frame.
> 
> These registers are essential for managing the execution flow and stack operations, allowing precise control and manipulation of data and instructions during reverse engineering.
> 
> **Important Instructions**:
> 
> | Instruction              | Description |
> |--------------------------|-------------|
> | `add eax, 0x5`           | Adds 0x5 to the `eax` register. `eax` is a general-purpose register used in arithmetic and data manipulation. |
> | `sub eax, 0x5`           | Subtracts 0x5 from the `eax` register. |
> | `mul eax, edx`           | Multiplies `eax` by `edx`, storing the result in `edx`. |
> | `div eax, edx`           | Divides `eax` by `edx`, storing the quotient in `eax` and the remainder in `edx`. |
> | `cmp eax, 0x10`          | Compares `eax` with 0x10, setting flags based on the result. |
> | `mov eax, edx`           | Moves the contents of `edx` into `eax`. |
> | `mov eax, [edx]`         | Moves the contents of the memory address pointed to by `edx` into `eax`. |
> | `lea eax, [ebx+4*edx]`   | Loads the effective address represented by `ebx + 4*edx` into `eax`. |
> | `call 0x8004bc`          | Calls the function at address `0x8004bc`, storing the return address on the stack. |
> | `ret`                    | Returns from the function, restoring the address from the stack. |
> | `jmp 0x8004bc`           | Unconditionally jumps to address `0x8004bc`. |

> [!example] Example: Assembly Instructions
>
> Consider the instruction `add eax, 0x5`:
> - **Instruction**: `add eax, 0x5`
> - **Operation**: Adds the immediate value 0x5 to the eax register.
> - **Importance**: Modifies the value of eax, which can affect subsequent operations.

> [!consider] Static vs. Dynamic Analysis
> 
> - **Static Analysis**: Involves examining the code without executing it, useful for understanding structure and detecting potential vulnerabilities.
> - **Dynamic Analysis**: Involves executing the code and observing its behavior, useful for understanding runtime behavior and identifying hidden issues.

> [!idea] Tools for Reverse Engineering
> 
> **Ghidra**: A powerful open-source reverse engineering tool developed by the NSA, which supports:
> 
> - **Disassembly**: Converts machine code to assembly language.
> - **Decompilation**: Transforms machine code back into high-level code.
> - **Interactive GUI**: Allows for detailed analysis and manipulation of code.

> [!summary] Summary of Reverse Engineering
> 
> - **Reverse Engineering**: Analyzing software to understand its components and functionality.
> - **Assembly Language**: Low-level programming language used for direct hardware manipulation.
> - **Legal Aspects**: Includes both legitimate and malicious uses.
> - **Static vs. Dynamic Analysis**: Techniques for examining code without and during execution.
> - **Tools**: Ghidra for disassembly, decompilation, and interactive analysis.