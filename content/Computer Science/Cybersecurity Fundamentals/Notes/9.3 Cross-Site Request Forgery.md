> [!idea] Cross-Site Request Forgery (CSRF)
>
> Cross-Site Request Forgery (CSRF) is a type of attack that **exploits the trust a web application has in a user's authenticated session**. When a user is authenticated with a website, the server issues a session token, typically stored in a cookie or as a hidden field in HTML forms. This token is automatically included in subsequent requests from the user's browser, allowing the server to identify and validate the user's session.
>
> In a CSRF attack, the attacker tricks the user's browser into sending a forged request to the vulnerable website, leveraging the user's active session and trusted status. This request could perform actions such as transferring funds, changing account details, or executing unauthorized commands.

> [!example] CSRF Attack Example
>
> Let's illustrate a CSRF attack with an example:
>
> ```
> <!-- CSRF Attack Code -->
> <img src="https://bank.example.com/transfer.php?amount=1000&to=attackerAccount" width="0" height="0" />
> ```
>
> 1. The attacker crafts a malicious webpage or email containing the above code.
> 2. When the victim user, who is currently logged into their bank account, visits the attacker's site or opens the malicious email, the embedded code automatically triggers a request to the bank's website.
> 3. Because the victim is already authenticated with the bank, their browser includes the session token in the request, making it appear legitimate.
> 4. The bank's server processes the request, assuming it came from the user, and transfers $1,000 to the attacker's account.
>
> In this example, the attacker exploited the user's active session to perform an unauthorized action without the user's knowledge or consent.

> [!consider] Distinguishing from Reflected XSS
>
> While CSRF and Reflected Cross-Site Scripting (XSS) attacks both involve exploiting vulnerabilities in web applications, they differ in their objectives and mechanisms.
>
> Reflected XSS aims to inject malicious scripts into a web application's response, typically by sending a crafted URL or form input to the server. These scripts are then executed in the victim's browser, potentially allowing the attacker to steal sensitive data or perform other malicious actions.
>
> In contrast, CSRF attacks do not rely on injecting scripts but rather on exploiting the trust a web application has in an authenticated user's session. The attacker tricks the victim's browser into sending a legitimate but unauthorized request to the web application, leveraging the user's active session.

> [!consider] Preventing CSRF Attacks
>
> Several techniques can be employed to mitigate the risk of CSRF attacks:
>
> 1. **Synchronizer Token Pattern**: Implement a unique, unpredictable token (e.g., a cryptographically secure random value) that is generated by the server and included in each form or request. The server then validates this token for every subsequent request, rejecting those without a valid token or with a token that has already been used.
>
> 2. **Same-Site Cookies**: Enable the `SameSite` attribute for session cookies, instructing the browser to only send cookies for same-site requests. This mitigates the risk of cross-site requests from unauthorized sources.
>
> 3. **Referer Header Validation**: Check the `Referer` HTTP header in incoming requests to ensure they originate from trusted sources and not from external domains.
>
> 4. **CSRF Tokens in URL Parameters**: Include a unique token as a URL parameter for sensitive requests, such as `DELETE` or `POST` operations, and validate it on the server-side.
>
> It's important to note that while these techniques can significantly reduce the risk of CSRF attacks, they should be combined with other security best practices, such as input validation, secure coding practices, and regular security audits.

> [!consider] Same-Site Cookies
>
> The `SameSite` attribute for cookies plays a crucial role in mitigating CSRF attacks. This attribute instructs the browser on whether to include cookies in cross-site requests, providing an additional layer of security.
>
> There are three possible values for the `SameSite` attribute:
>
> 1. **`Strict`**: Cookies will only be sent for same-site requests, meaning they will not be included in cross-site requests. This provides the highest level of protection against CSRF attacks.
>
> 2. **`Lax`**: Cookies will be included in same-site requests, as well as cross-site top-level navigations, such as when a user follows a link from an external site to your application. This setting provides a balance between security and functionality.
>
> 3. **`None`**: Cookies will be included in all requests, regardless of their origin. This setting effectively disables the `SameSite` protection and should be used with caution.
>
> By setting the `SameSite` attribute to `Strict` or `Lax`, web applications can significantly reduce the risk of CSRF attacks. However, it's important to note that this attribute is not a complete solution and should be combined with other CSRF prevention techniques for comprehensive protection.