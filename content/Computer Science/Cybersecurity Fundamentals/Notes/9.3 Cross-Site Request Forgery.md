> [!motivation] Understanding Cookies and Session Tokens
> 
> Cookies and **session tokens are used to manage user sessions** in web applications. When a user logs in, the server creates a session and sends a unique session token to the client, which is stored as a cookie. On subsequent requests, the **client includes this session token, allowing the server to identify the user** and maintain their authenticated state. However, if an attacker can **obtain these session tokens, they can hijack** user sessions and perform unauthorized actions.

> [!idea] How Cross-Site Request Forgery (CSRF) Works
> 
> Cross-Site Request Forgery (CSRF) is an attack that **exploits the trust a website has in a user's browser**. 
> 
> 1. The victim logs in to the target website, and the server creates a session token that is stored as a cookie in the victim's browser.
> 2. The attacker crafts a malicious link or form that performs an unwanted action on the target website, such as submitting a transaction or changing account settings.
> 3. The attacker tricks the victim into clicking the link or submitting the form, often through social engineering techniques or by embedding the malicious code on a website the victim visits.
> 4. Since the victim is already authenticated on the target website, their browser automatically includes the session token in the request sent by the malicious link or form.
> 5. The target website, trusting the session token, processes the request as if it were a legitimate action performed by the authenticated user.
> 6. The attacker successfully performs the unwanted action on behalf of the victim without their knowledge or consent.
> 
> ![[Pasted image 20240508173744.png|500]]

> [!example] CSRF Attack on a Banking Website
> 
> Imagine a user, Alice, who has an account with a popular online banking website, BankXYZ. The banking website uses session tokens to manage user authentication. Here's how a CSRF attack could be executed:
> 
> 1. Alice logs in to her account on the BankXYZ website, and the server creates a session token that is stored as a cookie in her browser.
> 2. The attacker, Eve, crafts a malicious HTML form that performs a fund transfer from Alice's account to Eve's account. The form sends a POST request to the transfer endpoint of Alice's bank, telling it to transfer funds to the attacker.
>    ```html
>    <\form action="https://bankxyz.com/transfer" method="POST">
>      <input type="hidden" name="amount" value="1000">
>      <input type="hidden" name="recipient" value="Eve's Account">
>      <input type="submit" value="Click here for a chance to win!">
>    </form>
>    ```
> 3. Eve sends an email to Alice with a link to a website containing the malicious form, disguising it as a chance to win a prize. Alice, unaware of the hidden form, clicks on the link and unknowingly submits the form.
> 4. Since Alice is already logged in to her BankXYZ account, her browser automatically includes the session token in the form submission request.
> 5. The BankXYZ server, trusting the session token, processes the fund transfer request as if it were initiated by Alice herself.
> 6. The attacker successfully transfers funds from Alice's account to their own account without Alice's knowledge or consent.
> 


> [!consider] CSRF vs. Cross-Site Scripting (XSS)
> 
> While CSRF and Cross-Site Scripting (XSS) are both types of attacks that target web applications, they have some key differences:
> 
> - XSS attacks involve injecting malicious scripts into a website, which are then executed by the victim's browser. 
> - CSRF attacks, on the other hand, trick the victim's browser into performing actions on a website where they are already authenticated.
> - XSS attacks can be used to steal session tokens or perform actions on behalf of the user, while CSRF attacks focus on performing specific actions without stealing the session token itself.


> [!consider] Preventing CSRF Attacks
> 
> To mitigate the risk of CSRF attacks, web developers can implement various countermeasures:
> 
> 1. Anti-CSRF Tokens: Include a unique, random token in each form or request that performs sensitive actions. The server should validate this token to ensure the request originated from a legitimate source.
> 2. Same-Site Cookies: Set the `SameSite` attribute on cookies to `Strict` or `Lax`, which restricts the browser from sending cookies with cross-site requests, reducing the risk of CSRF attacks.
> 3. Referer Header Validation: Check the `Referer` header on sensitive requests to ensure they originated from the same domain, rejecting requests from unknown or external sources.
> 4. Multi-Factor Authentication (MFA): Implement additional authentication factors, such as one-time passwords (OTPs) or hardware tokens, to provide an extra layer of security beyond session tokens.

> [!idea] Understanding Same-Site Cookies
> 
> The `SameSite` attribute on cookies allows web developers to control whether cookies should be sent with cross-site requests. It helps mitigate CSRF attacks by restricting the scope of cookies. The `SameSite` attribute can have three values:
> 
> 1. `Strict`: Cookies are only sent for same-site requests, i.e., requests originating from the same domain. This provides the strongest protection against CSRF attacks.
> 2. `Lax`: Cookies are sent for same-site requests and for top-level navigation requests initiated by the user, such as clicking a link. This provides a balance between security and usability.
> 3. `None`: Cookies are sent for both same-site and cross-site requests. This value should be used carefully and requires the cookie to be marked as `Secure`, ensuring it is only sent over HTTPS.
> 
> By setting the `SameSite` attribute appropriately, web developers can enhance the security of user sessions and reduce the risk of CSRF attacks.