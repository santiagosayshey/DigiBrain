> [!motivation] Understanding Cookies and Session Tokens
> 
> Cookies and **session tokens are used to manage user sessions** in web applications. When a user logs in, the server creates a session and sends a unique session token to the client, which is stored as a cookie. On subsequent requests, the **client includes this session token, allowing the server to identify the user** and maintain their authenticated state. However, if an attacker can **obtain these session tokens, they can hijack** user sessions and perform unauthorized actions.

> [!idea] How Cross-Site Request Forgery (CSRF) Works
> 
> Cross-Site Request Forgery (CSRF) is an attack that exploits the trust a website has in a user's browser. Here's an example of how a CSRF attack can be carried out:
> 
> 1. The attacker crafts a malicious link or form that performs an unwanted action on the target website, such as submitting a transaction or changing account settings.
> 2. The attacker tricks the victim into clicking the link or submitting the form, often through social engineering techniques or by embedding the malicious code on a website the victim visits.
> 3. If the victim is authenticated on the target website, their browser automatically includes the session token in the request sent by the malicious link or form.
> 4. The target website, trusting the session token, processes the request as if it were a legitimate action performed by the authenticated user.
> 5. The attacker successfully performs the unwanted action on behalf of the victim without their knowledge or consent.
> 
> ```
> [Image: Diagram illustrating the CSRF attack process, showing the attacker, victim, and target website, with arrows indicating the flow of requests and the inclusion of the session token.]
> ```

> [!consider] CSRF vs. Cross-Site Scripting (XSS)
> 
> While CSRF and Cross-Site Scripting (XSS) are both types of attacks that target web applications, they have some key differences:
> 
> - XSS attacks involve injecting malicious scripts into a website, which are then executed by the victim's browser. CSRF attacks, on the other hand, trick the victim's browser into performing actions on a website where they are already authenticated.
> - XSS attacks can be used to steal session tokens or perform actions on behalf of the user, while CSRF attacks focus on performing specific actions without stealing the session token itself.
> - Reflected XSS attacks require the victim to visit a malicious link, similar to CSRF. However, stored XSS attacks persist the malicious script on the website itself, affecting multiple users.

> [!consider] Preventing CSRF Attacks
> 
> To mitigate the risk of CSRF attacks, web developers can implement various countermeasures:
> 
> 1. Anti-CSRF Tokens: Include a unique, random token in each form or request that performs sensitive actions. The server should validate this token to ensure the request originated from a legitimate source.
> 2. Same-Site Cookies: Set the `SameSite` attribute on cookies to `Strict` or `Lax`, which restricts the browser from sending cookies with cross-site requests, reducing the risk of CSRF attacks.
> 3. Referer Header Validation: Check the `Referer` header on sensitive requests to ensure they originated from the same domain, rejecting requests from unknown or external sources.
> 4. Multi-Factor Authentication (MFA): Implement additional authentication factors, such as one-time passwords (OTPs) or hardware tokens, to provide an extra layer of security beyond session tokens.

> [!idea] Understanding Same-Site Cookies
> 
> The `SameSite` attribute on cookies allows web developers to control whether cookies should be sent with cross-site requests. It helps mitigate CSRF attacks by restricting the scope of cookies. The `SameSite` attribute can have three values:
> 
> 1. `Strict`: Cookies are only sent for same-site requests, i.e., requests originating from the same domain. This provides the strongest protection against CSRF attacks.
> 2. `Lax`: Cookies are sent for same-site requests and for top-level navigation requests initiated by the user, such as clicking a link. This provides a balance between security and usability.
> 3. `None`: Cookies are sent for both same-site and cross-site requests. This value should be used carefully and requires the cookie to be marked as `Secure`, ensuring it is only sent over HTTPS.
> 
> By setting the `SameSite` attribute appropriately, web developers can enhance the security of user sessions and reduce the risk of CSRF attacks.