> [!idea]+ Buffer Overflow Vulnerabilities
>
> A buffer overflow is a security vulnerability that **occurs when a program writes more data to a buffer (array) than it can hold**, causing the excess data to overflow into adjacent memory locations.
> 
> ![[Pasted image 20240319142840.png]]
>
> Why buffer overflows are dangerous:
> - The overflowed data **can corrupt important program information** stored in memory
> - Attackers can intentionally overflow buffers to **overwrite control data like return addresses or function pointers**
> - By carefully crafting their input, **attackers can hijack program execution and run arbitrary code**
>
> **Example:** Consider an ATM program in C that prompts users to enter their name:
>
> ```c
> void getName() {
>     char name[20];
>     printf("Enter your name: ");
>     gets(name);
>     // ...
> }
> ```
>
> The `name` buffer can only hold 20 characters, but `gets()` allows writing an arbitrary length string. An attacker could input a very long name:
>
> ```
> AAAAAAAAAAAAAAAAAAAA\x10\x21\x51\x31...
> ```
>
> The `A`s overflow the buffer, and the `\x10\x21\x51\x31` bytes overwrite the return address. When `getName()` returns, execution jumps to the attacker's code instead of the intended location.
> 
> ![[Pasted image 20240319143354.png]]
>
> **Potential outcomes of buffer overflow attacks**:
> - Crashing the program (benign case)
> - Redirecting execution to an existing function (e.g. `dispenseMoney()`)
> - **Injecting and executing custom shellcode** (e.g. spawning a shell, stealing data) 
>
> **Solutions and mitigations**:
> - Use **runtime bounds checking** to validate array indices and sizes (performance overhead) (Implemented in Python, Rust, Java but not C, C++)
> - Employ secure string handling functions that limit input length
> - Enable compiler protections like stack canaries, ASLR, and DEP
> - Most importantly, write secure code that validates untrusted input 
>
> In summary, buffer overflows allow attackers to corrupt memory and hijack program control flow. Careful programming practices are essential to prevent these dangerous vulnerabilities.


> [!exercise]+ Exercise - Exploiting Stack Overflow to Change Program Flow
> 
> **Example Scenario:**
>
> A vulnerable C program has a function `hello()` that uses `gets()` to read user input into a buffer `buf` of size 17 bytes. The program is not supposed to reach the `win()` function, which prints "You win!". The goal is to exploit the stack overflow vulnerability to overwrite the return address and redirect program flow to the `win()` function.
>
> **Analyzing the Stack Frame:**
>
> 1. Set a breakpoint just before the `hello()` function ends and run the program with a pattern of 16 "A"s as input.
> 2. Use `info frame` to find the location of the saved return address (saved EIP) on the stack. In this case, it's at `0xffffd32c`.
> 3. Use `x/40x $esp` to examine the stack contents. The series of `0x41414141` represents the 16 "A"s in the `buf` buffer.
> 4. Determine the address of the `win()` function using `print win`. In this example, it's at `0x565561b9`.
>
> **Crafting the Exploit Payload:**
>
> 1. To overwrite the return address and redirect execution to `win()`, the payload needs to:
>    - Fill the `buf` buffer with 16 bytes of data ("A"s).
>    - Pad an additional 12 bytes to reach the saved return address.
>    - Overwrite the saved return address with the address of `win()` (`0x565561b9`).
> 2. The Python payload to generate this exploit string is:
>    ```python
>    print("A"*28 + "\xb9\x61\x55\x56")
>    ```
>    - `"A"*28` fills the buffer and padding (16 + 12 bytes).
>    - `"\xb9\x61\x55\x56"` is the little-endian representation of `0x565561b9` (address of `win()`).
>
> **Why It Works:**
>
> - The `buf` buffer can hold 17 bytes, but `gets()` allows writing beyond the buffer size, overflowing the stack.
> - By carefully crafting the input, we can overwrite the saved return address on the stack with the address of the `win()` function.
> - When the `hello()` function returns, instead of returning to the original caller, it jumps to the `win()` function, printing "You win!".
>
> This example demonstrates how stack overflow vulnerabilities can be exploited to manipulate program flow by overwriting the saved return address on the stack, allowing arbitrary code execution.
