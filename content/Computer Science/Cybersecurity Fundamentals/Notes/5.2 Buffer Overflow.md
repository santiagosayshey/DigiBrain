> [!idea]+ Buffer Overflow Vulnerabilities
>
> A buffer overflow is a security vulnerability that **occurs when a program writes more data to a buffer (array) than it can hold**, causing the excess data to overflow into adjacent memory locations.
> 
> ![[Pasted image 20240319142840.png]]
>
> Why buffer overflows are dangerous:
> - The overflowed data **can corrupt important program information** stored in memory
> - Attackers can intentionally overflow buffers to **overwrite control data like return addresses or function pointers**
> - By carefully crafting their input, **attackers can hijack program execution and run arbitrary code**
>
> **Example:** Consider an ATM program in C that prompts users to enter their name:
>
> ```c
> void getName() {
>     char name[20];
>     printf("Enter your name: ");
>     gets(name);
>     // ...
> }
> ```
>
> The `name` buffer can only hold 20 characters, but `gets()` allows writing an arbitrary length string. An attacker could input a very long name:
>
> ```
> AAAAAAAAAAAAAAAAAAAA\x10\x21\x51\x31...
> ```
>
> The `A`s overflow the buffer, and the `\x10\x21\x51\x31` bytes overwrite the return address. When `getName()` returns, execution jumps to the attacker's code instead of the intended location.
> 
> ![[Pasted image 20240319143354.png]]
>
> **Potential outcomes of buffer overflow attacks**:
> - Crashing the program (benign case)
> - Redirecting execution to an existing function (e.g. `dispenseMoney()`)
> - **Injecting and executing custom shellcode** (e.g. spawning a shell, stealing data) 
>
> **Solutions and mitigations**:
> - Use **runtime bounds checking** to validate array indices and sizes (performance overhead) (Implemented in Python, Rust, Java but not C, C++)
> - Employ secure string handling functions that limit input length
> - Enable compiler protections like stack canaries, ASLR, and DEP
> - Most importantly, write secure code that validates untrusted input 
>
> In summary, buffer overflows allow attackers to corrupt memory and hijack program control flow. Careful programming practices are essential to prevent these dangerous vulnerabilities.

> [!exercise]+ Exercise - Exploiting Buffer Overflows to Hijack Program Flow
> A simple C program incorrectly uses the `gets()` function, making it vulnerable to buffer overflow attacks. The program has a hidden function named `win()` that prints "You win!" but is never called in the program's normal execution flow. The goal is to craft an input that causes the program to execute `win()` instead of returning to `main()` as intended.
>
> **Vulnerable Program Structure:**
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> void win()
> {
>     printf("You win!\n");
> }
> void hello()
> {
>     char buf[17];
>     printf("What is your name? ");
>     gets(buf); // Vulnerable to buffer overflow
>     printf("Hello %s!\n", buf);
> }
> int main(int argc, char **argv)
> {
>     hello();
>     return 0;
> }
> ```
>
> **Task:**
> 
> 1. Start the program under GDB, setting a breakpoint at the start of `hello()`.
> 2. Use Python to generate an input string that overflows the buffer and overwrites the return address with the address of `win()`. The crafted input should consist of:
>     - Enough characters to fill the buffer and reach the saved return address on the stack.
>     - The exact address of the `win()` function in little-endian format.
> 3. Pass the crafted input to the program via GDB and continue execution to observe the result.
>
> **Example Input Command:**
>
> ```shell
> python2 -c 'print("A"*29 + "\xad\x61\x55\x56")' | ./your_program
> ```
>
> **Expected Outcome:**
> 
> By carefully crafting the input, the program's execution flow is redirected to the `win()` function, printing "You win!" to the screen, instead of executing its intended return path.
>
> **Why It's Effective:**
> 
> - The `gets()` function does not limit the amount of data read, allowing the buffer to overflow.
> - By overwriting the saved return address on the stack, we can redirect the execution to any part of the code, including the `win()` function.
>
> **Security Implications:**
> 
> This exercise demonstrates the critical importance of validating and limiting input sizes to prevent buffer overflows, a common vulnerability that can lead to unauthorized code execution and system compromise.
>
> **Mitigation Strategies:**
>
> - Avoid using unsafe functions like `gets()`.
> - Use functions that limit input size, such as `fgets()`.
> - Employ compiler protections, such as stack canaries and Address Space Layout Randomization (ASLR), to mitigate exploitability.

