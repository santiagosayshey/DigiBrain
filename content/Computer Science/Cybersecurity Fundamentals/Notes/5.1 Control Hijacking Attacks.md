
> [!idea]+ Hijacking Attacks
> Hijacking attacks **attempt to take over the target machine, often by exploiting vulnerabilities** to execute arbitrary code and disrupt the normal application control flow.
>
> Examples of memory-based hijacking attacks include:
> - Buffer overflow and integer overflow attacks
> - Format string vulnerabilities 
> - Use-after-free vulnerabilities
>
> Some notable examples of hijacking attacks from history:
> - The Morris Worm (1988) exploited a buffer overflow vulnerability to spread itself
> - The Code Red worm (2001) exploited a buffer overflow in Microsoft's IIS Server, causing billions in damages
> - Heartbleed (2014) was a vulnerability in OpenSSL that allowed reading private memory contents
> - The Glibc "GHOST" vulnerability (2015) was a heap-based buffer overflow in the GNU C library
>  
> Here's an example of an integer overflow vulnerability:
>
> ```c
> #include <stdio.h>
> int main() {
>     char command;
>     unsigned char c = 5;
>     while (1) {
>         printf("The current value is %d\n", c);
>         printf("Up(u) or down(d)?\n");
>         command = getchar();
>         if (command == 'u')
>             c = c + 1;
>         else if (command == 'd') 
>             c = c - 1;
>     }
>     return 0;
> }
> ```
>
> This code is vulnerable to an integer overflow attack. Incrementing the unsigned char `c` past its maximum value of 255 will cause it to wrap around to 0.


> [!consider]
> To understand and develop control hijacking exploits, you need to:
> - Concretely understand the computer architecture, including the stack and heap memory layouts. Note that details vary slightly between CPUs and operating systems in terms of stack frame structure, little endian vs. big endian byte ordering, etc.
> - Know how the system makes function calls and the role of the `exec()` system call
> - Understand the programming languages (C, etc.) and compilers used to build the target software
> - Be familiar with the different code representations, from high-level source code to bytecode/CIL to low-level machine code that the CPU executes. Ultimately, exploits happen at the machine code level.

The callout focuses on the technical knowledge required, like familiarity with system architecture, programming languages, compilers, and code representations at different abstraction levels. Let me know if you would like me to modify or expand the callout further.