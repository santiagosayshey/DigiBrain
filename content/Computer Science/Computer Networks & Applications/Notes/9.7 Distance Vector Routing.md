> [!idea] Distance Vector Routing
> 
> Distance Vector Routing is a distributed routing algorithm where each node maintains a routing table containing the following information for each destination in the network:
> - The distance (cost) to reach the destination
> - The next hop (neighbor) to reach the destination
> 
> Nodes update their routing tables based on the information received from their directly connected neighbors. The algorithm does not run the Bellman-Ford algorithm at each node to find the cost to every other node. Instead, it uses the Bellman-Ford equation to update the routing tables iteratively:
> 
> $d_x(y) = min_v\{c(x,v) + d_v(y)\}$
> 
> where $d_x(y)$ is the shortest distance from node $x$ to node $y$, $min_v$ is the minimum over all neighbors $v$ of $x$, $c(x,v)$ is the cost of the link between $x$ and $v$, and $d_v(y)$ is the distance from $v$ to $y$ as reported by neighbor $v$.
> 
> Each node performs the following steps:
> 1. Initialize its routing table with the distances to its directly connected neighbors and infinity for all other destinations.
> 2. Send its routing table to all its directly connected neighbors.
> 3. Receive routing tables from its neighbors and update its own routing table using the Bellman-Ford equation.
> 4. If any changes occur in the routing table, send the updated table to its neighbors.
> 
> The next hop recorded in the routing table is not a predecessor but rather the neighbor that offers the shortest path to the destination according to the current information available to the node.

> [!example] Example of Distance Vector Routing
> 
> Consider the following network topology:
> 
> ```
> (A description of the image: A network graph with 4 nodes (A, B, C, D) and 5 edges. The edges have the following costs: A-B: 1, A-C: 3, B-C: 1, B-D: 2, C-D: 1.)
> ```
> 
> Initially, each node only knows the distance to its directly connected neighbors. Through iterations of the Distance Vector Routing algorithm, the nodes exchange their routing tables and update their knowledge of the network.
> 
> After the first iteration, the routing tables will look like this:
> 
> | Node | Destination | Distance | Next Hop |
> |------|-------------|----------|----------|
> | A    | B           | 1        | B        |
> |      | C           | 3        | C        |
> |      | D           | ∞        | -        |
> | B    | A           | 1        | A        |
> |      | C           | 1        | C        |
> |      | D           | 2        | D        |
> | C    | A           | 3        | A        |
> |      | B           | 1        | B        |
> |      | D           | 1        | D        |
> | D    | A           | ∞        | -        |
> |      | B           | 2        | B        |
> |      | C           | 1        | C        |
> 
> After subsequent iterations, the nodes will have a complete view of the network and the shortest paths to all other nodes.

> [!consider] Considerations and Limitations
> 
> - Distance Vector Routing can suffer from the "count-to-infinity" problem, where it may take a long time to converge to the correct routing tables after a network topology change. This issue can be mitigated using techniques like split horizon, route poisoning, and holddown timers.
> 
> - The algorithm has a lower computational complexity compared to Link-State Routing but may have slower convergence times.
> 
> - Distance Vector Routing is used in protocols like RIP (Routing Information Protocol) and EIGRP (Enhanced Interior Gateway Routing Protocol).
> 
> - The algorithm assumes that the cost of a path is the sum of the costs of the individual links along the path, which may not always be the case in real-world networks with different quality of service (QoS) requirements.