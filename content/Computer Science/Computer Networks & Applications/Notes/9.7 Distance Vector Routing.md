> [!idea] Distance Vector Routing: A Distributed Approach to Finding Shortest Paths
> 
> Distance Vector Routing (DVR) is a distributed routing algorithm where each node independently determines the shortest path to every other node.
> - Each node maintains a routing table
> - Each entry in the table has a `cost` and a `via`
> - Each node sends its routing table to its neighbours
> - Each node updates its own table based on the tables sent to it by other nodes
> 
> ![[DVR Cycle.png|500]]

> [!example] Illustrating Distance Vector Routing in Action
>
> Let's consider a simple network with five nodes: A, B, C, D and E. Let's figure out the routing table at E!
>
>![[DVR Example.png|500]]
>
> Initially, E only knows the distances to its directly connected neighbours. Then, each neighbouring node shares its routing table with E, and E can update it's routing table using each respective node as an intermediate. Assume that every other routing table has been finalised. We can see that there are many times where the loop routes back through E itself!
>
>| | | Via | Via | Via |
>| ---- | ----- | ------------------------------ | -------------------------------- | ----------------------------- |
>| | $D^E$ | A | B | D |
>| Dest | A | **1 (E -> A)** | 14 (E -> B -> C -> D -> E -> A) | 5 (E -> D -> E -> A) |
>| Dest | B | 7 (E -> A -> E -> D -> C -> B) | 8 (E -> B) | **5** **(E -> D -> C -> B )** |
>| Dest | C | 6 (E -> A -> E -> D -> C) | 9 (E -> B -> C) | **4** **(E -> D -> C)** |
>| Dest | D | 4 (E -> A -> E -> D) | 11 (E -> B -> C -> D) | **2** **(E -> D)** |
>
>From this distance table, we can construct our final routing table!
>
>| Destination | Outgoing Link, Distance |
>| ----------- | ----------------------- |
>| A | A, 1 |
>| B | D, 5 |
>| C | D, 4 |
>| D | D, 2 |


> [!example]+ Exercise 2
> ![[Pasted image 20240513222201.png]]



> [!consider] Count-to-Infinity Problem: Incrementing Routes and Convergence
>
> In Distance Vector Routing, the count-to-infinity problem arises when a link or node fails, and the network infinitely tries to update the links to this node in the other nodes. 
>
> Let's consider a simple network topology: A -- B -- C, where the link between B and C fails. Initially, A's routing table indicates that it can reach C via B with a distance of 2. After the link failure, B updates its distance to C as infinity and sends this update to A. 
> 
> ![[Pasted image 20240513231348.png]]
> 
> However, A still believes it can reach C via B, so it increments the distance received from B by 1 and updates its own distance to C as 3. In the next routing update, A sends this distance of 3 to B, and B updates its distance to C as 4 (A's distance plus 1). This process continues, with the distance incrementing by 1 at each update, until it reaches infinity.
> 
> ![[Pasted image 20240513231548.png]]



> [!idea] Poison Reverse: Preventing Routing Loops in DVR
>
> Poison Reverse is a technique used in Distance Vector Routing (DVR) to **prevent routing loops and improve convergence** time. 
> 
> 1. When a node learns a new route from a neighbor, it updates its routing table with the new information and the distance advertised by the neighbor.
> 2. The node then advertises this route to its other neighbors (not the one it learned the route from) with the updated distance (the distance advertised by the neighbor plus the cost of the link between them).
> 3. Poison Reverse **comes into play ONLY when a node detects a link failure** or a significant change in the network topology that affects a previously known route.
> 4. In such cases, the node **marks the affected route as unreachable (with an infinite distance) in its routing table**. This is what we call "poisoning" the route.
> 5. The node then s**ends a routing update** to all its neighbors, including the one it learned the failed route from, with the infinite distance for the affected route.
> 6. This poisoned route update **informs the neighbors that the specific route is no longer available**, and they should not use it to reach the destination.
>7. The neighbors, upon receiving the poisoned route update, will update their own routing tables accordingly and propagate the information to their neighbors.

Hello!

I would like your assistance in writing concise, modular notes on the topic of [Routing] The goal is to create notes that are easy to understand and focused on key ideas rather than verbatim copying from textbooks. 

I would like you to format the note using 'callouts'. A callout is defined as a block of text, where each line starts with >. The first line contains the type of callout and the title of the callout. 

> [!callout type] title

Each line after that contains the content of the callout.

Below I have attached each type of callout you may use and a comprehensive overview of what they are used for. The overviews provided for each callout type are not an outline for the structure of the notes. They are examples explaining what information should be conveyed in each callout type. Do not include the overviews themselves in the notes.

It is vital that these notes are objective. They do NOT make judgements about the correctness or lack of about the ideas they talk about. Here are some examples of what I DONT WANT:

```
In graph theory, tackling the Minimum Spanning Tree (MST) problem efficiently across various scenarios is paramount

This example adds nothing of value and introduces bias. 
```

I DO NOT want an overview or plan first. I want the final deliverable note, formatted as proper callouts as outlined above and below. 

> [!motivation] Motivation
> 
> **Purpose**: Introduce the problem that motivates the need for the main idea. This callout sets the stage, making the upcoming discussion relevant and urgent.
> 
> **Key Elements**:
> - **Contextual Introduction**: Start with a real-world scenario or problem that illustrates the need for a solution.
> - **Problem Framing**: Clearly outline the properties or issues that the main idea addresses. Avoid mentioning the solution; focus solely on setting up the problem. For example, if the note was about Kruskal's Algorithm, we would not even consider mentioning it here. It is a solution to this problem.
> 
> **Example**:
> - In project management and network planning, there's often a need to minimize resource usage while achieving maximum efficiency. Imagine trying to connect multiple offices with the least amount of cabling. 
> 
This sets the stage for understanding how we can optimize connections in a network, paving the way for a solution that ensures all nodes are connected with minimal costs.

> [!idea] Main Idea or Concept
> 
> **Purpose**: Explain the core concept or idea that addresses the problem introduced in the motivation callout.
> 
> **Key Elements**:
> - **Definition**: Provide a clear, concise definition or explanation of the main concept.
> - **Mechanics**: Describe how the concept works in theoretical or abstract terms.
> - **Relevance**: Tie back to the motivation by explaining how this idea effectively solves the problem.
> 
> **Example**:
> - Kruskalâ€™s Algorithm offers a solution to the minimum spanning tree problem in graph theory. It processes edges of a graph in ascending order of their weights and adds them to the spanning tree, ensuring no cycles are formed, until all vertices are connected. This method efficiently addresses the need for minimal connection costs in networks.

> [!example] Example or Illustration
> 
> **Purpose**: Provide a concrete example or visualization that elucidates the main idea.
> 
> **Key Elements**:
> - **Illustrative Example**: Use a specific case, possibly with visual aids or diagrams, to show the idea in action.
> - **Step-by-Step Analysis**: Break down how the example fits or demonstrates the main idea.
> - **Relevance**: Highlight the practical impact or benefits observed in the example.
> 
> **Example**:
> - Consider a network of five nodes where the goal is to connect all nodes with the least total weight. Using Kruskal's Algorithm, we start by selecting the smallest edge, ensuring no cycles are created, and continue until all nodes are interconnected. This process results in a spanning tree with minimized connection costs.

> [!consider] Additional Considerations or Related Ideas
> 
> **Purpose**: Expand on the main idea by introducing related concepts, further implications, or advanced considerations.
> 
> **Key Elements**:
> - **Broader Implications**: Discuss the broader impact or applications of the main idea.
> - **Related Concepts**: Introduce and explain additional theories or ideas that complement or contrast with the main idea.
> - **Complex Considerations**: Address any complexities or nuances that add depth to the understanding of the main idea.
> 
> **Example**:
> - While implementing Kruskal's Algorithm, consider the union-find data structure for efficient cycle detection. Additionally, explore how variations of the algorithm might behave in directed graphs or with negative weights. These considerations are crucial for adapting the algorithm to more complex or specialized scenarios.

This structure ensures that each callout is detailed and purposeful, enhancing the clarity and depth of your notes.
You may also include the following elements in the callouts:

- Tables: Please ensure that tables follow markdown formatting rules.
- Images: Indicate where the image should be placed and provide a description so that I can find or create a suitable image (e.g., drawing a graph to illustrate Dijkstra's algorithm in Figma). This is very important. Whenever you want to include an image, You NEED to describe it. Perhaps write the explanation in a codeblock so that I know it can be deleted later. 
- Math: When including mathematical equations, please use Obsidian's formatting rules - `$ $` for inline equations and `$$ $$` for equation blocks.

I have provided additional context on the desired notes below. Please use this information as a guide for what you should write:

I have already completed notes on Distance Vector and Link state router. I just need you to write a consider callout that includes a comparison table for btoh of them. You should compare, message complexity (what do nodes need to know about other nodes), speed of convergence (complexity, loops, count to infinity, etc), and robustness (any issues)

Thanks!