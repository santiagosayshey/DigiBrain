

> [!idea] Distance Vector Routing
> 
> In Distance Vector Routing, each node maintains a routing table with entries for every destination in the network. The table contains:
> 
> 1. The destination node
> 2. The distance (cost) to reach the destination
> 3. The next hop (neighboring node) to reach the destination
> 
> The distance (cost) is initialized based on the node's direct links:
> - If the destination is a directly connected neighbor, the cost is the outgoing cost of the link to that neighbor
> - If the destination is not a direct neighbor, the cost is set to infinity (or a very large number)
> 
> Nodes exchange their entire routing tables with their directly connected neighbors periodically (e.g., every 30 seconds). When a node receives a routing table from a neighbor, it updates its own table:
> 
> For each destination in the received table:
> 1. Add the cost to reach the neighbor to the cost advertised by the neighbor for that destination
> 2. Compare the new total cost with the existing cost in the node's own routing table
> 3. If the new total cost is lower, update the node's routing table with the new cost and set the next hop to the neighbor that provided the update
> 
> By iteratively exchanging and updating routing tables, each node gradually learns the best paths to all destinations based on the information provided by its neighbors. The algorithm converges when no more updates are made to the routing tables.

> [!example] Example of Distance Vector Routing
> 
> Consider the following network topology:
> 
> ```
> (A description of the image: A network graph with 4 nodes (A, B, C, D) and 5 edges. The edges have the following costs: A-B: 1, A-C: 3, B-C: 1, B-D: 2, C-D: 1.)
> ```
> 
> Initially, each node only knows the distance to its directly connected neighbors. Through iterations of the Distance Vector Routing algorithm, the nodes exchange their routing tables and update their knowledge of the network.
> 
> After the first iteration, the routing tables will look like this:
> 
> | Node | Destination | Distance | Next Hop |
> |------|-------------|----------|----------|
> | A    | B           | 1        | B        |
> |      | C           | 3        | C        |
> |      | D           | ∞        | -        |
> | B    | A           | 1        | A        |
> |      | C           | 1        | C        |
> |      | D           | 2        | D        |
> | C    | A           | 3        | A        |
> |      | B           | 1        | B        |
> |      | D           | 1        | D        |
> | D    | A           | ∞        | -        |
> |      | B           | 2        | B        |
> |      | C           | 1        | C        |
> 
> After subsequent iterations, the nodes will have a complete view of the network and the shortest paths to all other nodes.

> [!consider] Considerations and Limitations
> 
> - Distance Vector Routing can suffer from the "count-to-infinity" problem, where it may take a long time to converge to the correct routing tables after a network topology change. This issue can be mitigated using techniques like split horizon, route poisoning, and holddown timers.
> 
> - The algorithm has a lower computational complexity compared to Link-State Routing but may have slower convergence times.
> 
> - Distance Vector Routing is used in protocols like RIP (Routing Information Protocol) and EIGRP (Enhanced Interior Gateway Routing Protocol).
> 
> - The algorithm assumes that the cost of a path is the sum of the costs of the individual links along the path, which may not always be the case in real-world networks with different quality of service (QoS) requirements.