> [!motivation] The Need for Error Detection and Correction
> Errors can occur during data transmission or storage, **corrupting the data and leading to incorrect interpretations or system failures**. Error detection and correction techniques are essential to maintain data accuracy and reliability.

> [!idea] Error Detection and Correction (EDC)
> EDC ensures data integrity by adding redundant bits (EDC bits) to the original data. The two main types of EDC are:
>
> 1. **Error Detection**: Detects errors using parity checking. A parity bit is added to make the total number of 1s even (even parity) or odd (odd parity). If the received parity doesn't match, an error is detected.
>
> 2. **Error Correction**: Detects and corrects errors using error correction codes (ECC) like Hamming codes, Reed-Solomon codes, and CRC codes. ECC adds redundancy to identify and correct errors.
> 
> ![[EDC Diagram.png|500]]


> [!example] Example 1: 1's Complement Error Detection
> 1. **Original Data**: Consider an 8-bit binary number `10110011`.
> 2. **1's Complement**: Flip all the bits to get the 1's complement: `01001100`.
> 3. **Transmission**: Transmit both the original data and its 1's complement.
> 4. **Error Detection**: Upon reception, add the original data and its 1's complement:
> 
>    ```
>      10110011
>    + 01001100
>    -----------
>      11111111
>    ```
> 5. **Verification**: If the result is `11111111`, no error is detected. Any deviation indicates an error.

> [!example] Example 2: 2's Complement Error Detection
> 1. **Original Data**: Consider an 8-bit binary number `10110011`.
> 2. **1's Complement**: Flip all the bits to get the 1's complement: `01001100`.
> 3. **2's Complement**: Add 1 to the 1's complement: `01001100 + 1 = 01001101`.
> 4. **Transmission**: Transmit both the original data and its 2's complement.
> 5. **Error Detection**: Upon reception, add the original data and its 2's complement:
> 
>    ```
>      10110011
>    + 01001101
>    -----------
>      00000000 (with overflow)
>    ```
> 6. **Verification**: If the result is `00000000` (with overflow), no error is detected. Any deviation indicates an error.


> [!example] Example: Internet Checksum in Two's Complement
> 
> 1. **Packet in Hexadecimal**: Consider a packet represented in hexadecimal: `AB00 FFDE 03A3 9CF2`.
> 
> 2. **Checksum Field**: The checksum field is initially `0000` (not included in the calculation).
> 
> 3. **Form 16-bit Words**: Split the packet into 16-bit words:
> 
> ```
> AB00
> FFDE
> 03A3
> 9CF2
> ```
> 
> 4. **Two's Complement Sum**:
> 
>    - Convert each hex value to binary:
> 
> ```
> 1010101100000000
> 1111111111011110
> 0000001110100011
> 1001110011110010
> ```
> 
>    - Add these binary values, storing the sum in a 32-bit word:
> 
> ```
> 1010101100000000
> + 1111111111011110
> ---------------------
> 11010101011011110 (overflow, carry added to sum)
> + 0000001110100011
> ---------------------
> 1010101010000001
> + 1001110011110010
> ---------------------
> 0100011101110011
> 
> Sum in hexadecimal: 0002 4B73
> ```
> 
> 5. **One's Complement**:
> 
>    - Add the carry (`0002`) to the sum (`4B73`) and take the one's complement:
> 
> ```
> 0002 + 4B73 = 4B75
> 
> One's complement of 4B75: B48A
> 
> Checksum in hexadecimal: B48A
> ```
> 
> 6. **Checksum**:
> 
>    - The calculated checksum value `B48A` is then inserted into the checksum field of the packet.
> 
> The final packet with the calculated checksum:
> 
> `AB00 FFDE 03A3 9CF2 B48A`
> 
> This ensures that the sum of all 16-bit words, including the checksum, will equal `FFFF`, indicating no errors during transmission.
