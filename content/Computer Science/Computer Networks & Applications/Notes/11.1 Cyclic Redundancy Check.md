
> [!motivation] Need for Effective Error Detection in Data Transmission
>
> As data is transmitted over computer networks, errors can occur due to various factors such as noise or interference. While simple parity bits and checksums can detect isolated bit errors, **they struggle to effectively handle burst errors, where multiple consecutive bits are corrupted**. This limitation **motivates the need for more robust error detection techniques like the Cyclic Redundancy Check (CRC)** to ensure reliable data transmission.

> [!idea] Cyclic Redundancy Check (CRC)
> 
> The Cyclic Redundancy Check (CRC) is a powerful error detection technique used in data communications and storage systems. It is based on **representing binary data as polynomials and performing arithmetic operations on these polynomials over a specific finite field** or Galois Field (GF).
> 
> The CRC calculation involves the following key steps:
> 
> 1. Represent the binary data as a polynomial, treating each bit as a coefficient.
> 2. Append zeros to the right of the binary data, where the number of zeros equals the degree of a predefined generator polynomial.
> 3. Divide the extended data polynomial by the generator polynomial using polynomial long division.
> 4. The remainder obtained from the division is the CRC checksum.
> 5. Append the CRC checksum to the original data for transmission.
> 


I apologize for not following your instructions clearly. Let's proceed with Step 4 of the CRC calculation example.

I apologize for the confusion and frustration I have caused. Please see the corrected solution below, with the image left exactly as you provided it.

> [!example] CRC Calculation Example
>
> Consider the binary data `10011010` and the generator polynomial $1101 = x^3 + x^2 + 1$
>
> Step 1: Represent the binary data as a polynomial.
> $10011010 = x^7 + x^4 + x^3 + x^1$
>
> Step 2: Append zeros to the right of the binary data, where the number of zeros equals the degree of the generator polynomial (3).
> $10011010000 = x^{10} + x^7 + x^6 + x^4$
>
> Step 3: Divide the extended data polynomial by the generator polynomial using polynomial long division (modulo 2, without carry).
>
![[Pasted image 20240520172729.jpg|500]]
>
> Step 4: The remainder obtained from the division is the CRC checksum.
> CRC checksum: $x^2 + 1 = 101$ (binary)
>
> Step 5: Append the CRC checksum to the original data for transmission.
> Transmitted data: `10011010` + `101` = `10011010<mark>101</mark>`





> [!consider] CRC Calculation Process
> 
> The CRC calculation involves dividing the data polynomial by a predefined generator polynomial and appending the remainder (known as the CRC checksum) to the original data. The generator polynomial is carefully chosen to maximize error detection capabilities. Key steps in the CRC calculation process include:
> 
> 1. Appending zeros to the data polynomial based on the degree of the generator polynomial.
> 2. Dividing the extended data polynomial by the generator polynomial using polynomial long division.
> 3. The remainder obtained from the division is the CRC checksum.
> 4. The CRC checksum is appended to the original data for transmission.

> [!consider] CRC Calculation Process
> 
> The CRC calculation involves dividing the data polynomial by a predefined generator polynomial and appending the remainder (known as the CRC checksum) to the original data. The generator polynomial is carefully chosen to maximize error detection capabilities. Key steps in the CRC calculation process include:
> 
> 1. Appending zeros to the data polynomial based on the degree of the generator polynomial.
> 2. Dividing the extended data polynomial by the generator polynomial using polynomial long division.
> 3. The remainder obtained from the division is the CRC checksum.
> 4. The CRC checksum is appended to the original data for transmission.



> [!consider] Error Detection Capabilities and Limitations
> 
> CRC provides strong error detection capabilities, especially for burst errors. The choice of the generator polynomial greatly influences the types of errors that can be detected. Some key considerations include:
> 
> - CRC can detect all single-bit and double-bit errors.
> - CRC can detect all odd number of bit errors.
> - The error detection capability for burst errors depends on the degree of the generator polynomial. A CRC-n can detect any burst error up to n bits long.
> 
> However, CRC has limitations. It cannot detect errors that are exact multiples of the generator polynomial. Additionally, CRC alone cannot correct errors; it only detects them. Error correction requires additional techniques like forward error correction (FEC).

> [!consider] Commonly Used CRC Variants
> 
> Several CRC variants are widely used in different applications and protocols. Some common examples include:
> 
> - CRC-16: Used in USB, HDLC, and XMODEM protocols.
> - CRC-32: Used in Ethernet, PKZIP, and IEEE 802 standards.
> - CRC-CCITT: Used in X.25, V.41, and Bluetooth protocols.
> 
> The choice of CRC variant depends on the specific requirements of the application, such as the desired error detection strength, data size, and computational efficiency.


> [!example] Impact of Modular 2 and Without Carry on Division
>
> Let's take a closer look at how the rules of "modular 2" and "without carry" affect the polynomial division in the CRC calculation. We'll use the same example as before:
>
> - Binary data: `10011010`
> - Generator polynomial: $1101 = x^3 + x^2 + 1$
>
> The extended data polynomial is: $x^{10} + x^7 + x^6 + x^4$
>
> When we perform the polynomial division, we start by aligning the divisor (generator polynomial) with the leftmost term of the dividend (extended data polynomial). Here's how the division progresses:
>
> $\begin{array}{r}
>    x^7 + x^5 + x^4 + x^2 \\
> 1101 \enclose{longdiv}{x^{10} + x^7 + x^6 + x^4} \\
>    x^{10} + x^9 + x^7 \\
> \hline
>    <mark>x^9 + x^6 + x^4</mark> \\
>    x^9 + x^8 + x^6 \\
> \hline
>    <mark>x^8 + x^4</mark> \\
>    x^8 + x^7 + x^5 \\
> \hline
>    <mark>x^7 + x^5 + x^4</mark> \\
>    x^7 + x^6 + x^4 \\
> \hline
>    <mark>x^6 + x^5</mark> \\
>    x^6 + x^5 + x^3 \\
> \hline
>    x^3 \\
> \end{array}$
>
> The highlighted terms in each step show the result of the XOR operation between the corresponding coefficients of the dividend and the divisor. Due to the "modular 2" and "without carry" rules, the XOR operation is equivalent to addition and subtraction in GF(2):
>
> - Step 1: $(x^9 + x^6 + x^4) \oplus (x^9 + x^8 + x^6) = x^8 + x^4$
> - Step 2: $(x^8 + x^4) \oplus (x^8 + x^7 + x^5) = x^7 + x^5 + x^4$
> - Step 3: $(x^7 + x^5 + x^4) \oplus (x^7 + x^6 + x^4) = x^6 + x^5$
> - Step 4: $(x^6 + x^5) \oplus (x^6 + x^5 + x^3) = x^3$
>
> As you can see, the division process is simplified because there is no need to consider carries or borrows between columns. Each operation is confined to the current column, and the coefficients remain in GF(2).
>
> The final remainder ($x^3$) is the CRC checksum, which is then appended to the original data for transmission.


> [!info] Modular 2 and Without Carry - Simple Explanation
> 
> In simple terms, "modular 2" and "without carry" mean that when we perform the polynomial division in the CRC calculation:
> 
> 1. We only use 0s and 1s (modular 2).
> 2. We do not carry over any values from one column to the next (without carry).
> 
> This simplifies the division process because:
> 
> - Addition and subtraction become the same operation (XOR).
> - We only need to consider the values in each column independently.
> 
> Here's a simple example:
> 
> $\begin{array}{r}
>   1011 \\
> 1101 \enclose{longdiv}{11010} \\
>   1101 \\
> \hline
>   0111 \\
> \end{array}$
> 
> In this division, we simply XOR the corresponding bits in each column:
> 
> - 1 XOR 1 = 0
> - 1 XOR 1 = 0
> - 0 XOR 0 = 0
> - 1 XOR 1 = 0
> 
> The remainder (0111) is the CRC checksum.



