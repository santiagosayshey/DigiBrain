> [!idea] The Need for Pipelining in Reliable Data Transfer Protocols
>
> In high-speed networks with significant propagation delays and small packet sizes, **stop-and-wait protocols can severely limit bandwidth utilization**. For example, with a 1 Gbps link, 15 ms end-to-end propagation delay, and 1 KB packet size, the sender utilization is only 0.027%, resulting in a throughput of just 33 KB/sec.
>
> **Pipelining addresses this issue** by allowing multiple data packets to be in transit simultaneously, without waiting for individual ACKs. By using sequence numbers, timers, and efficient retransmission mechanisms, pipelining enables the sender to fully utilize the available bandwidth and significantly improve throughput.
>
> Pipelining has the following consequences for reliable data transfer protocols:
> - Increased range of sequence numbers to accommodate multiple in-transit packets
> - Buffering requirements for both sender and receiver
> - Dependence on the protocol's approach to handling lost, corrupted, or delayed packets (e.g., Go-Back-N or selective repeat)
>
> The **delay-bandwidth product** determines the optimal size of the window buffer. It is calculated as the product of the round-trip delay and the available bandwidth:
>
> ```
> delay-bandwidth product = round-trip delay Ã— bandwidth
> ```
>
> The window buffer is a region of memory allocated for temporary storage of data packets. Its size should be equal to the delay-bandwidth product to ensure that the sender can fully utilize the available bandwidth while waiting for acknowledgments. If the window buffer is too small, the sender will be unable to keep the pipeline full, leading to underutilization of the link. Conversely, if the window buffer is too large, it may lead to excessive memory usage and potential issues with flow control.
>
> [[Pipelining]] is crucial in advanced RDT protocols to overcome the limitations of stop-and-wait approaches and ensure efficient data transfer in high-speed networks with substantial propagation delays. By properly sizing the window buffer according to the delay-bandwidth product, reliable data transfer protocols can optimize throughput and efficiently utilize network resources.

> [!info] Understanding the Need for a Window in Reliable Data Transfer
>
> Imagine you're sending a series of letters to a friend who lives far away. You want to ensure that your friend receives all the letters in the correct order, without any missing or duplicate letters.
>
> In a stop-and-wait approach, you would send one letter at a time and wait for your friend to acknowledge receipt before sending the next letter. This process is slow and inefficient, especially if the distance between you and your friend is large, as you spend most of your time waiting for acknowledgments.
>
> Now, consider a pipelined approach with a window. Instead of sending one letter at a time, you can send multiple letters simultaneously, up to a certain limit (the window size). You keep track of which letters have been sent and which ones have been acknowledged. As your friend acknowledges the receipt of letters, you can send more letters to keep the pipeline full, ensuring that you're always sending letters at the maximum rate possible.
>
> The window acts as a buffer, allowing you to store letters that have been sent but not yet acknowledged. The size of the window determines how many letters you can send at once without waiting for acknowledgments. If the window is too small, you won't be able to keep the pipeline full, and you'll underutilize your sending capacity. If the window is too large, you risk sending too many letters and overwhelming your friend's ability to process and acknowledge them.
>
> In reliable data transfer protocols, the window plays a similar role. It allows the sender to transmit multiple data packets simultaneously, keeping the network pipeline full and maximizing throughput. The window size is determined by the delay-bandwidth product, which ensures that the sender can fully utilize the available bandwidth while waiting for acknowledgments. The window buffer stores the packets that have been sent but not yet acknowledged, enabling the sender to retransmit them if necessary and maintain the correct order of packet delivery.
>
> By using a window in reliable data transfer protocols, we can overcome the limitations of stop-and-wait approaches and achieve efficient, high-speed data transfer in networks with significant propagation delays.


> [!idea] Go-Back-N (GBN)
> 
> Go-Back-N is a pipelining protocol where the sender can transmit multiple packets (up to a window size) without waiting for an acknowledgment, but the receiver only sends cumulative acknowledgments.
>
> Example:
> - Sender's window size: 4
> - Sent packets: 1, 2, 3, 4
> - Received ACKs: 1, 2
> - Packet 3 is lost
> - Receiver discards packet 4 and sends ACK 2
> - Sender retransmits packets 3 and 4 upon receiving ACK 2
>
> Key points:
> - Sender maintains a window of size N
> - Receiver sends cumulative ACKs for in-order packets
> - Lost or corrupted packets cause the receiver to discard subsequent packets
> - Sender retransmits all packets starting from the lost one
>   
>![[Go Back N demonstration.mp4]]

> [!idea] Selective Repeat (SR)
>
> Selective Repeat is a pipelining protocol that allows the sender to transmit multiple packets (up to a window size) without waiting for an acknowledgment, and the receiver individually acknowledges each correctly received packet, even if it is out of order.
>
> Example:
> - Sender's window size: 4
> - Sent packets: 1, 2, 3, 4
> - Received ACKs: 1, 2, 4
> - Packet 3 is lost
> - Receiver sends NAK 3
> - Sender retransmits only packet 3
>
> Key points:
> - Sender maintains a window of size N
> - Receiver sends individual ACKs for each correctly received packet
> - Lost or corrupted packets cause the receiver to send a NAK for the specific packet
> - Sender retransmits only the lost or corrupted packet
> - Window slides forward upon receiving ACKs, allowing new packets to be sent
>   
>   ![[Selective retransmission demonstration.mp4]]


