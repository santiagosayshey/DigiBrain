

> [!exercise]+ Exercise 1 - IP Subnets
>
> Are the two IP addresses 129.127.8.8 and 129.127.104.8 in the same subnet? Explain your answer.
>
> Are the two IP addresses 129.127.8.8/24 and 129.127.104.8/24 in the same subnet? Explain your answer.
>
> **Answers:**
>
> 1. To determine if these IP addresses belong to the same subnet, we need to consider the class of the addresses. The first octet of both addresses is 129, which falls within the range of 128 to 191, indicating that they are Class B addresses. In Class B addressing, the first two octets (129.127) represent the network portion. Since both addresses share the same network portion, we can conclude that they belong to the **same subnet**.
>
> 2. When given IP addresses with a /24 suffix, it means that the first 24 bits (or the first three octets) of the addresses represent the network portion. To determine if these addresses are part of the same subnet, we need to compare the first three octets. In this case, the third octet differs between the two addresses (8 and 104), which means that the network portions are different. Therefore, the addresses 129.127.8.8/24 and 129.127.104.8/24 belong to **different subnets**.


> [!exercise]+ Exercise 2 - IP Fragmentation
>
> A IPv4 router that has an incoming datagram of 1,600 bytes to send into an outgoing link that has an MTU of 500 bytes. The in-coming datagram is stamped with the identification number 291.
>
> - How many fragments will be generated?
> - What are the values in the various fields in the IP datagram(s) generated by the router?
>
> **Answer:**
>
> 1. Calculate the number of fragments:
>    - IP header size: 20 bytes
>    - Available payload size per fragment: 500 bytes (MTU) - 20 bytes (IP header) = 480 bytes
>    - Number of fragments = (Datagram size - IP header size) / Available payload size per fragment
>    - Number of fragments = (1600 - 20) / 480⌉ = 3.29 = **4 fragments**
>
> 2. Determine the values in the various fields of the generated IP datagrams:
>
>    | Fragment | Identification | Flags (MF) | Fragment Offset | Total Length |
>    |----------|----------------|------------|-----------------|--------------|
>    | 1        | 291            | 1          | 0               | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 2        | 291            | 1          | 60 (480 / 8)    | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 3        | 291            | 1          | 120 (960 / 8)   | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 4        | 291            | 0          | 180 (1440 / 8)  | 180 bytes (160 bytes payload + 20 bytes header) |


> [!exercise]+ Exercise 3 - Forwarding
> Consider an IP network using 32-bit host addresses. Suppose a router has four links, numbered 0 to 3, and packets are to be forwarded to the link interfaces as follows:
>
> | _**Destination Address Range**_                                                                                             | _**Link Interface**_ |
> | --------------------------------------------------------------------------------------------------------------------------- | -------------------- |
> | 11100000 00000000 00000000 00000000     <br><br>                        through<br><br>11100000 00000000 11111111 11111111 | 0                    |
> | 11100000 00000001 00000000 00000000<br><br>                       through<br><br>11100000 00000001 11111111 11111111       | 1                    |
> | 11100000 00000010 00000000 00000000<br><br>                      through<br><br>11100001 11111111 11111111 11111111       | 2                    |
> | Otherwise                                                                                                                   | 3                    |
>
> - Write out a forwarding table, that uses longest prefix matching, and forwards packets to the correct link interfaces.
> - Describe how your forwarding table determines the appropriate link interface for the IP datagrams with destination addresses:
>   - 11111000 10010001 01010001 01010101
>   - 11100000 00000000 11000011 00111100
>   - 11100001 10000000 00010001 01110111
>
>**Answer:**
>
> Forwarding Table:
>
> | **Prefix** | **Link Interface** |
> | ------------ | -------------------- |
> | 11100000 00000000 | 0 |
> | 11100000 00000001 | 1 |
> | 11100000 0000001 | 2 |
> | 11100000 000001 | 2 |
> | 11100000 00001 | 2 |
> | 11100000 0001 | 2 |
> | 11100000 001 | 2 |
> | 11100000 01 | 2 |
> | 11100000 1 | 2 |
> | 11100001 | 2 |
> | * | 3 |
>
> The forwarding table uses longest prefix matching to determine the appropriate link interface for each destination address. The table is sorted by the length of the prefix, with the longest prefixes at the top.
>
> **Determining the link interface for the given IP datagrams:**
>
> 1. 11111000 10010001 01010001 01010101
>    - The longest matching prefix is *, which corresponds to link interface 3.
>
> 2. 11100000 00000000 11000011 00111100
>    - The longest matching prefix is 11100000 00000000, which corresponds to link interface 0.
>
> 3. 11100001 10000000 00010001 01110111
>    - The longest matching prefix is 11100001, which corresponds to link interface 2.


> [!exercise]+ Exercise 4 - Routing Algorithms
> ![[Screenshot 2017-04-26 13.30.40 1.png]]
> 
> Using node E as your base, show how node E builds it's routing table, using Dijkstra's algorithm and then using Distance Vector.

Thank you for the corrections. Let's start fresh with the accurate graph representation:

- **Node A** is connected to:
  - B with a weight of 2
  - C with a weight of 1
  - E with a weight of 8
- **Node B** is connected to:
  - C with a weight of 2
  - D with a weight of 2
- **Node D** is connected to:
  - E with a weight of 3

Given this correct graph, let's now demonstrate how node E builds its routing table using both Dijkstra's algorithm and the Distance Vector routing algorithm.

### Dijkstra's Algorithm from Node E
Dijkstra's algorithm finds the shortest paths from the source node to all other nodes in the graph. Here are the steps from node E:

1. **Initialization**:
   - Distance to E = 0 (since it's the source)
   - Distance to all other nodes = ∞ (unknown at the beginning)

2. **Iterative Updates**:
   - Update distances for direct neighbors of E:
     - E to D = 3 (update since 3 is less than ∞)

3. **Choose next closest node that hasn't been finalized**:
   - D is the closest with a distance of 3.

4. **From D, update its neighbors**:
   - Check B through D:
     - E to B = E to D + D to B = 3 + 2 = 5 (update since 5 is less than ∞)

5. **Next, B is finalized (next closest unfinalized node)**:
   - Check A through B:
     - E to A = E to B + B to A = 5 + 2 = 7 (update since 7 is less than ∞)
   - Check C through B:
     - E to C = E to B + B to C = 5 + 2 = 7 (update since 7 is less than ∞)

### Final Shortest Paths from Node E:
- E to A = 7
- E to B = 5
- E to C = 7
- E to D = 3
- E to E = 0

### Distance Vector Routing
In the Distance Vector routing algorithm, each node shares its table with immediate neighbors, and the neighbors update their tables based on the received information.

1. **Initial Table at E**:
   - Distance to E = 0
   - Distance to D = 3
   - Distance to all others = ∞

2. **Receiving Update from D**:
   - D knows:
     - D to E = 3
     - D to B = 2
   - E updates:
     - E to B = E to D + D to B = 3 + 2 = 5

3. **Receiving Update from B** (when B gets updates from A and C):
   - B knows:
     - B to A = 2
     - B to C = 2
   - E updates:
     - E to A = E to B + B to A = 5 + 2 = 7
     - E to C = E to B + B to C = 5 + 2 = 7

### Final DV Routing Table for Node E:
- E to A = 7
- E to B = 5
- E to C = 7
- E to D = 3
- E to E = 0

Both algorithms arrive at the same results for this network configuration, although the paths and updates propagate differently.