

> [!exercise]+ Exercise 1 - IP Subnets
>
> Are the two IP addresses 129.127.8.8 and 129.127.104.8 in the same subnet? Explain your answer.
>
> Are the two IP addresses 129.127.8.8/24 and 129.127.104.8/24 in the same subnet? Explain your answer.
>
> **Answers:**
>
> 1. To determine if these IP addresses belong to the same subnet, we need to consider the class of the addresses. The first octet of both addresses is 129, which falls within the range of 128 to 191, indicating that they are Class B addresses. In Class B addressing, the first two octets (129.127) represent the network portion. Since both addresses share the same network portion, we can conclude that they belong to the **same subnet**.
>
> 2. When given IP addresses with a /24 suffix, it means that the first 24 bits (or the first three octets) of the addresses represent the network portion. To determine if these addresses are part of the same subnet, we need to compare the first three octets. In this case, the third octet differs between the two addresses (8 and 104), which means that the network portions are different. Therefore, the addresses 129.127.8.8/24 and 129.127.104.8/24 belong to **different subnets**.


> [!exercise]+ Exercise 2 - IP Fragmentation
>
> A IPv4 router that has an incoming datagram of 1,600 bytes to send into an outgoing link that has an MTU of 500 bytes. The in-coming datagram is stamped with the identification number 291.
>
> - How many fragments will be generated?
> - What are the values in the various fields in the IP datagram(s) generated by the router?
>
> **Answer:**
>
> 1. Calculate the number of fragments:
>    - IP header size: 20 bytes
>    - Available payload size per fragment: 500 bytes (MTU) - 20 bytes (IP header) = 480 bytes
>    - Number of fragments = (Datagram size - IP header size) / Available payload size per fragment
>    - Number of fragments = (1600 - 20) / 480⌉ = 3.29 = **4 fragments**
>
> 2. Determine the values in the various fields of the generated IP datagrams:
>
>    | Fragment | Identification | Flags (MF) | Fragment Offset | Total Length |
>    |----------|----------------|------------|-----------------|--------------|
>    | 1        | 291            | 1          | 0               | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 2        | 291            | 1          | 60 (480 / 8)    | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 3        | 291            | 1          | 120 (960 / 8)   | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 4        | 291            | 0          | 180 (1440 / 8)  | 180 bytes (160 bytes payload + 20 bytes header) |


> [!exercise]+ Exercise 3 - Forwarding
> Consider an IP network using 32-bit host addresses. Suppose a router has four links, numbered 0 to 3, and packets are to be forwarded to the link interfaces as follows:
>
> | _**Destination Address Range**_                                                                                             | _**Link Interface**_ |
> | --------------------------------------------------------------------------------------------------------------------------- | -------------------- |
> | 11100000 00000000 00000000 00000000     <br><br>                        through<br><br>11100000 00000000 11111111 11111111 | 0                    |
> | 11100000 00000001 00000000 00000000<br><br>                       through<br><br>11100000 00000001 11111111 11111111       | 1                    |
> | 11100000 00000010 00000000 00000000<br><br>                      through<br><br>11100001 11111111 11111111 11111111       | 2                    |
> | Otherwise                                                                                                                   | 3                    |
>
> - Write out a forwarding table, that uses longest prefix matching, and forwards packets to the correct link interfaces.
> - Describe how your forwarding table determines the appropriate link interface for the IP datagrams with destination addresses:
>   - 11111000 10010001 01010001 01010101
>   - 11100000 00000000 11000011 00111100
>   - 11100001 10000000 00010001 01110111
>
>**Answer:**
>
> Forwarding Table:
>
> | **Prefix** | **Link Interface** |
> | ------------ | -------------------- |
> | 11100000 00000000 | 0 |
> | 11100000 00000001 | 1 |
> | 11100000 0000001 | 2 |
> | 11100000 000001 | 2 |
> | 11100000 00001 | 2 |
> | 11100000 0001 | 2 |
> | 11100000 001 | 2 |
> | 11100000 01 | 2 |
> | 11100000 1 | 2 |
> | 11100001 | 2 |
> | * | 3 |
>
> The forwarding table uses longest prefix matching to determine the appropriate link interface for each destination address. The table is sorted by the length of the prefix, with the longest prefixes at the top.
>
> **Determining the link interface for the given IP datagrams:**
>
> 1. 11111000 10010001 01010001 01010101
>    - The longest matching prefix is *, which corresponds to link interface 3.
>
> 2. 11100000 00000000 11000011 00111100
>    - The longest matching prefix is 11100000 00000000, which corresponds to link interface 0.
>
> 3. 11100001 10000000 00010001 01110111
>    - The longest matching prefix is 11100001, which corresponds to link interface 2.

> [!exercise]+ Exercise 4 - Routing Algorithms
> ![[Screenshot 2017-04-26 13.30.40 1.png]]
> 
> Using node E as your base, show how node E builds it's routing table, using Dijkstra's algorithm and then using Distance Vector.
> 
>---
>
> **Dijkstra's Algorithm**
> Dijkstra's algorithm finds the shortest paths from the source node to all other nodes in the graph.
>
> - **Initialization**: Node E starts with a distance of 0 to itself, and infinity to all other nodes.
> - **Update Neighbors**: The distance to node D is now 3 and node A is 8. 
> - **Choose Closest Node**: Node D, with a distance of 3, is the next node to process.
> - **Update from D**: The path from E to B through D becomes viable with a total distance of 5. This is updated because it's better than infinity.
> - **Continue Process**: B is the next closest node. From B, the paths to A and C are updated to a total distance of 7 each, through B.
>
> The shortest paths from E are now: E to A = 7, E to B = 5, E to C = 7, E to D = 3, and E to E = 0.
>
> **Distance Vector Routing**
> In the Distance Vector algorithm, nodes exchange distance vectors with their neighbors:
>
> - **Initial Vector**: Node E knows its distance to itself (0) and to D (3) and A (8).
> - **Receive from D**: When D shares its vector, E learns it can reach B through D at a distance of 5.
> - **B Updates**: As B receives updates from its neighbors, it eventually knows it can reach A and C each at a distance of 2. E uses this information to conclude that it can reach A and C each through B at a distance of 7.
>
> The final routing table for E using Distance Vector would also show: E to A = 7, E to B = 5, E to C = 7, E to D = 3, and E to E = 0.
>
> Both algorithms use different processes but ultimately determine the same shortest paths from E to all other nodes in this network.


