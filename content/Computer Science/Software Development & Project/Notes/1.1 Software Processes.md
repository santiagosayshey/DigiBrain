> [!idea]+ Software Processes
> A structured set of **activities to produce** or maintain a **software** product. These processes allow us to:
> - Improve efficiency in software development
> - Ensure quality and reliability of software products
> - Manage resources effectively
> - Meet project deadlines and milestones
> - Facilitate communication among team members
> - Standardize development practices
> - Track progress and identify issues early

> [!example] Software Process Model
> An abstract representation of a process used to describe steps and guide software teams throughout development. It acts as a **roadmap**.
>![[Software Testing Flowchart.png]]
Understood. I'll restructure the information into three separate callouts as you've requested.

> [!idea] Waterfall Model
> - Example: Developing software for a heart surgery robot
>   - Requirements fully defined before design begins
>   - Rigorous testing before deployment
>   - Minimal changes after implementation
> - Resembles a waterfall cascading from one stage to the next
> - Key memory aid: 
>   - Lots of work at the top (extensive upfront planning)
>   - Once flowing, it easily progresses downward (because gravity!)
>   - Difficult to go back upstream (challenging to make changes)
>   - Like eating all your vegetables first at dinner:
>     - Challenging at first, but smooth sailing after
> 
> Strengths:
> - Clear structure and milestones
> - Comprehensive documentation
> - Easier to estimate costs and timelines
> - Suits projects with fixed requirements
> 
> Weaknesses:
> - Inflexible to changes
> - Late testing may uncover major issues
> - Customer sees product only at the end
> - Risk of delivering outdated product

> [!idea] Linear Development (Waterfall Model)
> A sequential approach to software development, where **progress flows steadily through distinct phases** without overlap.
> 
> - Example: Developing software for a heart surgery robot
>   - Requirements fully defined before design begins
>   - Rigorous testing before deployment
>   - Minimal changes after implementation
> - Resembles a waterfall cascading from one stage to the next
> - Key memory aid: 
>   - Lots of work at the top (extensive upfront planning)
>   - Once flowing, it easily progresses downward (because gravity!)
>   - Difficult to go back upstream (challenging to make changes)
>   - Like eating all your vegetables first at dinner:
>     - Challenging at first, but smooth sailing after
> 
> Strengths:
> - Clear structure and milestones
> - Comprehensive documentation
> - Easier to estimate costs and timelines
> - Suits projects with fixed requirements
> 
> Weaknesses:
> - Inflexible to changes
> - Late testing may uncover major issues
> - Customer sees product only at the end
> - Risk of delivering outdated product

> [!idea] Cyclical Development (Agile Methodology)
> An iterative approach to software development that emphasizes **flexibility, continuous improvement, and rapid delivery** through repeated cycles.
> 
> - Example: Developing an online multiplayer game
>   - Features added and balanced iteratively
>   - Regular updates based on player feedback
>   - Continuous refinement of gameplay mechanics
> - Named for its ability to move quickly and easily
> - Key memory aid: Think of an agile athlete, able to change direction rapidly
> 
> Strengths:
> - Adaptable to changing requirements
> - Regular delivery of working software
> - Continuous customer involvement
> - Early identification of issues
> 
> Weaknesses:
> - Less predictable end product
> - Can be challenging to estimate costs
> - Risk of scope creep
> - Less comprehensive documentation

> [!consider] Linear vs Cyclical Development Comparison
> | Aspect | Linear (Waterfall) | Cyclical (Agile) |
> |--------|-----------|-------|
> | Requirements | Fully defined upfront | Evolve as development progresses |
> | Testing | Comprehensive testing phase | Continuous testing throughout |
> | Delivery | Single release after full development | Regular updates and patches |
> | Risk Management | Extensive initial assessment | Ongoing evaluation and mitigation |
> | Changes | Difficult and costly to implement | Expected and easily accommodated |
> | User Feedback | Limited, mainly in initial stages | Continuous throughout development |
> 
> Key: (+) Strength, (-) Weakness
