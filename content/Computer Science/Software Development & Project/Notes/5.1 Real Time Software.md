> [!idea] Real-Time Systems (RTS)
> Real-time systems are **continuous systems that monitor and control their environment**. They typically:
> - Run constantly without termination
> - Often involve hardware devices
> - Receive, process, and return data
> - Directly affect their environment
> 
> **Key Characteristic**: The correct functionality of an RTS depends not only on the results produced but also on the time at which those results are produced.
> 
> **Examples**: 
> - Sensors in a smart home system
> - Actuators in industrial robotics
> - Traffic light control systems
> - Aircraft navigation systems
> 
> **Core Elements of RTS**:
> 
> 1. **Sensor Controls**:
>    - Collect information from sensors
>    - Buffer information collected in response to sensor stimuli
> 
> 2. **Data Processor**:
>    - Process the collected information
>    - Compute appropriate responses
> 
> 3. **Actuator Process**:
>    - Generate control signals for the actuators
>    - Execute the computed responses in the environment
> 
> **RTS Process Flow**:
> 
> ```mermaid
> graph LR
>     A[Sensor] --> B[Sensor Control]
>     B --> C[Data Processor]
>     C --> D[Actuator Control]
>     D --> E[Actuator]
>     E --> F[Environment]
>     F --> A
> 
>```
> 
> This diagram illustrates the cyclical nature of real-time systems, showing how they continuously interact with their environment through sensors and actuators.
> 
> **Important Considerations**:
> - Timing constraints are critical
> - Must handle concurrent processing of multiple inputs
> - Reliability and fault tolerance are often crucial
> - May need to prioritize certain processes over others

> [!consider] Types of Real-Time Systems
> Real-time systems can be categorized based on the consequences of missing deadlines:
> 
> 1. **Soft Real-Time Systems**
>    - Missed deadlines still provide some value, albeit degraded
>    - Performance is degraded but not system failure
>    - Example: Digital thermometer
>      - If it updates temperature a bit late, the reading is still useful
> 
> 2. **Firm Real-Time Systems**
>    - Missed deadlines provide no benefit, but no cost is incurred
>    - Occasional misses are tolerable, but too many can degrade system quality
>    - Example: Assembly line robot
>      - If it misses a cycle, that piece isn't processed, but no damage occurs
> 
> 3. **Hard Essential Real-Time Systems**
>    - Missed deadlines incur a cost
>    - System continues to function, but with notable negative consequences
>    - Example: Printer in a business setting
>      - Missing a print deadline could result in lost business opportunities
> 
> 4. **Hard Critical Real-Time Systems**
>    - Missed deadlines can lead to catastrophic consequences
>    - System failure is not an option
>    - Example: Nuclear power plant control system
>      - Any delay in responding to critical events could lead to disaster
> 
> ```mermaid
> graph TD
>     A[Real-Time Systems] --> B[Soft]
>     A --> C[Firm]
>     A --> D[Hard Essential]
>     A --> E[Hard Critical]
>     B -->|"Degraded Value"| F[Thermometer]
>     C -->|"No Benefit, No Cost"| G[Assembly Robot]
>     D -->|"Cost Incurred"| H[Business Printer]
>     E -->|"Catastrophic Cost"| I[Nuclear System]
> 
>```
> 
> **Key Considerations**:
> - The classification of a system can change based on context
> - As criticality increases, so does the complexity of system design and testing
> - Hard real-time systems often require formal verification methods
> - Soft and firm systems may use best-effort approaches
> - The choice of type significantly impacts system architecture and resource allocation


idea - stimulus
- RT are stimulus / response systems
	- given an event (stimulus), the system must produce a response in a given time
- two types of events
	- periodic
		- occur at predictable intervals of time - example
	- aperiodic
		- occur at unpredictable times = system power failure

consider - design implications
- must allow for fast switching between stimulus handlers
	- sequential loop is usually not enough
	- need concurrent cooperating processes
	- priority
	- usually lots of sensors and actuators
	- Hard RTS usually written in assmebly for complete control and speed
	- C is also an option
	- based on non fucntional system requirements

idea - design process
1. identify events that needs to be processed and responded to
2. identify timing constraints
3. aggregate into concurrent processes
4. design algorithms to process each class of stim and response
5. design a scheduling system to ensure that processes are started in time

idea - modelling
- stimuluses trigger state switches
- we model these triggers and states using finite state machines
	- descibes tranistions from states to other states

example - finte state machine for petrol pump
- mermaid diagram for this please


idea - real time operating systems
- manage processes in real time systems
- responsible for process management, resource allocation
- include: (say what theyre used for)
	- clock 
		- information for scheduling
	- interrupt handler
		- manages aperodic requests for service
	- scheduler
		- choose which next process to run - fifo, spf, etc
		-  can be premptive (interupts other tasks)
		- non pre emptive -doesn't
		- the interrupt routine MUST be fast and simple
	- resource manager
		- allocate memory and processor resources
	- Dispatcher
		- starts process execution

example - rts operating system
- mermaid diagram again please

idea - periodic processes
- must be executed at specific, deterrmined times
- can be between executions, deadlines
- real time lcock ticks peroidically and each tick causes an interrupt to check for periodic processes

idea - data acquisition systems
- collect data from sensors processing and analysis
- need to think about
	- collection may be slower than processing, vice versa
	- need buffers for smooth processing

example - generic sensor mermaid model
-  3 sensors picked up and anylsed, stored into a buffer, which then gets processed and displayed. 
- have two of these leading into the display

example - producer / consumer
- producers collect data and add it to the buffer consumer taks data and make elements avaiable
- they must nbot access the same element
- the buffer stops producers from adding to a full buffer and consumer from taking information from an empty buffer