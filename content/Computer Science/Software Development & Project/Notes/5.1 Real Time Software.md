> [!idea] Real-Time Systems (RTS)
> Real-time systems are **continuous systems that monitor and control their environment**. They typically:
> - Run constantly without termination
> - Often involve hardware devices
> - Receive, process, and return data
> - Directly affect their environment
> 
> **Key Characteristic**: The correct functionality of an RTS depends not only on the results produced but also on the time at which those results are produced.
> 
> **Examples**: 
> - Sensors in a smart home system
> - Actuators in industrial robotics
> - Traffic light control systems
> - Aircraft navigation systems
> 
> **Core Elements of RTS**:
> 
> 1. **Sensor Controls**:
>    - Collect information from sensors
>    - Buffer information collected in response to sensor stimuli
> 
> 2. **Data Processor**:
>    - Process the collected information
>    - Compute appropriate responses
> 
> 3. **Actuator Process**:
>    - Generate control signals for the actuators
>    - Execute the computed responses in the environment
> 
> **RTS Process Flow**:
> 
> ```mermaid
> graph LR
>     A[Sensor] --> B[Sensor Control]
>     B --> C[Data Processor]
>     C --> D[Actuator Control]
>     D --> E[Actuator]
>     E --> F[Environment]
>     F --> A
> 
>```
> 
> This diagram illustrates the cyclical nature of real-time systems, showing how they continuously interact with their environment through sensors and actuators.
> 
> **Important Considerations**:
> - Timing constraints are critical
> - Must handle concurrent processing of multiple inputs
> - Reliability and fault tolerance are often crucial
> - May need to prioritize certain processes over others

> [!consider] Types of Real-Time Systems
> Real-time systems can be categorized based on the consequences of missing deadlines:
> 
> 1. **Soft Real-Time Systems**
>    - Missed deadlines still provide some value, albeit degraded
>    - Performance is degraded but not system failure
>    - Example: Digital thermometer
>      - If it updates temperature a bit late, the reading is still useful
> 
> 2. **Firm Real-Time Systems**
>    - Missed deadlines provide no benefit, but no cost is incurred
>    - Occasional misses are tolerable, but too many can degrade system quality
>    - Example: Assembly line robot
>      - If it misses a cycle, that piece isn't processed, but no damage occurs
> 
> 3. **Hard Essential Real-Time Systems**
>    - Missed deadlines incur a cost
>    - System continues to function, but with notable negative consequences
>    - Example: Printer in a business setting
>      - Missing a print deadline could result in lost business opportunities
> 
> 4. **Hard Critical Real-Time Systems**
>    - Missed deadlines can lead to catastrophic consequences
>    - System failure is not an option
>    - Example: Nuclear power plant control system
>      - Any delay in responding to critical events could lead to disaster
> 
> ```mermaid
> graph TD
>     A[Real-Time Systems] --> B[Soft]
>     A --> C[Firm]
>     A --> D[Hard Essential]
>     A --> E[Hard Critical]
>     B -->|"Degraded Value"| F[Thermometer]
>     C -->|"No Benefit, No Cost"| G[Assembly Robot]
>     D -->|"Cost Incurred"| H[Business Printer]
>     E -->|"Catastrophic Cost"| I[Nuclear System]
> 
>```
> 
> **Key Considerations**:
> - The classification of a system can change based on context
> - As criticality increases, so does the complexity of system design and testing
> - Hard real-time systems often require formal verification methods
> - Soft and firm systems may use best-effort approaches
> - The choice of type significantly impacts system architecture and resource allocation


> [!idea] Stimulus in Real-Time Systems
> Real-time systems (RTS) are fundamentally **stimulus/response systems:**
> - **Given an event (stimulus), the system must produce a response within a specified time frame**
> - The timeliness of the response is as critical as its correctness
> 
> **Types of Events (Stimuli)**:
> 
> 1. **Periodic Events**
>    - Occur at predictable intervals of time
>    - Easier to plan for and allocate resources
>    - Example: Refreshing a display screen every 16.7ms (60Hz)
>    
> ```mermaid
>    graph LR
>        A[Time] --> B[Event 1]
>        B --> |16.7ms| C[Event 2]
>        C --> |16.7ms| D[Event 3]
>        D --> |16.7ms| E[...]
>    
>```
> 
> 2. **Aperiodic Events**
>    - Occur at unpredictable times
>    - Require more flexible resource management
>    - Example: System power failure or user input
>    
> ```mermaid
>    graph LR
>        A[Time] --> B[Event 1]
>        B --> |Variable| C[Event 2]
>        C --> |Variable| D[Event 3]
>        D --> |Variable| E[...]
>    
>```

> [!consider] Design Implications for Real-Time Systems
> The unique requirements of real-time systems lead to several important design considerations:
> 
> 1. **Fast Switching Between Stimulus Handlers**
>    - Sequential loops are often insufficient due to varying response time requirements
>    - Solution: Implement concurrent cooperating processes
>    
> ```mermaid
>    graph TD
>        A[Scheduler] --> B[Process 1]
>        A --> C[Process 2]
>        A --> D[Process 3]
>        B --> E[Sensor 1]
>        C --> F[Sensor 2]
>        D --> G[Actuator]
>    
>```
> 
> 2. **Priority-Based Execution**
>    - Critical tasks must take precedence over less important ones
>    - Implement priority scheduling algorithms
> 
> 3. **Handling Multiple I/O Devices**
>    - RTS typically interface with numerous sensors and actuators
>    - Requires efficient I/O management and interrupt handling
> 
> 4. **Programming Language Choice**
>    - Hard Real-Time Systems:
>      - Often written in assembly language for complete control and speed
>      - Provides fine-grained control over hardware resources
>      - Allows for precise timing control
>    - Alternative: C programming language
>      - Offers a balance between low-level control and higher-level abstractions
>      - Widely used in embedded systems and RTS
> 
> 5. **Non-Functional Requirements**
>    - Design choices heavily influenced by:
>      - Performance requirements (e.g., response time, throughput)
>      - Reliability and fault tolerance needs
>      - Resource constraints (memory, processing power)

> [!idea] Real-Time System Design Process
> 1. **Identify events**: Determine all stimuli that the system must respond to
>    - Include both periodic and aperiodic events
>    - Consider normal operations and potential error conditions
> 
> 2. **Identify timing constraints**: For each event, specify:
>    - Maximum response time
>    - Periodic event frequencies
>    - Deadlines for completing responses
> 
> 3. **Aggregate into concurrent processes**: Group related events and responses into:
>    - Sensor management processes
>    - Data processing tasks
>    - Actuator control processes
> 
> 4. **Design algorithms**: For each process, develop algorithms to:
>    - Handle incoming stimuli
>    - Process data
>    - Generate appropriate responses
> 
> 5. **Design scheduling system**: Create a scheduling mechanism that:
>    - Ensures processes meet their timing constraints
>    - Handles priority between competing processes
>    - Manages resource allocation

> [!idea] Modelling Real-Time Systems
> Real-time systems are often **modelled using finite state machines (FSMs)** because:
> - They clearly **represent system behavior** in response to stimuli
> - They **show all possible states** a system can be in
> - They illustrate how the system transitions between states
> 
> Key components of an FSM:
> - States: Represent the condition of the system at a given time
> - Transitions: Show how the system moves from one state to another
> - Events/Stimuli: Trigger transitions between states
> - Actions: Operations performed when entering a state or during a transition

> [!example] Finite State Machine for Petrol Pump
> 
> ```mermaid
> stateDiagram-v2
>     [*] --> Idle
>     Idle --> ReadyToPump: Nozzle Lifted / Display "Ready"
>     ReadyToPump --> Pumping: Trigger Pressed / Start Fuel Flow
>     Pumping --> ReadyToPump: Trigger Released / Stop Fuel Flow
>     ReadyToPump --> Idle: Nozzle Replaced / Reset Display
>     Pumping --> Idle: Tank Full / Stop Fuel Flow, Alert User
>     Idle --> OutOfOrder: System Fault Detected / Display "Out of Order"
>     OutOfOrder --> Idle: System Repaired / Reset System
>     Pumping --> Emergency: Emergency Button Pressed / Stop All Operations
>     Emergency --> Idle: Emergency Reset / System Check
> 
> ```
> 
> This expanded FSM for a petrol pump includes:
> - Additional states: OutOfOrder and Emergency
> - More detailed transitions with actions
> - Initial state indicator [*]
> - Complex scenarios like system faults and emergency situations


idea - real time operating systems
- manage processes in real time systems
- responsible for process management, resource allocation
- include: (say what theyre used for)
	- clock 
		- information for scheduling
	- interrupt handler
		- manages aperodic requests for service
	- scheduler
		- choose which next process to run - fifo, spf, etc
		-  can be premptive (interupts other tasks)
		- non pre emptive -doesn't
		- the interrupt routine MUST be fast and simple
	- resource manager
		- allocate memory and processor resources
	- Dispatcher
		- starts process execution

example - rts operating system
- mermaid diagram again please

idea - periodic processes
- must be executed at specific, deterrmined times
- can be between executions, deadlines
- real time lcock ticks peroidically and each tick causes an interrupt to check for periodic processes

idea - data acquisition systems
- collect data from sensors processing and analysis
- need to think about
	- collection may be slower than processing, vice versa
	- need buffers for smooth processing

example - generic sensor mermaid model
-  3 sensors picked up and anylsed, stored into a buffer, which then gets processed and displayed. 
- have two of these leading into the display

example - producer / consumer
- producers collect data and add it to the buffer consumer taks data and make elements avaiable
- they must nbot access the same element
- the buffer stops producers from adding to a full buffer and consumer from taking information from an empty buffer