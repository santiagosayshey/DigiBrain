
> [!idea]+ GitHub
> 
> GitHub enhances Git with:
> - Centralized Git repository hosting
> - Collaboration features (pull requests, issues)
> - CI/CD tool integration
> - Project management capabilities

> [!idea]+ Pull Requests
> 
> A mechanism for **proposing changes to a codebase.**
> - Developers submit changes for review before merging
> - Facilitates collaborative development and quality control
> - Integral part of the Code Review process
> 
> Pull requests are what we review during code reviews, ensuring code quality and consistency.

> [!idea]+ GitHub Issues
> 
> A tracking system for tasks, enhancements, and bugs in GitHub repositories.
> - Centralized location for project management
> - Supports labels, milestones, and assignees
> - Integrates with pull requests for traceability
> 
> GitHub Issues help teams organize work and prioritize tasks effectively. When developers **create pull requests to address specific issues, they can reference the relevant issue numbers**, creating a clear **connection between the problem and its solution.**

> [!idea]+ Code Reviews
> 
> A systematic examination of source code by peers.
> - **Identify bugs, logic errors, and security vulnerabilities**
> - Ensure code quality, readability, and adherence to standards
> - Facilitate knowledge sharing among team members
> 
> Code reviews are a crucial step in the Definition of Done (DoD) for many development teams.

> [!idea] GitHub Diff
> A **diff** in GitHub shows the **differences between two versions of code**:
> - Compares files line by line
> - Highlights added, removed, and modified lines
> - Appears in pull requests, commits, and branch comparisons
> 
> Key features:
> - Color-coding: Green for additions, red for deletions
> - Side-by-side view option for easier comparison
> - Ability to comment on specific lines in the diff
> 
> Diffs are crucial for:
> - **Code reviews**: Quickly identify and discuss changes
> - **Tracking history**: Understand how code evolved over time
> - **Resolving conflicts**: Visualize differences when merging branches

> [!consider] Merge Conflicts in Git
> Merge conflicts occur when Git can't automatically **reconcile differences between branches**:
> 
> - **Causes**:
>   - Same lines edited in both branches
>   - File deleted in one branch but edited in another
>   - File added with the same name in both branches
> 
> - **Implications**:
>   - Halts the merging process
>   - Requires manual intervention
>   - Can slow down development if frequent
> 
> - **Prevention strategies**:
>   - Frequent small merges
>   - Clear communication among team members
>   - Using feature flags for long-running features
> 
> Resolving merge conflicts is a crucial skill for effective collaboration in Git-based workflows.


> [!example] Resolving a Merge Conflict
> Scenario: Conflicting changes in the `main` and `feature` branches for a file named `greeting.js`.
> 
> 1. Attempt to merge:
>    ```
>    git checkout main
>    git merge feature
>    ```
>    Git reports: "CONFLICT (content): Merge conflict in greeting.js"
> 
> 2. Open the conflicting file `greeting.js`:
>    ```javascript
>    <<<<<<< HEAD
>    function greet() {
>      return "Hello from main branch";
>    }
>    =======
>    function greet() {
>      return "Hello from feature branch";
>    }
>    >>>>>>> feature
>    ```
>    
>    Explanation of conflict markers:
>    - `<<<<<<< HEAD`: Beginning of the conflicting section in the current branch (main)
>    - `=======`: Separator between the conflicting changes
>    - `>>>>>>> feature`: End of the conflicting section, showing the incoming branch (feature)
> 
> 3. Resolve the conflict:
>    Decide which version to keep or how to combine them. For example:
>    ```javascript
>    function greet() {
>      return "Hello from main and feature branches";
>    }
>    ```
>    Remove all conflict markers after deciding on the final version.
> 
> 4. Stage the resolved file:
>    ```
>    git add greeting.js
>    ```
> 
> 5. Complete the merge:
>    ```
>    git commit -m "Resolve greeting.js merge conflict"
>    ```
>    Git will open an editor with a pre-filled commit message. You can modify it if needed.
> 
> 6. Push the changes:
>    ```
>    git push origin main
>    ```
> 
> Tips:
> - Use `git diff` to see the differences between the conflicting versions
> - If unsure about which changes to keep, consult with team members
> - Some IDEs and text editors provide visual tools for resolving conflicts
> - Always test the resolved code to ensure it works as expected
> 
> Remember, resolving conflicts often requires understanding the intent behind the changes, not just mechanically combining them.

> [!motivation]+ Why Review Code?
> 
> Imagine a scenario where untested code is pushed directly to production:
> - A critical e-commerce platform experiences frequent crashes
> - Customer data is exposed due to a security vulnerability
> - The company loses millions in revenue and faces legal consequences
> 
> Code reviews help **prevent such scenarios by catching issues early** in the development process.

> [!example]+ GitHub Code Review Process
> 
> 1. Developer creates a new branch and makes changes
> 2. Developer opens a pull request (PR)
> 3. Reviewers are assigned or notified
> 4. Reviewers examine the code, leaving comments
> 5. Developer addresses feedback and makes changes
> 6. Reviewers approve the PR
> 7. Code is merged into the main branch


> [!consider]+ Commit Messages
> 
> Effective commit messages include:
> - Concise title/summary
> - Detailed description of changes
> - Related ticket/issue ID
>
> Importance:
> - Facilitates code review
> - Aids in generating changelogs
> - Helps track project history and decision-making

> [!example]+ Good Commit Message
> 
> ```
> Add user authentication feature
> 
> - Implement OAuth2 flow for Google and Facebook login
> - Create user profile page with editable fields
> - Add session management and logout functionality
> 
> Closes #123
> ```

> [!idea]+ Version Numbering
> 
> Semantic Versioning (SemVer) format: MAJOR.MINOR.PATCH
> - MAJOR: Incompatible API changes
> - MINOR: New backwards-compatible features
> - PATCH: Backwards-compatible bug fixes
> 
> Optional pre-release labels may be added (e.g., 1.0.0-alpha.1)

> [!example]+ Version Number Examples
> 
> - 1.0.0: Initial release
> - 1.1.0: New feature added
> - 1.1.1: Bug fix
> - 2.0.0: Major update with breaking changes
> - 1.2.0-beta.1: Beta version of upcoming feature release
