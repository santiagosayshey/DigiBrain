> [!idea] Software Architecture Design
> Software architecture design is a crucial phase that:
> - Identifies and defines major system components and their relationships
> - Establishes patterns for system organization and communication
> - Balances functional requirements with non-functional qualities (e.g., performance, security, scalability)
> 
> Key outputs:
> - High-level structure diagrams (e.g., component diagrams, deployment diagrams)
> - Interface specifications between major components
> - Design principles and patterns to be used across the system
> - Rationale for key architectural decisions
> 
> The architecture serves as a bridge between requirements and detailed design, guiding the entire development process and ensuring alignment with project goals.

> [!example] Banking System Architecture
> Here's a simplified architectural diagram for a banking system:
> 
> ```mermaid
> graph TD
>     A[Client Interface] --> B[Authentication Service]
>     A --> C[Transaction Service]
>     C --> D[Account Management]
>     C --> E[Payment Processing]
>     D --> F[Database]
>     E --> F
>     B --> G[Security Layer]
>     C --> G
>     D --> G
>     E --> G
> ```
> 
> This diagram illustrates:
> - Major components: Client Interface, Authentication, Transaction Service, etc.
> - Interactions between components
> - Central role of the Security Layer in all operations

> [!consider] Importance of Architecture Design
> Architecture design is valuable for several reasons:
> 
> 1. **Stakeholder Communication**:
>    - Facilitates discussions on system structure and functionality
>    - Allows early feedback on what works and what doesn't
> 
> 2. **System Analysis**:
>    - Enables assessment of whether the proposed system can meet requirements
>    - Allows evaluation of performance and reliability at a high level
> 
> 3. **Early Design Considerations**:
>    - Forces developers to consider key design aspects early in the process
>    - Reduces the need for major refactoring later in development
> 
> 4. **Scalability Planning**:
>    - Helps in designing systems that can grow and adapt to future needs
> 
> 5. **Risk Mitigation**:
>    - Identifies potential technical challenges early in the project lifecycle
> 
> By addressing these aspects early, architecture design can significantly improve project outcomes and reduce development risks.

> [!idea] Choosing an Architecture
> When selecting a software architecture, it must satisfy both functional and non-functional requirements:
> 
> 1. **Performance**:
>    Example: A real-time trading system requiring response times under 10 milliseconds
> 
> 2. **Security**:
>    Example: A healthcare system needing end-to-end encryption for patient data
> 
> 3. **Safety**:
>    Example: An air traffic control system with redundant backup systems
> 
> 4. **Availability**:
>    Example: A cloud storage service guaranteeing 99.99% uptime
> 
> 5. **Maintainability**:
>    Example: A modular CMS allowing easy addition of new features without affecting existing ones

> [!consider] Architectural Conflicts
> Sometimes, requirements can conflict, requiring careful trade-offs:
> 
> - Large-grain components can improve performance by reducing inter-component communication
> - Fine-grain components enhance maintainability by isolating functionality
> 
> **Compromise Solution**: Modularize the system, using different granularities where appropriate
> - Example: Large-grain for performance-critical sections, fine-grain for frequently updated features
> - Note: This approach can increase development complexity

> [!example] Architectural Approaches: Monolithic vs. Microservices
> Here are two contrasting architectural approaches for an e-commerce system:
> 
> Monolithic Architecture:
> ```mermaid
> graph TD
>     A[Client] --> B[Monolithic Application]
>     B --> C[(Database)]
>     B --> D[External Services]
> ```
> 
> Microservices Architecture:
> ```mermaid
> graph TD
>     A[Client] --> B[API Gateway]
>     B --> C[User Service]
>     B --> D[Product Service]
>     B --> E[Order Service]
>     B --> F[Payment Service]
>     C --> G[(User DB)]
>     D --> H[(Product DB)]
>     E --> I[(Order DB)]
>     F --> J[(Payment DB)]
> ```
> 
> The monolithic architecture combines all functionality into a single application, which can be simpler to develop initially but harder to scale. The microservices architecture separates concerns into distinct services, improving scalability and maintainability at the cost of increased complexity in service communication and deployment.

consider - decisions
- well designed architecture mostly depends on experience of architect - things are hard to foresee (this is why most have switched to agile over waterfall)
- questions we need to ask:
	- generic template we can copy?
	- distrubution?
	- appropriate style?
	- approach?
	- modules?
	- evaluation?
	- documented?
	- 