> [!motivation] Motivation
> Condition variables enable concurrency by allowing one thread to signal another, determining execution order. However, they require manual state management by the programmer. Consider a simple producer-consumer scenario:
> ```cpp
> mutex mtx; 
> condition_variable cv;
> bool dataReady = false;
> int data;
> 
> // Producer thread
> void producer() {
>     while (true) {
>         mtx.lock();
>         data = generateData();
>         dataReady = true;
>         cv.notify_one();
>         mtx.unlock();
>     }
> }
> 
> // Consumer thread
> void consumer() {
>     while (true) {
>         mtx.lock();
>         while (!dataReady) {
>             cv.wait(mtx);
>         }
>         consumeData(data);
>         dataReady = false;
>         mtx.unlock();
>     }
> }
> ```
> Here, the `dataReady` flag and the `data` variable must be **manually managed to coordinate the producer and consumer threads.** The **programmer is responsible** for correctly setting and checking these shared variables, as well as explicitly locking and unlocking the mutex. As systems grow more complex, this **manual state management and synchronization becomes increasingly difficult** and prone to errors. A higher-level synchronization primitive that encapsulates state and provides a more intuitive interface could greatly simplify concurrent programming and reduce the potential for bugs.

> [!idea] Semaphores
> Semaphores are a generalized synchronization primitive that can be used to control access to shared resources or to synchronize the actions of multiple threads or processes. They have a n**on-negative integer value, which represents the number of available resources or the state of the semaphore.**
> 
> The key operations on a semaphore are:
> - `wait()` (also known as `acquire()` or `down()`): This operation waits for the semaphore's value to become positive and then decrements it by 1. If the semaphore's value is already positive, the operation proceeds immediately. Otherwise, the calling thread or process is blocked until the semaphore becomes positive.
> - `post()` (also known as `release()` or `up()`): This operation increments the semaphore's value by 1. If there are any threads or processes waiting on the semaphore (blocked by `wait()`), one of them is woken up to proceed.
> 
> By using these operations, semaphores can be used to implement various synchronization patterns, such as mutual exclusion, resource allocation, and signaling between threads or processes.

> [!consider] Railway Analogy
> Imagine a single-track railway where trains can travel in both directions. To prevent collisions, a semaphore is placed at each end of the track. The semaphore's value represents the number of trains allowed on the track at any given time.
> 
> ```
> Train Station A                                Train Station B
>      |                                                |
>      |                    Single Track                |
>      |                 <----------------->            |
>     (S)                                              (S)
>  Semaphore A                                     Semaphore B
> ```
> 
> When a train wants to enter the track from Station A, it performs a `wait()` operation on Semaphore A. If the semaphore's value is positive (meaning there is space on the track), the train enters the track, and the semaphore's value is decremented. If the value is zero (meaning the track is full), the train must wait until another train leaves the track and increments the semaphore using `post()`.
> 
> Similarly, when a train arrives at Station B and leaves the track, it performs a `post()` operation on Semaphore A, incrementing its value and allowing waiting trains at Station A to enter the track.
> 
> This analogy illustrates how semaphores can be used to control access to a shared resource (the single-track railway) and prevent conflicts (train collisions).
