> [!motivation] Motivation
> Condition variables enable concurrency by allowing one thread to signal another, determining execution order. However, they require manual state management by the programmer. Consider a simple producer-consumer scenario:
> ```cpp
> mutex mtx; 
> condition_variable cv;
> bool dataReady = false;
> int data;
> 
> // Producer thread
> void producer() {
>     while (true) {
>         mtx.lock();
>         data = generateData();
>         dataReady = true;
>         cv.notify_one();
>         mtx.unlock();
>     }
> }
> 
> // Consumer thread
> void consumer() {
>     while (true) {
>         mtx.lock();
>         while (!dataReady) {
>             cv.wait(mtx);
>         }
>         consumeData(data);
>         dataReady = false;
>         mtx.unlock();
>     }
> }
> ```
> Here, the `dataReady` flag and the `data` variable must be **manually managed to coordinate the producer and consumer threads.** The **programmer is responsible** for correctly setting and checking these shared variables, as well as explicitly locking and unlocking the mutex. As systems grow more complex, this **manual state management and synchronization becomes increasingly difficult** and prone to errors. A higher-level synchronization primitive that encapsulates state and provides a more intuitive interface could greatly simplify concurrent programming and reduce the potential for bugs.

> [!idea] Semaphores
> Semaphores are a generalized synchronization primitive that can be used to control access to shared resources or to synchronize the actions of multiple threads or processes. They have a **non-negative integer value, which represents the number of available resources or the state of the semaphore.**
> 
> The key operations on a semaphore are:
> - `wait()` (also known as `acquire()` or `down()`): This operation waits for the semaphore's value to become positive and then decrements it by 1. If the semaphore's value is already positive, the operation proceeds immediately. Otherwise, the calling thread or process is blocked until the semaphore becomes positive.
> - `post()` (also known as `release()` or `up()`): This operation increments the semaphore's value by 1. If there are any threads or processes waiting on the semaphore (blocked by `wait()`), one of them is woken up to proceed.
>
> **Initialization:**
> When creating a semaphore, its initial value must be specified. This value **represents the initial number of available resources or permits.**
>
> **Atomicity:**
> The `wait()` and `post()` operations are atomic, meaning they cannot be interrupted by other threads or processes. This ensures that the semaphore's value remains consistent and helps prevent race conditions.
>
> **Preventing Race Conditions:**
> While the atomic nature of `wait()` and `post()` operations helps prevent race conditions, it's important to note that the code executed between these operations is not automatically protected. Developers must still design their code carefully to ensure proper synchronization and avoid issues like over-allocation of resources.
>
> By using these operations, semaphores can be used to implement various synchronization patterns, such as mutual exclusion, resource allocation, and signaling between threads or processes.

> [!consider] Factorio Trains
> Take a look at this railway section with three stations on each side of a single-lane track. Five trains continuously move back and forth between the sides, loading and unloading materials at the stations. To prevent collisions and ensure efficient traffic flow, signals are placed at each station, acting as semaphores.
> 
> ![[factorio_semaphore_trains.mp4]]
> 
> **Semaphore Initialization:**
> In this scenario, the semaphore's initial value would be set to 1, as there is only a single-lane track connecting the stations on both sides. This initialization effectively defines the number of paths available between the loading and unloading stations.
> 
> When a train wants to enter the single-lane track from any loading station on side A (A1, A2, or A3), it checks the signal (semaphore) at its station. If the signal is green (semaphore value is positive), indicating that there is space on the track, the train enters the track, and the signal turns red (semaphore value is decremented). If the signal is already red (semaphore value is zero), the train must wait until another train leaves the track and the signal turns green again (semaphore value is incremented).
> 
> Similarly, when a train arrives at any unloading station on side B (B1, B2, or B3) and leaves the track, the signal (semaphore) at the station it departed from on side A turns green (increments its value), allowing waiting trains at side A stations to enter the track.
> 
> This Factorio rail intersection effectively demonstrates how semaphores, represented by the signals, can be used to control access to a shared resource (the single-lane track) and coordinate the actions of multiple entities (trains from multiple stations on both sides) to prevent conflicts and ensure efficient operation.


> [!example] Semaphores in Action
> Here's a simple example of how semaphores can be used in Python to synchronize access to a shared resource:
> 
> ```python
> import threading
> import time
> 
> class SharedPrinter:
>     def __init__(self):
>         self.semaphore = threading.Semaphore(1)
> 
>     def print_document(self, document):
>         self.semaphore.acquire()
>         print(f"Printing document: {document}")
>         time.sleep(1)  # Simulating printing time
>         print(f"Finished printing: {document}")
>         self.semaphore.release()
> 
> def worker(printer, document):
>     printer.print_document(document)
> 
> shared_printer = SharedPrinter()
> documents = ["Doc1", "Doc2", "Doc3", "Doc4", "Doc5"]
> 
> threads = []
> for doc in documents:
>     t = threading.Thread(target=worker, args=(shared_printer, doc))
>     threads.append(t)
>     t.start()
> 
> for t in threads:
>     t.join()
> ```
> 
> In this example, we have a `SharedPrinter` class that represents a shared resource (a printer) that multiple threads want to access concurrently. The `SharedPrinter` class has a semaphore initialized with a value of 1, indicating that only one thread can access the printer at a time.
> 
> The `print_document` method acquires the semaphore using `semaphore.acquire()`, simulates the printing process (with a 1-second delay), and then releases the semaphore using `semaphore.release()`. This ensures that only one thread can print a document at a time.
> 
> We create multiple threads, each representing a document to be printed. The threads are started, and each thread calls the `print_document` method of the shared printer instance.
> 
> When a thread acquires the semaphore, it proceeds to print its document. Other threads that try to acquire the semaphore will be blocked until the semaphore is released by the thread that is currently printing.
> 
> The output will show that documents are printed one at a time, with each document taking 1 second to print, demonstrating how the semaphore synchronizes access to the shared printer resource.
> 
> This example illustrates how semaphores can be used to control access to a shared resource, ensuring that only a limited number of threads (in this case, one) can access the resource concurrently, preventing conflicts and maintaining the desired order of execution.

