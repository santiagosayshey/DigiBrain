> [!motivation] Motivation
> Condition variables enable concurrency by allowing one thread to signal another, determining execution order. However, they require manual state management by the programmer. Consider a simple producer-consumer scenario:
> ```cpp
> mutex mtx; 
> condition_variable cv;
> bool dataReady = false;
> int data;
> 
> // Producer thread
> void producer() {
>     while (true) {
>         mtx.lock();
>         data = generateData();
>         dataReady = true;
>         cv.notify_one();
>         mtx.unlock();
>     }
> }
> 
> // Consumer thread
> void consumer() {
>     while (true) {
>         mtx.lock();
>         while (!dataReady) {
>             cv.wait(mtx);
>         }
>         consumeData(data);
>         dataReady = false;
>         mtx.unlock();
>     }
> }
> ```
> Here, the `dataReady` flag and the `data` variable must be **manually managed to coordinate the producer and consumer threads.** The **programmer is responsible** for correctly setting and checking these shared variables, as well as explicitly locking and unlocking the mutex. As systems grow more complex, this **manual state management and synchronization becomes increasingly difficult** and prone to errors. A higher-level synchronization primitive that encapsulates state and provides a more intuitive interface could greatly simplify concurrent programming and reduce the potential for bugs.

idea - semaphores
- generalised lock (what does this mean?)
- has a non negative integer value
- wait() - waits for the semaphore to become positive then decrements it by 1
- post() - increments the semaphore by 1, waking up a waiting wait() (like signal)