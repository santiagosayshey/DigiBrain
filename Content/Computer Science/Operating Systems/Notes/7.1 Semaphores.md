> [!motivation] Motivation
> Condition variables enable concurrency by allowing one thread to signal another, determining execution order. However, they require manual state management by the programmer. Consider a simple producer-consumer scenario:
> ```cpp
> mutex mtx; 
> condition_variable cv;
> bool dataReady = false;
> int data;
> 
> // Producer thread
> void producer() {
>     while (true) {
>         mtx.lock();
>         data = generateData();
>         dataReady = true;
>         cv.notify_one();
>         mtx.unlock();
>     }
> }
> 
> // Consumer thread
> void consumer() {
>     while (true) {
>         mtx.lock();
>         while (!dataReady) {
>             cv.wait(mtx);
>         }
>         consumeData(data);
>         dataReady = false;
>         mtx.unlock();
>     }
> }
> ```
> Here, the `dataReady` flag and the `data` variable must be **manually managed to coordinate the producer and consumer threads.** The **programmer is responsible** for correctly setting and checking these shared variables, as well as explicitly locking and unlocking the mutex. As systems grow more complex, this **manual state management and synchronization becomes increasingly difficult** and prone to errors. A higher-level synchronization primitive that encapsulates state and provides a more intuitive interface could greatly simplify concurrent programming and reduce the potential for bugs.

> [!idea] Semaphores
> Semaphores are a generalized synchronization primitive that can be used to control access to shared resources or to synchronize the actions of multiple threads or processes. They have a n**on-negative integer value, which represents the number of available resources or the state of the semaphore.**
> 
> The key operations on a semaphore are:
> - `wait()` (also known as `acquire()` or `down()`): This operation waits for the semaphore's value to become positive and then decrements it by 1. If the semaphore's value is already positive, the operation proceeds immediately. Otherwise, the calling thread or process is blocked until the semaphore becomes positive.
> - `post()` (also known as `release()` or `up()`): This operation increments the semaphore's value by 1. If there are any threads or processes waiting on the semaphore (blocked by `wait()`), one of them is woken up to proceed.
> 
> By using these operations, semaphores can be used to implement various synchronization patterns, such as mutual exclusion, resource allocation, and signaling between threads or processes.

> [!consider] Factorio Trains
> Take a look at this railway section with three stations on each side of a single-lane track. Five trains continuously move back and forth between the sides, loading and unloading materials at the stations. To prevent collisions and ensure efficient traffic flow, signals are placed at each station, acting as semaphores.
> 
> ![[factorio_semaphore_trains.mp4]]
> 
> When a train wants to enter the single-lane track from any loading station on side A (A1, A2, or A3), it checks the signal (semaphore) at its station. If the signal is green (semaphore value is positive), indicating that there is space on the track, the train enters the track, and the signal turns red (semaphore value is decremented). If the signal is already red (semaphore value is zero), the train must wait until another train leaves the track and the signal turns green again (semaphore value is incremented).
> 
> Similarly, when a train arrives at any unloading station on side B (B1, B2, or B3) and leaves the track, the signal (semaphore) at the station it departed from on side A turns green (increments its value), allowing waiting trains at side A stations to enter the track.
> 
> This Factorio rail intersection effectively demonstrates how semaphores, represented by the signals, can be used to control access to a shared resource (the single-lane track) and coordinate the actions of multiple entities (trains from multiple stations on both sides) to prevent conflicts and ensure efficient operation.
