> [!motivation] The Need for Permanent Storage
> Computing systems require **permanent storage to persist data beyond the lifetime of processes or the computer itself.** This enables applications to store and retrieve data across sessions, even after the machine has been powered off.

> [!idea] Virtualizing Storage: Files as Persistent Byte Arrays
> Storage virtualization abstracts physical storage devices, presenting them as virtual resources. In this context, files are treated as **arrays of persistent bytes that can be read from or written to**. Files are identified using three types of names:
> 
> 1. I-node numbers: Unique identifiers assigned to each file by the file system.
> 
> ![[Pasted image 20241017175241.png|300]]
> 
> 2. Paths: Human-readable, hierarchical names that represent the location of a file within the directory structure.
> 3. File descriptors: Non-negative integers returned by the kernel when a process opens a file, used for subsequent file operations.

> [!idea] Directories
> Directories are a special type of file used to organize and provide a hierarchical structure to the file system. They contain entries that **map human-readable names to i-node numbers**, allowing users to **navigate and locate files using meaningful paths**.
>
> Directories include two special entries:
> 1. ".": Refers to the directory itself.
> 2. "..": Refers to the parent directory.
> 
> These special entries allow for relative path navigation within the file system hierarchy.
>
> ![[Pasted image 20241017175420.png|400]]
>
> ![[Pasted image 20241017175557.png|400]]

> [!idea] File Descriptors
> File descriptors are **non-negative integers returned by the kernel** when a process opens a file. They serve as **unique identifiers for open files within a process** and are used for subsequent file operations.
> 
> When a file is opened, the kernel:
> 1. Performs an **expensive traversal** of the file system hierarchy to locate the file's i-node.
> 2. Stores the i-node information in a **descriptor object** in the kernel.
> 3. Returns the **index of the descriptor object** as the file descriptor to the process.
> 
> This approach **avoids repeated traversals** for each operation on the open file.
> 
> Three standard file descriptors are predefined:
> - 0: Standard input (stdin)
> - 1: Standard output (stdout)
> - 2: Standard error (stderr)
> 
> These descriptors enable communication with the process's environment.

> [!example] File System Traversal
> Consider the following file system hierarchy:
> 
> ```
> /
> ├── home/
> │   └── user/
> │       └── documents/
> │           └── report.txt
> └── etc/
>     └── config.ini
> ```
> 
> To open the file "/home/user/documents/report.txt", the kernel performs these steps:
> 
> 1. Start at the root directory ("/").
> 2. Find the entry for "home" in the root directory's i-node and retrieve its i-node number.
> 3. Access the "home" directory's i-node and find the entry for "user", retrieving its i-node number.
> 4. Access the "user" directory's i-node and find the entry for "documents", retrieving its i-node number.
> 5. Access the "documents" directory's i-node and find the entry for "report.txt", retrieving its i-node number.
> 6. Access the i-node of "report.txt" to obtain the file's metadata and data block addresses.
> 
> The kernel then creates a descriptor object containing the file's i-node information and returns the index of this object as the file descriptor to the process.

Certainly! Here's an example of using the x86 file API functions (open, read, write) along with a Mermaid diagram illustrating the process of i-node traversal:

I apologize for the confusion. Let me include the corrected Mermaid diagram within the callout:

> [!example] x86 File API Usage
> Consider a program that opens a file, reads its contents, and writes them to another file:
> 
> ```c
> #include <fcntl.h>
> #include <unistd.h>
> 
> int main() {
>     int fd_in = open("input.txt", O_RDONLY);
>     int fd_out = open("output.txt", O_WRONLY | O_CREAT, 0644);
>     
>     char buffer[1024];
>     ssize_t bytes_read;
>     
>     while ((bytes_read = read(fd_in, buffer, sizeof(buffer))) > 0) {
>         write(fd_out, buffer, bytes_read);
>     }
>     
>     close(fd_in);
>     close(fd_out);
>     
>     return 0;
> }
> ```
> 
> This program:
> 1. Opens "input.txt" for reading using `open()`, which returns a file descriptor (fd_in).
> 2. Opens "output.txt" for writing using `open()`, which returns another file descriptor (fd_out).
> 3. Reads data from fd_in into a buffer using `read()` in a loop until the end of the file is reached.
> 4. Writes the data from the buffer to fd_out using `write()`.
> 5. Closes both file descriptors using `close()`.
> 
> Here's a Mermaid diagram showing the i-node traversal process for opening "input.txt":
> 
> ```mermaid
> graph TD
>     A[Start] --> B[Open input.txt]
>     B --> C[Traverse file system hierarchy]
>     C --> D{Find input.txt i-node}
>     D -->|Found| E[Create descriptor object]
>     D -->|Not found| F[Return error]
>     E --> G[Return file descriptor]
> ```
> 
> The diagram illustrates the steps involved in opening a file:
> 1. The `open()` function is called with the file name "input.txt".
> 2. The kernel traverses the file system hierarchy to locate the i-node of "input.txt".
> 3. If the i-node is found, a descriptor object is created with the i-node information.
> 4. The index of the descriptor object is returned as the file descriptor.
> 5. If the i-node is not found, an error is returned.
