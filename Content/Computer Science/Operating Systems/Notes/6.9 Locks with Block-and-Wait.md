> [!motivation] The Need for Blocking Locks
> While spin locks can be efficient for short waits, they have drawbacks:
> - **CPU waste:** Continuously spinning consumes CPU cycles
> - **Energy inefficiency:** Constant activity increases power consumption
> - **Priority inversion:** Low-priority tasks holding a lock can prevent high-priority tasks from running
> 
> For longer waits or in systems where energy efficiency is crucial, a blocking approach can be more beneficial.

> [!idea] Blocking Locks: Sleep When Waiting
> Blocking locks put waiting threads to sleep instead of spinning, freeing up CPU resources for other tasks.
> 
> **Key concepts:**
> - **Sleep queue:** A queue where waiting threads are placed when they can't acquire the lock
> - **Wake-up mechanism:** A way to wake up sleeping threads when the lock becomes available
> 
> **How it works:**
> 1. Thread attempts to acquire the lock
> 2. If the lock is unavailable, the thread is added to a sleep queue and blocks (sleeps)
> 3. When the lock is released, one or more waiting threads are woken up
> 4. Awakened threads compete to acquire the lock
> 
> **Basic implementation (pseudocode):**
> ```c
> typedef struct {
>     int locked;  // 0: unlocked, 1: locked
>     queue_t wait_queue;  // Queue of waiting threads
> } blocking_lock_t;
> 
> void blocking_lock_acquire(blocking_lock_t *lock) {
>     disable_interrupts();  // Enter critical section
>     if (lock->locked) {
>         add_to_wait_queue(&lock->wait_queue, current_thread);
>         sleep();  // Releases interrupts and switches context
>     } else {
>         lock->locked = 1;
>         enable_interrupts();
>     }
> }
> 
> void blocking_lock_release(blocking_lock_t *lock) {
>     disable_interrupts();
>     if (queue_empty(&lock->wait_queue)) {
>         lock->locked = 0;
>     } else {
>         thread_t *thread = remove_from_wait_queue(&lock->wait_queue);
>         wake_up(thread);  // This thread will acquire the lock
>     }
>     enable_interrupts();
> }
> ```

> [!example] Blocking Lock in Action
> Consider three threads (A, B, C) competing for a blocking lock:
> 
> ```
> Time  Thread A              Thread B              Thread C              Lock State
> ────  ───────────────────   ───────────────────   ───────────────────   ───────────
>  t1   acquire() -> success                                              Locked (A)
>  t2   [Critical Section]
>  t3                         acquire() -> block                          Locked (A), B sleeping
>  t4                                               acquire() -> block    Locked (A), B&C sleeping
>  t5   release()                                                         Unlocked, B woken
>  t6                         acquire() -> success                        Locked (B), C sleeping
>  t7                         [Critical Section]
>  t8                         release()                                   Unlocked, C woken
>  t9                                               acquire() -> success  Locked (C)
> ```
> 
> In this scenario:
> - Waiting threads (B and C) sleep instead of spinning
> - CPU can be used for other tasks while threads are blocked
> - Threads are woken in the order they were blocked (FIFO fairness)

> [!consider] Advantages and Limitations of Blocking Locks
> **Advantages:**
> - **CPU efficiency:** Frees up CPU for other tasks when threads are waiting
> - **Energy savings:** Reduced CPU activity can lead to lower power consumption
> - **Fairness:** Can easily implement FIFO ordering of lock acquisition
> - **Priority handling:** Can be integrated with priority scheduling mechanisms
> 
> **Limitations:**
> - **Context switch overhead:** Blocking and waking involve context switches, which have a cost
> - **Latency:** May introduce more latency compared to spinning for very short waits
> - **Complexity:** More complex to implement correctly, especially in user space
> 
> **Considerations:**
> - Often implemented by the operating system (e.g., mutexes, semaphores)
> - Can be combined with spinning in hybrid approaches (spin-then-block)
> - Well-suited for scenarios where lock hold times are unpredictable or potentially long
> - May require kernel support for efficient implementation
