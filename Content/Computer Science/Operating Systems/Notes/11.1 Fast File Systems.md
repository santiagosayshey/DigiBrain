> [!motivation] File System Design
> Traditional Unix file systems treated disk drives like random-access memory, leading to significant performance issues as storage technologies evolved. Disk drives achieve optimal performance with sequential access patterns, performing 50-100 times faster than random access operations. The mechanical nature of disk drives introduces latency from head movements and rotational delays, making **data placement crucial for performance.**

> [!idea] Fast File System Structure
> FFS divides the disk into **cylinder groups** - each group being a sequence of consecutive disk blocks. This organization improves performance by reducing head movement and maintaining data locality.
> 
> **1. Cylinder Group Contents**
> As shown in the diagram, each cylinder group contains four main components:
> 
> - **Superblock**: Contains critical filesystem metadata
>   - Total number of blocks and inodes
>   - Block and fragment sizes
>   - Free block counts
> - **Inode Blocks**: Array of inodes storing file metadata
> - **Data Blocks**: The actual file contents
> - **Bitmap**: Tracks which blocks and inodes are free/used
> 
> ![[Pasted image 20241031065044.png|500]]
> 
> **2. Block Management System**:
> FFS uses two block sizes for efficient storage:
> 
> | Block Type | Typical Size | Usage Pattern |
> |------------|--------------|---------------|
> | Full Block | 4-8KB | Large files, directories |
> | Fragment | 512B-1KB | Small files, partial blocks |
> 
> **3. Index Structure**:
> The index structure revolves around inodes, which store file metadata. Each inode contains:
> - Direct block pointers for immediate data access
> - Single indirect pointers for medium-sized files
> - Double and triple indirect pointers for large files
> 
> FFS places inodes strategically within their cylinder groups, maintaining proximity to their associated data blocks. This placement strategy reduces seek times during file access operations.


> [!idea] FFS Implementation
> The FFS implementation enhances performance through strategic data organization and resource management. The superblock contains critical file system metadata, replicated across cylinder groups for reliability. Unlike traditional systems that use linked lists, FFS employs a bitmap in each cylinder group to track free blocks, enabling efficient space allocation.
> 
> **Cylinder Group Organization**:
> Each cylinder group maintains its own resource tracking and contains:
> 
> The superblock copy stores vital file system information:
> - Block and fragment size parameters
> - Total blocks and free blocks count
> - Inode allocation information
> - File system state flags
> 
> The inode table region holds file metadata entries:
> - Static allocation of 1% of total group space
> - Sequential inode numbering within groups
> - Pre-allocation strategy for future growth

> [!idea] Block Placement Strategy
> FFS employs sophisticated block placement algorithms to maximize disk performance. When allocating blocks for new files, the system attempts to preserve both spatial and temporal locality. 
> 
> **Directory Placement**:
> The system places new directories in cylinder groups based on:
> - Available free space above the group's mean
> - Number of existing directories below mean
> - Physical distance from parent directory's group
> 
> **File Block Allocation**:
> For regular files, FFS allocates blocks using a multi-tiered strategy:
> - First data block placement determines the file's "home" group
> - Subsequent blocks are allocated within the same group when possible
> - Large files receive blocks across multiple groups after exceeding the per-group quota
> - System maintains a rotational layout table for optimal block positioning

> [!example] FFS Operations
> Consider a file system with 4KB blocks and 512-byte fragments. When creating a new 6KB text file in /home/user/documents:
> 
> 1. Directory Operation:
> The system first locates the documents directory inode in its home group. The directory entry for the new file requires a block modification to add:
> - File name
> - Inode number
> - File type
> 
> 2. Resource Allocation:
> The file requires:
> - One complete block (4KB)
> - Four fragments (2KB)
> - One inode from the cylinder group
> 
> 3. Block Layout:
> ```
> Block 0: First 4KB of file data
> Fragments 0-3: Remaining 2KB of data
>   Fragment 0: 512 bytes
>   Fragment 1: 512 bytes
>   Fragment 2: 512 bytes
>   Fragment 3: 512 bytes (partially used)
> ```

> [!consider] Performance Implications
> The FFS design introduces several performance trade-offs that affect system behavior. The block size selection impacts both performance and space efficiency. Larger blocks improve sequential read performance but may increase internal fragmentation for small files.
> 
> **Space Management Considerations**:
> The fragment implementation addresses space efficiency:
> - Reduces internal fragmentation for small files
> - Increases management complexity
> - Requires additional metadata tracking
> 
> **Load Balancing Effects**:
> Cylinder group management affects overall system performance:
> - Groups maintain independent free block counts
> - Directory spreading prevents hot spots
> - Large file block spreading may increase seek times
> 
> **System Aging Impact**:
> As the file system ages, several factors affect performance:
> - Fragment free space becomes scattered
> - Directory structures grow and spread
> - Large files may experience increased fragmentation
> 
> The system implements several strategies to combat aging:
> - Regular block reallocation during quiet periods
> - Maintaining free space reserves in each group
> - Background optimization of file block layouts


