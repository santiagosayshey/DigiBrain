

> [!idea] Compare-and-Swap (CAS)
> Compare-and-Swap is a more versatile atomic operation than Test-and-Set, offering additional capabilities and benefits.
> 
> **How CAS works:**
> 1. **Compare:** Check if a memory location contains an expected value
> 2. **Swap:** If the comparison succeeds, update the memory location with a new value
> 3. **Atomic:** The entire operation is performed as a single, indivisible unit
> 
> **CAS operation signature:**
> ```c
> bool compare_and_swap(int *addr, int expected, int new_value);
> ```
> 
> **Key differences from Test-and-Set:**
> - **Conditional update:** CAS only modifies the memory if it matches an expected value
> - **Flexibility:** Can be used to implement a wider range of lock-free and wait-free algorithms
> - **ABA problem awareness:** Returns the actual value, allowing detection of ABA scenarios
> 
> **Example implementation of a spin lock using CAS:**
> ```c
> typedef struct {
>     int flag; // 0: unlocked, 1: locked
> } lock_t;
> 
> void acquire_lock(lock_t *lock) {
>     while (!compare_and_swap(&lock->flag, 0, 1)) {
>         // Busy-wait (spin)
>     }
> }
> 
> void release_lock(lock_t *lock) {
>     lock->flag = 0;
> }
> ```


> [!example] Compare-and-Swap in Action
> Let's consider a scenario with two threads trying to increment a shared counter using CAS.
> 
> **Shared state:**
> ```c
> int counter = 5;  // Initial value
> ```
> 
> **CAS-based increment function:**
> ```c
> bool increment_counter(int* addr) {
>     int old_value = *addr;
>     int new_value = old_value + 1;
>     return compare_and_swap(addr, old_value, new_value);
> }
> ```
> 
> **Scenario:**
> ```
> Time  Thread A                      Thread B                      counter
> ────  ────────────────────────────  ────────────────────────────  ───────
>  t1   read counter (5)
>  t2   calculate new_value (6)
>  t3                                 read counter (5)
>  t4                                 calculate new_value (6)
>  t5   CAS(counter, 5, 6) -> true                                  6
>  t6                                 CAS(counter, 5, 6) -> false   6
>  t7                                 read counter (6)
>  t8                                 calculate new_value (7)
>  t9                                 CAS(counter, 6, 7) -> true    7
> ```
> 
> **Explanation:**
> 1. Both threads read the initial value (5) and calculate the new value (6).
> 2. Thread A successfully performs CAS, updating the counter to 6.
> 3. Thread B's CAS fails because the counter is no longer 5.
> 4. Thread B retries, reading the new value (6), calculating 7, and successfully updating.
> 
> This example demonstrates how CAS:
> - Ensures atomic updates
> - Handles contention without explicit locking
> - Allows threads to detect and react to concurrent modifications

> [!consider] CAS vs. Test-and-Set in This Scenario
> If we used Test-and-Set for this counter increment:
> - We'd need to implement a lock around the counter
> - Only one thread could access the counter at a time
> - The operation would be less efficient, especially under low contention
> 
> CAS allows for lock-free updates, potentially improving performance and scalability in scenarios like this shared counter.

