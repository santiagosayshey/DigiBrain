> [!example] Dining Lawyers Problem
> Five lawyers sit around a circular table, each with a plate of spaghetti and a single fork between each pair of lawyers. To eat, a lawyer needs two forks.
> 
> ![[Pasted image 20240910050914.png|400]]
> 
> The problem unfolds as follows:
> 1. Each lawyer follows this routine:
>    - Think (don't need forks)
>    - Pick up left fork
>    - Pick up right fork
>    - Eat
>    - Put down right fork
>    - Put down left fork
> 
> 2. Deadlock scenario:
>    - If all lawyers simultaneously pick up their left forks, none can pick up their right forks.
>    - All lawyers are now holding one fork and waiting for another, creating a circular wait.
> 
> 3. This demonstrates all four conditions for deadlock:
>    - **Mutual Exclusion**: Only one lawyer can use a fork at a time.
>    - **Hold and Wait**: Lawyers hold one resource (left fork) while waiting for another (right fork).
>    - **No Preemption**: Forks cannot be forcibly taken from lawyers.
>    - **Circular Wait**: Each lawyer is waiting for the fork held by the next lawyer.
> 
> Possible solutions:
> - Allow only four lawyers to sit at the table at once.
> - Instruct an odd-numbered lawyer to pick up the right fork first, then the left.
> - Use a semaphore to limit the number of lawyers who can simultaneously attempt to pick up forks.

> [!idea] Deadlock
> A deadlock is a concurrent systems problem where **two or more processes are unable to proceed because each is waiting for the other to release a resource.**
> 
> Key characteristics of a deadlock:
> - **Mutual Exclusion**: A resource is exclusively owned by a single process.
> - **Hold and Wait**: A process must be holding at least one resource while waiting to acquire additional resources held by other processes.
> - **No Preemption**: Resources cannot be forcibly taken away; they must be released voluntarily by the process holding them.
> - **Circular Wait**: A circular chain of two or more processes, each waiting for a resource held by the next process in the chain.
> 
> **Key Idea**: If you remove any one of these characteristics, you remove the deadlock!

> [!example] Factorio Trains Deadlock
> Consider our Factorio railway system from before. If we add 1 more train to the network, we experience a deadlock. Each train is trying to move to a station that is mutually blocked by another train. A train in the top left is trying to get to the bottom right, but cant because a train is there. That train is trying to get to the bottom left, because there is a train there also!
> 
> ![[Pasted image 20240910050428.png]]
> 
> 
> This scenario mirrors the deadlock conditions:
> 1. **Mutual Exclusion**: Each track segment can only be used by one train at a time.
> 2. **Hold and Wait**: Each train holds one track while waiting for the other.
> 3. **No Preemption**: Trains can't be forcibly removed from tracks.
> 4. **Circular Wait**: Train A-B is waiting for Train C-D, which is waiting for Train A-B.


> [!example] Deadlock in Code
> Here's a simple example of a deadlock scenario in Python using threads and locks:
> 
> ```python
> import threading
> import time
> 
> # Create two locks
> lock1 = threading.Lock()
> lock2 = threading.Lock()
> 
> def thread1_function():
>     print("Thread 1 starting...")
>     lock1.acquire()
>     print("Thread 1 acquired lock1")
>     time.sleep(1)  # Simulate some work
>     # DEADLOCK: Thread 1 tries to acquire lock2 while holding lock1
>     lock2.acquire()
>     print("Thread 1 acquired lock2")
>     lock2.release()
>     lock1.release()
> 
> def thread2_function():
>     print("Thread 2 starting...")
>     lock2.acquire()
>     print("Thread 2 acquired lock2")
>     time.sleep(1)  # Simulate some work
>     # DEADLOCK: Thread 2 tries to acquire lock1 while holding lock2
>     lock1.acquire()
>     print("Thread 2 acquired lock1")
>     lock1.release()
>     lock2.release()
> 
> # Create and start the threads
> thread1 = threading.Thread(target=thread1_function)
> thread2 = threading.Thread(target=thread2_function)
> 
> thread1.start()
> thread2.start()
> 
> # Wait for the threads to finish
> thread1.join()
> thread2.join()
> 
> print("Program finished")
> ```
> 
> This code demonstrates a classic deadlock scenario:
> 
> 1. **Thread 1** acquires `lock1`, then tries to acquire `lock2`.
> 2. **Thread 2** acquires `lock2`, then tries to acquire `lock1`.
> 3. Both threads are now waiting for a lock held by the other, creating a circular wait.
> 
> The program will hang indefinitely, as neither thread can proceed. This exemplifies all four conditions for deadlock:
> - **Mutual Exclusion**: The locks are held exclusively.
> - **Hold and Wait**: Each thread holds one lock while waiting for another.
> - **No Preemption**: Locks cannot be forcibly released.
> - **Circular Wait**: Each thread is waiting for a resource held by the other.
> 
> To prevent this deadlock, you could:
> - Ensure a consistent order of lock acquisition (e.g., always acquire `lock1` before `lock2`).
> - Use a timeout when acquiring locks.
> - Implement a deadlock detection algorithm.

> [!idea] Wait-Free Algorithms
> Wait-free algorithms are a **concurrent programming technique** that ensures every operation can complete in a finite number of steps, regardless of the actions of other threads.
> 
> Key characteristics:
> - **Progress Guarantee**: Every thread makes progress in a finite number of steps, regardless of other threads' actions.
> - **Non-Blocking**: No thread can be prevented from making progress by the failure or suspension of other threads.
> - **Bounded Time**: Operations complete within a bounded number of steps.
> 
> Benefits:
> - **Deadlock Prevention**: By design, wait-free algorithms eliminate the possibility of deadlocks.
> - **Improved Responsiveness**: Ensures that all threads make progress, enhancing system responsiveness.
> - **Fault Tolerance**: System continues to function even if some threads fail or are delayed indefinitely.
> 
> Implementation Challenges:
> - **Complexity**: Often more complex to design and implement than lock-based algorithms.
> - **Performance Overhead**: May introduce some performance overhead in low-contention scenarios.
> 
> Common Techniques:
> - **Atomic Operations**: Utilize hardware-supported atomic operations (e.g., Compare-and-Swap).
> - **Helping Mechanism**: Threads may help complete other threads' operations.
> - **Version Counters**: Use version numbers to detect and handle conflicts.
> 
> While not suitable for all scenarios, wait-free algorithms provide a powerful tool for creating robust, deadlock-free concurrent systems in critical applications where progress guarantees are essential.
