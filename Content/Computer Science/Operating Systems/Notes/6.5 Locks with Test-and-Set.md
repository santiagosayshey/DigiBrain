
> [!motivation] The Need for Hardware-Supported Atomic Operations
> While software-based solutions like Peterson's algorithm are theoretically sound, they face practical limitations:
> 
> - **Complexity:** Difficult to extend to more than two threads
> - **Performance:** Often slower than hardware-supported alternatives
> - **Portability:** May behave incorrectly on modern processors due to memory reordering
> 
> These limitations led to the widespread adoption of hardware-supported atomic operations for implementing efficient and scalable locks.

> [!idea] Test-and-Set Locks
> Test-and-Set locks use **hardware-supported atomic operations** to implement mutual exclusion efficiently.
> 
> **Key concepts:**
> - **Atomic operation:** Performs read-modify-write as a single, uninterruptible unit
> - **Lock state:** Represented by a single memory location (typically a boolean or integer)
> 
> **How it works:**
> 1. **Test:** Check if the lock is free (typically 0 or false)
> 2. **Set:** If free, set it to locked state (typically 1 or true)
> 3. **Atomic:** Both steps occur in a single, indivisible operation
> 
> **Common implementations:**
> - **Test-and-Set instruction:** Directly supported on some architectures
> - **XCHG (Exchange) instruction:** Used on x86 architectures, effectively achieving the same result
> 
> **Basic structure:**
> ```c
> typedef struct {
>     int flag; // 0: unlocked, 1: locked
> } lock_t;
> 
> void acquire_lock(lock_t *lock) {
>     while (test_and_set(&lock->flag) == 1) {
>         // Busy-wait (spin)
>     }
> }
> 
> void release_lock(lock_t *lock) {
>     lock->flag = 0;
> }
> ```

> [!example] Test-and-Set Lock in Action
> Consider two threads, A and B, competing for a lock:
> 
> 1. Initially, `lock->flag = 0` (unlocked)
> 2. Thread A performs test-and-set:
>    - Atomically reads 0 and sets `lock->flag` to 1
>    - A acquires the lock and enters the critical section
> 3. Thread B performs test-and-set:
>    - Atomically reads 1 and sets `lock->flag` to 1 (no change)
>    - B spins, repeatedly trying test-and-set
> 4. Thread A releases the lock by setting `lock->flag` to 0
> 5. Thread B's next test-and-set succeeds, acquiring the lock
> 
> ```
> Time  Thread A              Thread B              lock->flag
> ────  ───────────────────   ───────────────────   ───────────
>  t1   test-and-set() -> 0                         1
>  t2   [Critical Section]
>  t3                         test-and-set() -> 1   1
>  t4                         [Spin]                1
>  t5   [Exit]
>  t6   flag = 0                                    0
>  t7                         test-and-set() -> 0   1
>  t8                         [Critical Section]    1
> ```

> [!consider] Implications of Test-and-Set Locks
> **Advantages:**
> - **Simplicity:** Easy to implement and understand
> - **Efficiency:** Hardware-supported, faster than software-only solutions
> - **Portability:** Supported on most modern architectures
> 
> **Limitations:**
> - **Busy-waiting:** Spinning consumes CPU cycles
> - **Scalability:** Can lead to high contention on multi-core systems
> - **Fairness:** No guarantee of fair scheduling among waiting threads
> 
> **Further considerations:**
> - Test-and-Set locks form the basis for more sophisticated locking mechanisms
> - Understanding these fundamentals is crucial for developing efficient concurrent systems
