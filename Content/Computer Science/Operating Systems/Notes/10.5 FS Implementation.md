> [!motivation] Implementing File Systems
> File systems need to efficiently:
> - Represent files and directories as data structures
> - Provide methods for file access (read, write)
> - Map logical file structures to physical disk blocks
> - Handle file growth and manage fragmentation

> [!idea] Disk Structures
> - Disks are represented as a large array of blocks
> - Files are abstracted entities that need to be mapped to these blocks
> - We need a structure to map files to disk blocks
> - This is similar to memory abstraction in operating systems
> 
> ```
> Disk blocks:
> +----+----+----+----+----+----+----+----+
> | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |  ...
> +----+----+----+----+----+----+----+----+
> 
> File abstractions:
> [File 1]   [File 2]   [File 3]
> 
> Mapping:
> [File 1] ---> Blocks 0, 1, 2
> [File 2] ---> Blocks 4, 5
> [File 3] ---> Blocks 7, 8, 9, 10
> ```
> 
> Previous approaches to file allocation:
> - Contiguous allocation
> - Extend based allocation
> - Linked allocation
> - File allocation tables
> - Indexed allocation
> - Multi level index
> 
> Key considerations:
> - Managing fragmentation
> - Accommodating file growth

> [!consider] Contiguous Allocation
> ```
> Disk blocks:
> +----+----+----+----+----+----+----+----+----+----+
> | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  |
> +----+----+----+----+----+----+----+----+----+----+
> |<-File 1->|<--File 2-->|<----File 3---->|  Free  |
> ```
> 
> Advantages:
> - Simple implementation
> - Excellent read performance (sequential access)
> - Minimal disk seeks for large files
> 
> Disadvantages:
> - Leads to external fragmentation
> - Difficult to accommodate file growth
> - Requires accurate size prediction or frequent reallocation