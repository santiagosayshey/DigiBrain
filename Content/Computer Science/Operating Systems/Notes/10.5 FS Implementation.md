> [!motivation] How do we implement file systems?
> File systems are a crucial component of operating systems, but how exactly are they implemented? To understand this, we need to explore:
> - The **data structures used to represent files and directories** 
> - The **methods** for accessing files, such as **reading and writing**

> [!idea] Disk structures for file systems
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 |
> |---------|---------|---------|---------|---------|---------|---------|---------|
> | File A  | File A  | File B  | File B  | File C  | File C  | Free    | Free    |
>
> - Disks are divided into a large array of blocks
> - We need a structure to map files to these blocks 
> - This is similar to memory abstraction
>   - In the past, we've used contiguous, extend-based, linked, file allocation tables, indexed, and multi-level index approaches
>   - Fragmentation and file growth are important considerations

> [!consider] Contiguous allocation with extents
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 |
> |---------|---------|---------|---------|---------|---------|---------|---------|
> | File A  | File A  | File A  | File A  | Free    | Extent  | Free    | Free    |
>
> - **Contiguous allocation** assigns consecutive disk blocks to a file.
> - **Extents**: In some systems, a small number of contiguous blocks (like Block 5 in the diagram) can be allocated as **extents**.
>   - Extents provide extra blocks to allow the file to grow without relocating it entirely.
>   - This minimizes fragmentation and allows space for file growth.
> - **Advantages**:
>   - Simple to implement.
>   - Good performance due to sequential access.
> - **Disadvantages**:
>   - Suffers from external fragmentation.
>   - Difficult to predict file growth and allocate appropriate space.

> [!consider] Linked allocation
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 |
> |---------|---------|---------|---------|---------|---------|---------|---------|
> | File A  | Next: 3 | File B  | Next: 6 | Free    | File B  | Next: 7 | File A  |
> 
> - **File A** occupies Block 0 and Block 7, with pointers leading from Block 0 to Block 3, then to Block 7.
> - **File B** occupies Block 2, Block 5, and Block 6, with pointers leading from Block 2 to Block 6, and then to Block 5.
> - **No external fragmentation** as blocks for files can be scattered anywhere.
> - **Internal fragmentation** occurs due to wasted space for storing pointers.
> - **Grows easily** by adding blocks to the list.
> - **Disadvantage**: Every block requires a pointer to the next block, wasting space.

> [!consider] File Allocation Table (FAT)
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 |
> |---------|---------|---------|---------|---------|---------|---------|---------|
> | File A  | Free    | File B  | File A  | Free    | File B  | File B  | File A  |
> | Next: 3 | -       | Next: 6 | Next: 7 | -       | Next: 5 | End     | End     |
> 
> - **File A** occupies Block 0, Block 3, and Block 7. The FAT stores the pointers linking Block 0 to Block 3, and then Block 7.
> - **File B** occupies Block 2, Block 6, and Block 5. The FAT stores pointers linking Block 2 to Block 6, and then to Block 5.
> - **Difference**: The pointers are stored in the FAT table, not in the blocks themselves, simplifying management.
> - **Disadvantage**: The FAT can grow large, consuming memory.
