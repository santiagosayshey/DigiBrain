> [!motivation] How do we implement file systems?
> File systems are a crucial component of operating systems, but how exactly are they implemented? To understand this, we need to explore:
> - The **data structures used to represent files and directories** 
> - The **methods** for accessing files, such as **reading and writing**

> [!idea] Disk structures for file systems
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 |
> |---------|---------|---------|---------|---------|---------|---------|---------|
> | File A  | File A  | File B  | File B  | File C  | File C  | Free    | Free    |
>
> - Disks are divided into a large array of blocks
> - We need a structure to map files to these blocks 
> - This is similar to memory abstraction
>   - In the past, we've used contiguous, extend-based, linked, file allocation tables, indexed, and multi-level index approaches
>   - Fragmentation and file growth are important considerations

> [!consider] Contiguous allocation
> | Block 0 | Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | 
> |---------|---------|---------|---------|---------|---------|
> | File A  | File A  | File A  | File A  | Free    | Free    |
>  
> - Contiguous allocation assigns consecutive disk blocks to a file
> - Advantages:  
>   - Simple to implement
>   - Good performance due to sequential access
> - Disadvantages:
>   - Suffers from external fragmentation 
>   - Difficult to predict file growth and allocate appropriate space
