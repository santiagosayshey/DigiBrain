> [!motivation] Motivation
> In multithreaded programs, **locks solve mutual exclusion and race conditions** by ensuring that only one thread can access a shared resource at a time. However, locks alone **do not address the need for specific ordering of thread execution**. 
> 
> Consider a scenario where we want **process B to run only after process A has completed a certain task**. This requires a mechanism to **allow threads to signal each other and wait for specific conditions** to be met before proceeding.
> 
> Condition variables and semaphores provide a solution to this problem of thread synchronization and ordering.

> [!idea] Condition Variables
> A condition variable is a synchronization primitive that **allows threads to wait for a specific condition to be met before continuing execution**. It is always used in conjunction with a mutex lock.
> 
> - Threads can wait on a condition variable, effectively putting themselves to sleep until they are awakened by another thread.
> - When a thread modifies the shared state in a way that might satisfy the condition, it can signal or broadcast the condition variable to wake up waiting threads.
> - Upon being awakened, the waiting threads reacquire the associated mutex lock and recheck the condition to ensure it is truly met before proceeding.

> [!example] Example: Producer-Consumer Problem
> Let's consider the classic producer-consumer problem, where one thread (the producer) generates data and another thread (the consumer) processes that data. The consumer must wait until the producer has generated data before it can proceed.
> 
> ```c
> shared_queue = []
> mutex = new_mutex()
> cond_var = new_condition_variable()
> 
> function producer():
>     while true:
>         new_item = produce_item()
>         mutex.lock()
>         shared_queue.append(new_item)
>         mutex.unlock()
>         cond_var.signal()
> 
> function consumer():
>     while true:
>         mutex.lock()
>         while shared_queue.empty():
>             cond_var.wait(mutex)
>         item = shared_queue.pop(0)
>         mutex.unlock()
>         consume_item(item)
> ```
> 
> In this example:
> 1. The `producer` thread generates an item, acquires the mutex lock, adds the item to the shared queue, releases the lock, and signals the condition variable to indicate that new data is available.
> 2. The `consumer` thread acquires the mutex lock and checks if the shared queue is empty. If it is, the thread waits on the condition variable, automatically releasing the mutex lock.
> 3. When the `producer` signals the condition variable, the `consumer` thread is awakened. It reacquires the mutex lock, ensures the queue is not empty (to handle spurious wakeups), retrieves an item from the queue, releases the lock, and processes the item.
> 
> This synchronization ensures that the `consumer` thread only proceeds when there is data available in the shared queue, and it avoids race conditions by protecting access to the shared queue with a mutex lock.

> [!idea] Signal and Wait Operations
> The `signal` and `wait` operations are fundamental to working with condition variables. They allow threads to communicate and synchronize their execution based on specific conditions.
> 
> - `wait(mutex)`: When a thread calls `wait` on a condition variable, it automatically releases the associated mutex lock and puts itself to sleep, waiting to be awakened by another thread. Once awakened, the thread reacquires the mutex lock before returning from the `wait` function.
>   - The `wait` operation is typically used in a loop to recheck the condition after being awakened, as spurious wakeups can occur.
> 
> - `signal()`: When a thread calls `signal` on a condition variable, it wakes up one of the threads waiting on that condition variable (if any). The awakened thread then competes to reacquire the mutex lock and checks the condition again.
>   - If multiple threads are waiting on the same condition variable, the choice of which thread to wake up is determined by the thread scheduler and is implementation-dependent.
> 
> - `broadcast()`: Similar to `signal`, but it wakes up all the threads waiting on the condition variable instead of just one.
>   - This is useful when multiple threads may be waiting for the same condition, and all of them should be awakened to check the condition and proceed if it is met.
> 
> It's important to note that the `signal` and `broadcast` operations do not immediately give up the mutex lock. The signaling thread continues to hold the lock until it explicitly releases it, ensuring that the awakened thread(s) do not proceed until the signaling thread has completed its critical section.