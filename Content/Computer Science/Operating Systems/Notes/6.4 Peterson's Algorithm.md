> [!motivation] The Problem with Simple Flag-Based Locks
> **Simple flag-based locks can suffer from race conditions** when multiple threads attempt to enter a critical section simultaneously. This occurs because:
> - Reading and setting the flag may not be atomic operations
> - Changes to the flag might not be immediately visible to all threads
> - There's no guaranteed fairness in lock acquisition

> [!idea] Peterson's Algorithm
> Peterson's algorithm is a software-based solution for **mutual exclusion between two threads**, addressing the shortcomings of simple flag-based locks.
> 
> **Key components:**
> - Two flag variables (`flag[0]` and `flag[1]`), one for each thread
> - A turn variable to indicate which thread has priority
> 
> **How it works:**
> 1. A thread sets its own flag to indicate interest in entering the critical section
> 2. It then sets the turn to the other thread's id
> 3. The thread waits until either the other thread is not interested (flag is false) or it's not the other thread's turn
> 
> ```c
> // Pseudocode for Thread i (where i is 0 or 1)
> flag[i] = true;
> turn = 1 - i;
> while (flag[1-i] == true && turn == 1-i) {
>     // Wait
> }
> // Enter critical section
> ```

> [!example] Peterson's Algorithm in Action
> Consider two threads, A and B, trying to enter a critical section:
> 
> 1. Thread A sets `flag[A] = true` and `turn = B`
> 2. Thread B sets `flag[B] = true` and `turn = A`
> 3. Both threads check the while condition:
>    - A sees `flag[B] == true` but `turn == A`, so it enters
>    - B sees `flag[A] == true` and `turn == A`, so it waits
> 4. Thread A completes and sets `flag[A] = false`
> 5. Thread B can now enter the critical section
> 
> ```image_goes_here
> A diagram showing two timelines, one for Thread A and one for Thread B, illustrating the sequence of events described above. Each step should be clearly labeled, showing the state changes of flags and the turn variable.
> ```

> [!consider] Advantages and Limitations of Peterson's Algorithm
> **Advantages:**
> - Ensures mutual exclusion without hardware support
> - Provides a fair solution (no thread can be indefinitely prevented from entering)
> - Solves the race condition issues of simple flag-based locks
> 
> **Limitations:**
> - Limited to two threads (though it can be extended for more)
> - Relies on busy-waiting, which can be inefficient
> - Assumes sequential consistency memory model, which may not hold on modern architectures without proper memory barriers