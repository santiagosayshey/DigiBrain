> [!motivation] The Problem with Simple Flag-Based Locks
> **Simple flag-based locks can suffer from race conditions** when multiple threads attempt to enter a critical section simultaneously. This occurs because:
> - Reading and setting the flag may not be atomic operations
> - Changes to the flag might not be immediately visible to all threads
> - There's no guaranteed fairness in lock acquisition
You're absolutely right, and I apologize for the oversight. Let's revise both the idea and example callouts to incorporate this key information more clearly:

> [!idea] Peterson's Algorithm
> Peterson's algorithm is a software-based solution for **mutual exclusion between two threads**, addressing the shortcomings of simple flag-based locks.
> 
> **Key components:**
> - Two flag variables (`flag[0]` and `flag[1]`), one for each thread
> - A turn variable to indicate which thread should yield if there's contention
> 
> **How it works:**
> 1. A thread sets its own flag to indicate interest in entering the critical section
> 2. It then sets the turn to the **other** thread's id, effectively giving up priority
> 3. The thread waits if the other thread is interested (flag is true) **and** it's the other thread's turn
> 
> ```c
> // Pseudocode for Thread i (where i is 0 or 1)
> flag[i] = true;
> turn = 1 - i;  // Set turn to the other thread
> while (flag[1-i] == true && turn == 1-i) {
>     // Wait
> }
> // Enter critical section
> ```
> 
> **Key insight:** Setting the turn to the other thread's id is crucial for fairness and preventing monopoly.

> [!example] Peterson's Algorithm in Action
> Consider two threads, A and B, trying to enter a critical section:
> 
> 1. Thread A sets `flag[A] = true` and `turn = B`
> 2. Thread B sets `flag[B] = true` and `turn = A`
> 3. Both threads check the while condition:
>    - A sees `flag[B] == true` but `turn == A`, so it enters (B gave it priority)
>    - B sees `flag[A] == true` and `turn == A`, so it waits (it gave A priority)
> 4. Thread A completes and sets `flag[A] = false`
> 5. Thread B can now enter the critical section
> 
> ```
> Time  Thread A                 Thread B                 Variables
> ────  ────────────────────────  ────────────────────────  ────────────────────
>  t1   flag[A] = true
>  t2   turn = B                                           flag[A]=T, turn=B
>  t3                             flag[B] = true           flag[A]=T, flag[B]=T
>  t4                             turn = A                 turn=A
>  t5   while(flag[B] && turn==B) 
>      → Enter critical section
>  t6                             while(flag[A] && turn==A)
>                                → Wait
>  t7   [Critical Section]
>  t8   flag[A] = false                                    flag[A]=F, flag[B]=T
>  t9                             → Enter critical section
> t10                             [Critical Section]
> t11                             flag[B] = false          flag[A]=F, flag[B]=F
> ```
> 
> **Key observation:** The last thread to set the turn variable effectively yields priority, ensuring fairness.


> [!consider] Advantages and Limitations of Peterson's Algorithm
> **Advantages:**
> - Ensures mutual exclusion without hardware support
> - Provides a fair solution (no thread can be indefinitely prevented from entering)
> - Solves the race condition issues of simple flag-based locks
> 
> **Limitations:**
> - Limited to two threads (though it can be extended for more)
> - Relies on busy-waiting, which can be inefficient
> - Assumes sequential consistency memory model, which may not hold on modern architectures without proper memory barriers