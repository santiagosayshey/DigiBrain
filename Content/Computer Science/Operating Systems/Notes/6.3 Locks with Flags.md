> [!idea]+ Implementing Locks with Load and Store Instructions
> A more common and flexible approach to implementing locks is using load and store instructions, also known as locks with flags. This method relies on special atomic instructions provided by the processor to ensure mutual exclusion. Here's how it works:
>
> 1. **A lock is represented by a flag variable, typically an integer, which is initially set to 0 (unlocked state).**
> 2. When a thread wants to acquire the lock, it performs an atomic "test and set" operation on the flag variable. This operation atomically **reads the current value of the flag and sets it to 1 (locked state) in a single, indivisible step.**
> 3. If the previous value of the flag was 0, it means the lock was previously unlocked, and the thread successfully acquires the lock and enters the critical section.
> 4. If the previous value of the flag was already 1, it means another thread already holds the lock, and the current thread must wait (either by busy-waiting or blocking) until the lock becomes available.
> 5. When a thread exits the critical section, it atomically sets the flag back to 0 (unlocked state) using a store instruction, allowing other threads to acquire the lock.
>
> Here's some C pseudocode to illustrate this concept:
>
> ```c
> typedef struct {
>     int flag;  // 0 = unlocked, 1 = locked
> } lock_t;
>
> // Assume this function exists and performs an atomic test-and-set operation
> int test_and_set(int* target);
>
> void acquire_lock(lock_t* lock) {
>     while (test_and_set(&lock->flag) == 1) {
>         ; // Busy-wait (spin) while the lock is held by another thread
>     }
>     // Lock acquired, enter critical section
> }
>
> void release_lock(lock_t* lock) {
>     lock->flag = 0;  // Release the lock
> }
>
> // Usage
> lock_t my_lock = {0};  // Initialize lock
> acquire_lock(&my_lock);
> // Perform critical section operations
> release_lock(&my_lock);
> ```

> [!consider] Race Conditions in Flag-Based Locks
> While locks with flags seem straightforward, they can be **vulnerable to race conditions if not implemented correctly**. Here's why:
>
> - **Non-atomic operations**: If the check and set operations on the flag are not performed atomically, race conditions can occur.
>   - Thread A reads the flag (unlocked)
>   - Thread B also reads the flag (still unlocked)
>   - Both threads think they can enter the critical section
>   - Thread A sets the flag
>   - Thread B also sets the flag
>   - Both threads enter the critical section simultaneously
>
> - **Memory visibility**: Without proper memory barriers or volatile declarations, changes to the flag might not be immediately visible to other threads due to CPU caching or compiler optimizations.
>
> - **Priority inversion**: In a busy-wait scenario, a high-priority thread might be stuck waiting for a low-priority thread to release the lock, leading to priority inversion.


