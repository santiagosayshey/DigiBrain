> [!motivation] Implementing Concurrency with Locks
> With locks, we now have a way to safely and efficiently implement concurrency in our programs. Locks allow us to ensure mutual exclusion and protect critical sections, preventing race conditions and maintaining data consistency. But **how exactly do we implement locks?**

> [!idea] Implementing Locks with Interrupts
> One approach to implementing locks is by using interrupts. The basic idea is to **disable interrupts during the critical sections of lock acquisition and release**. Here's how it works:
>
> 1. When a thread wants to acquire a lock, it disables interrupts.
> 2. The thread then checks if the lock is available. If it is, the thread acquires the lock and enters the critical section.
> 3. While in the critical section, interrupts remain disabled, ensuring that no other thread can interrupt the current thread.
> 4. When the thread exits the critical section, it releases the lock and re-enables interrupts.
>
> Advantages of using interrupts for locks:
> - Simple implementation: Disabling and enabling interrupts is a straightforward mechanism.
> - Guaranteed mutual exclusion: By disabling interrupts, no other thread can preempt the current thread during the critical section.
>
> Disadvantages of using interrupts for locks:
> - Limited to uniprocessor systems: Interrupt-based locks are only effective on uniprocessor systems. In multiprocessor systems, disabling interrupts on one processor does not prevent threads on other processors from accessing shared resources.
> - Processor monopolization: While interrupts are disabled, the thread holding the lock monopolizes the processor, preventing other threads from executing, even for non-critical tasks.
> - Inability to perform other necessary work: Disabling interrupts blocks not only other threads but also important system tasks and interrupt handlers, which can impact overall system responsiveness and performance.

