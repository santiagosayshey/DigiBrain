> [!motivation] Implementing Concurrency with Locks
> With locks, we now have a way to safely and efficiently implement concurrency in our programs. Locks allow us to ensure mutual exclusion and protect critical sections, preventing race conditions and maintaining data consistency. But **how exactly do we implement locks?**

> [!idea] Implementing Locks with Interrupts
> One approach to implementing locks is by using interrupts. The basic idea is to **disable interrupts during the critical sections of lock acquisition and release**. Here's how it works:
>
> 1. When a thread wants to acquire a lock, it disables interrupts.
> 2. The thread then enters the critical section.
> 3. While in the critical section, interrupts remain disabled, ensuring that no other thread can interrupt the current thread.
> 4. When the thread exits the critical section, it re-enables interrupts.
>
> Here's some C pseudocode to illustrate this concept:
>
> ```c
> // Assume these functions exist
> void disable_interrupts();
> void enable_interrupts();
>
> void acquire_lock() {
>     disable_interrupts();
>     // Critical section starts here
> }
>
> void release_lock() {
>     // Critical section ends here
>     enable_interrupts();
> }
>
> // Usage
> acquire_lock();
> // Perform critical section operations
> release_lock();
> ```
>
> Advantages of using interrupts for locks:
> - Simple implementation: Disabling and enabling interrupts is a straightforward mechanism.
> - Guaranteed mutual exclusion: By disabling interrupts, no other thread can preempt the current thread during the critical section.
>
> Disadvantages of using interrupts for locks:
> - Limited to uniprocessor systems: Interrupt-based locks are only effective on uniprocessor systems.
> - Processor monopolization: While interrupts are disabled, the thread holding the lock monopolizes the processor.
> - Inability to perform other necessary work: Disabling interrupts blocks not only other threads but also important system tasks and interrupt handlers.

