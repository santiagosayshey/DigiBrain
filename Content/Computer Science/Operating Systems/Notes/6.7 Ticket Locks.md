
> [!motivation] The Need for Fair Locks
> Simple spin locks, while efficient, can lead to **unfairness and potential starvation**:
> - Threads might acquire the lock in an arbitrary order
> - Some threads could repeatedly acquire the lock, while others wait indefinitely
> - This unfairness can lead to unpredictable performance and responsiveness issues
> 
> Ticket locks provide a mechanism to ensure **fair ordering** in lock acquisition, addressing these concerns.

> [!example] Thread Starvation with Simple Spin Locks
> Consider a scenario with three threads (A, B, C) competing for a simple spin lock:
> ```
> Time  Thread A              Thread B              Thread C              lock->flag
> ────  ───────────────────   ───────────────────   ───────────────────   ───────────
>  t1   acquire() -> success                                              1
>  t2   [Critical Section]
>  t3                         acquire() -> fail                           1
>  t4                         [Spin]
>  t5                                               acquire() -> fail     1
>  t6                                               [Spin]
>  t7   release()                                                         0
>  t8   acquire() -> success                                              1
>  t9   [Critical Section]
> t10   release()                                                         0
> t11   acquire() -> success                                              1
> t12   [Critical Section]
> t13                         acquire() -> fail                           1
> t14                         [Spin]
> t15                                               acquire() -> fail     1
> t16                                               [Spin]
> t17   release()                                                         0
> t18   acquire() -> success                                              1
> ```
> 
> In this scenario:
> - Thread A repeatedly acquires the lock due to its proximity or scheduling luck
> - Threads B and C are stuck spinning, unable to acquire the lock
> - This pattern could theoretically continue indefinitely, starving B and C
> 
> **Key observations:**
> - No guaranteed order of acquisition
> - Fast threads or those with favorable scheduling can dominate lock acquisition
> - Some threads may face indefinite waiting (starvation)

> [!idea] Ticket Locks: Ensuring FIFO Ordering
> Ticket locks implement a first-in-first-out (FIFO) ordering for lock acquisition, similar to a deli counter system.
> 
> **Key components:**
> - `next_ticket`: Counter for assigning new ticket numbers
> - `now_serving`: Counter indicating the current ticket being served
> 
> **How it works:**
> 1. To acquire the lock, a thread atomically increments `next_ticket` and gets its ticket
> 2. The thread then waits until its ticket number equals `now_serving`
> 3. To release the lock, a thread increments `now_serving`
> 
> **Basic implementation:**
> ```c
> typedef struct {
>     atomic_int next_ticket;
>     atomic_int now_serving;
> } ticket_lock_t;
> 
> void ticket_lock_init(ticket_lock_t *lock) {
>     atomic_store(&lock->next_ticket, 0);
>     atomic_store(&lock->now_serving, 0);
> }
> 
> void ticket_lock_acquire(ticket_lock_t *lock) {
>     int my_ticket = atomic_fetch_add(&lock->next_ticket, 1);
>     while (atomic_load(&lock->now_serving) != my_ticket) {
>         // Busy-wait (could be optimized with pause or yield)
>     }
> }
> 
> void ticket_lock_release(ticket_lock_t *lock) {
>     atomic_fetch_add(&lock->now_serving, 1);
> }
> ```

> [!example] Ticket Lock in Action
> Consider three threads (A, B, C) trying to acquire a ticket lock:
> 
> ```
> Time  Thread A              Thread B              Thread C              next_ticket  now_serving
> ────  ───────────────────   ───────────────────   ───────────────────   ───────────  ───────────
>  t1   get_ticket() -> 0                                                 1            0
>  t2   [Enter critical]
>  t3                         get_ticket() -> 1                           2            0
>  t4                         [Wait]
>  t5                                               get_ticket() -> 2     3            0
>  t6                                               [Wait]
>  t7   [Exit]
>  t8   release()                                                         3            1
>  t9                         [Enter critical]                            3            1
> t10                         [Exit]
> t11                         release()                                   3            2
> t12                                               [Enter critical]      3            2
> ```
> 
> This example shows how ticket locks ensure FIFO ordering:
> - Threads acquire tickets in the order they arrive (A:0, B:1, C:2)
> - They enter the critical section in the same order, regardless of when they finish waiting

> [!consider] Advantages and Limitations of Ticket Locks
> **Advantages:**
> - **Fairness:** Guarantees FIFO ordering, preventing starvation
> - **Simplicity:** Relatively simple to implement and understand
> - **Scalability:** Works well for moderate contention scenarios
> 
> **Limitations:**
> - **Memory usage:** Requires two counters, which can wrap around for long-running systems
> - **Busy-waiting:** Still relies on spinning, which can waste CPU cycles
> - **Lack of adaptivity:** Doesn't adapt to different contention scenarios
> 
> **Considerations:**
> - Ticket locks are often used as a building block for more complex locking schemes
> - They can be combined with other techniques (e.g., exponential backoff) to reduce CPU usage during waiting
> - In practice, many systems use more sophisticated locks (e.g., queue-based locks) for high-contention scenarios
