


| Step                   | Action                                                                                                                                                                                  | Detailed Explanation                                                                                                                                                                                                                                                                                                                                                                                             |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. User Registration   | X: New user generates a public-private key pair locally.<br><br>Y: User broadcasts their public key and chosen username to the network.                                                 | The user's device generates an asymmetric key pair using a secure algorithm (e.g., RSA or ECC). The private key is securely stored on the device, never shared. The public key becomes the user's identity.<br><br>The user chooses a username and creates a signed message containing the username and public key. This message is sent to several known nodes in the network, which then propagate it further. |
| 2. Network Integration | X: User's information is stored in the Distributed Hash Table (DHT).<br><br>Y: Other nodes update their routing tables to include the new user.                                         | The network uses a DHT algorithm (e.g., Kademlia) to determine which nodes should store the new user's information. The username and public key are stored as key-value pairs in the DHT.<br><br>Nodes close to the new user (in terms of DHT distance) add the user to their routing tables. This process may involve a series of lookup and store operations in the DHT.                                       |
| 3. User Discovery      | X: Alice wants to message Bob.<br><br>Y: Alice queries the DHT for Bob's public key and network address.                                                                                | Alice's client hashes Bob's username to get a DHT key. It then performs a DHT lookup, which may involve multiple hops through the network.<br><br>The lookup returns Bob's public key and current network address (if online). Alice's client verifies the signature on this data to ensure authenticity.                                                                                                        |
| 4. Message Sending     | X: Alice composes a message to Bob.<br><br>Y: Alice's client encrypts the message with Bob's public key and signs it with her private key.                                              | Alice types her message. Her client prepares a data structure containing the message, a timestamp, and a unique message ID.<br><br>This structure is encrypted using Bob's public key (ensuring only Bob can read it) and then signed with Alice's private key (proving it's from Alice). The encrypted+signed package is prepared for transmission.                                                             |
| 5. Message Routing     | X: Alice's client determines the best route to Bob through the overlay network.<br><br>Y: The encrypted message is sent through this route, with each node forwarding it closer to Bob. | Alice's client uses its routing table to find the node closest to Bob's address. If a direct route isn't known, it may use a greedy algorithm to forward to the closest known node.<br><br>Each node along the path repeats this process, gradually moving the message closer to Bob in the network topology. Nodes may use techniques like parallel lookups or iterative routing to optimize this process.      |
| 6. Message Reception   | X: Bob's client receives the encrypted message.<br><br>Y: Bob's client verifies Alice's signature and decrypts the message with Bob's private key.                                      | Bob's client receives the message package. It first verifies the integrity of the package using a hash.<br><br>It then uses Alice's public key (retrieved from the DHT if not cached) to verify the signature, ensuring the message is truly from Alice. Finally, it uses Bob's private key to decrypt the message content.                                                                                      |
| 7. Offline Messaging   | X: Alice sends a message when Bob is offline.<br><br>Y: The message is stored in the DHT, associated with Bob's public key.                                                             | Alice's client attempts to send a message but can't locate Bob's current network address.<br><br>Instead, it wraps the encrypted message in another layer of encryption using Bob's public key. This package is then stored in the DHT using a key derived from Bob's public key and a timestamp. Multiple nodes may store copies for redundancy.                                                                |
| 8. Coming Online       | X: Bob comes online.<br><br>Y: Bob's client queries the DHT for any messages stored for him and retrieves them.                                                                         | When Bob's client connects to the network, it announces its presence by updating its entry in the DHT.<br><br>It then performs a DHT lookup for any messages stored under keys derived from its public key. It downloads these messages, decrypts them, verifies signatures, and presents them to Bob. It then sends confirmations allowing the storing nodes to delete the messages.                            |
| 9. Group Chat Creation | X: Alice creates a group chat.<br><br>Y: A group identifier is generated and broadcast to invited members.                                                                              | Alice's client generates a unique group ID (e.g., a UUID) and a symmetric encryption key for the group.<br><br>It creates invitation messages for each group member, containing the group ID and key, encrypted with each member's public key. These invitations are sent through the network to each member. The group's existence and metadata (but not the key) are stored in the DHT.                        |
