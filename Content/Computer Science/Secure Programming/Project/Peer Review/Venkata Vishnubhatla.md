## 1. Project Overview
- **Group Members:**
  - Bradley Hill
  - James Nguyen
  - Natanand Akomsoontorn
  - Vincent Scaffidi-Muta

- **Reviewers:**
  - [Reviewer Names Here]

## 2. Manual Code Review

### Architecture and Design

| **Aspect**                         | **Status**                | **Comments**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|------------------------------------|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Protocol Implementation Adherence** | ⚠️ Partially Adhered      | The implementation largely follows the OLAF/Neighbourhood protocol specifications, particularly in aspects like message signing, encryption, and routing through peer servers. However, there is a significant issue with the **client update lists**. According to the protocol, the client update lists should consist of **lists of PEM-encoded public keys**. In the provided code, the `client_update` messages are sending **base64-encoded PEM keys** instead of lists of PEM-encoded keys. Specifically, in the `send_client_list_response` function, the `clients` are aggregated into sets within the `server_public_keys` dictionary and then converted to lists when constructing the JSON response. However, these public keys are base64-encoded strings rather than raw PEM-encoded keys. This discrepancy can lead to inconsistencies in JSON serialization and potential interoperability issues with other groups' implementations. Additionally, the protocol expects the `client_update` to include lists, but sets are used internally before conversion, which might introduce ordering issues or duplicates if not handled properly. This observation is based on reviewing the code, and it will need to be verified during dynamic analysis to assess its impact fully.                                                                                                                                                                     |
| **Security Measures**              | ⚠️ Partially Implemented    | The code incorporates several security measures as per the protocol, including the use of RSA for asymmetric encryption and AES for symmetric encryption. Message signing using RSA-PSS with SHA-256 is implemented to ensure data integrity and authenticity. However, concerns arise regarding the **access control** mechanisms, specifically related to the `is_server` variable. The `is_server` flag is used within the `ClientSession` class to differentiate between server and client sessions. In the `process_message` function, this flag determines whether certain security checks, such as `verify_all`, are applied. However, the exact role and enforcement of `is_server` in access control are unclear. If not properly managed, this flag could potentially allow unauthorized access or privilege escalation. For instance, if a client session inadvertently sets `is_server` to `True`, it might gain access to server-level functionalities that should be restricted. Additionally, there is no explicit role-based access control mechanism to enforce permissions based on user roles or session types. While public keys are being exchanged and verified, the overall access control framework might be vulnerable if the `is_server` flag is manipulated or not consistently enforced across all message handling functions. A thorough review of how `is_server` is set, managed, and utilized throughout the code is necessary to ensure it does not inadvertently weaken the system's security posture.                                                                                                                                                                 |

### Security-specific Checks

| **Aspect**                               | **Status**                 | **Comments**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|------------------------------------------|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Input Validation**                     | ⚠️ Insufficient             | Input validation is minimally implemented. For instance, the server does not thoroughly validate the structure and content of incoming JSON messages beyond basic type checks. In the client, user inputs for sending messages and file operations are not adequately sanitized, which could lead to injection attacks or processing of malformed data. Additionally, the `upload_file` and `download_file` functionalities lack comprehensive checks to ensure that only allowed file types and sizes are processed, potentially exposing the system to file-based attacks. Strengthening input validation across all message handlers and user inputs is essential to mitigate these risks. |
| **Access Control**                       | ⚠️ Potential Flaws         | The `is_server` variable is used within the `ClientSession` class to distinguish between server and client sessions. In the `process_message` function, this flag determines whether certain security checks, such as `verify_all`, are applied. However, its implementation raises questions about whether it effectively enforces access control. Specifically, if this flag is not properly managed, it could allow clients to gain unauthorized access to server-level functionalities by manipulating their session state. For example, a client could potentially set `is_server` to `True`, thereby bypassing client-specific security checks and accessing restricted operations. Furthermore, there is no explicit role-based access control mechanism to enforce permissions based on user roles or session types, which could lead to privilege escalation attacks. A more robust and explicit access control framework is necessary to ensure that only authorized entities can perform sensitive operations within the system. |
| **Cryptographic Implementations**        | ⚠️ Partially Correct        | The cryptographic implementations adhere to the protocol specifications in terms of key sizes and padding schemes. RSA with OAEP and PSS padding, along with AES in CBC mode, are correctly utilized for encryption and signing purposes. However, there are inconsistencies in how cryptographic functions are invoked and managed across the server and client. For example, the encryption and decryption functions in the client might not fully align with the server's expectations, potentially leading to interoperability issues. Additionally, the use of base64 encoding for keys and messages is correctly implemented, but ensuring that all cryptographic operations are securely managed and free from side-channel vulnerabilities requires further verification. |
| **Secure Data Storage and Transmission** | ⚠️ Partially Secure         | Data transmission is secured using WebSockets, but the implementation does not enforce the use of secure WebSockets (`wss://`), leaving the data potentially vulnerable to interception and man-in-the-middle attacks. The storage of uploaded files is handled with basic safeguards using `secure_filename`, but there is no encryption of stored files, which could expose sensitive data if the server is compromised. Moreover, the client does not verify the integrity of downloaded files beyond basic HTTP status checks, which might allow tampering during transmission. Enhancing data transmission security by enforcing `wss://` and implementing encryption for stored files would significantly improve the system's overall security posture. |

---

**Note:** This review focuses solely on sections 1 and 2 (Project Overview and Manual Code Review) as per your request. Further sections will be addressed in subsequent reviews.