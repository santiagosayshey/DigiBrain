> [!motivation] The Need for Secure Microarchitectures
> Modern computer systems rely on complex microarchitectures to optimize performance through features like caching, speculative execution, and out-of-order execution. However, these same features can **inadvertently create covert channels that attackers exploit to leak sensitive data**, compromising system security. Understanding and mitigating these vulnerabilities is crucial for designing secure hardware and software systems.

> [!idea] Covert Channels in Microarchitectures
> Covert channels are **unintended communication paths that allow information transfer in violation of security policies**. In microarchitectures, these channels arise from shared resources like caches, branch predictors, and memory buses. By manipulating and measuring the state of these shared resources, attackers can transmit data covertly, bypassing traditional security boundaries.
> - **Cache-Based Channels**: Attackers can encode data in cache access patterns, causing measurable differences in access times that receivers can observe.
> - **Branch Predictor Channels**: The branch predictor's state can be influenced to convey information, as mispredictions affect execution time.
> - **Memory Bus Contention**: Varying levels of memory bus contention can be used to signal data, as it impacts memory access latencies.

> [!example] Cache-Based Covert Channel: Inferring a Secret Number
> Consider a scenario with two processes, Process A and Process B, sharing a CPU cache.
> 1. Process A stores a secret number (e.g., 3) in memory and sets a pointer to that memory location.
> 2. Process A then accesses `array[secret_number]`, causing the cache line containing `array[3]` to be loaded into the cache.
> 3. Later, Process B, which cannot directly access the secret number, attempts to infer it by measuring cache access times.
> 4. Process B accesses `array[1]`, `array[2]`, and `array[3]`, measuring the time taken for each access.
> 5. Process B observes that accessing `array[3]` is significantly faster than accessing `array[1]` or `array[2]`.
> 6. Based on this timing difference, Process B infers that the secret number stored by Process A is likely 3.

> [!consider] Out-of-Order Execution: Reordering Instructions
> Out-of-order execution is a technique used by modern processors to optimize performance by executing instructions in a non-sequential order, based on their dependencies and the availability of resources.
> 
> Consider the following code example:
> ```c
> int a = 1;
> int b = 2;
> int c = a + b;
> int d = a * b;
> ```
> 
> The corresponding assembly code might look like:
> ```assembly
> mov eax, 1
> mov ebx, 2
> add ecx, eax, ebx
> mul edx, eax, ebx
> ```
> 
> However, with out-of-order execution, the processor might reorder the instructions based on dependencies:
> ```assembly
> mov eax, 1
> mov ebx, 2
> mul edx, eax, ebx
> add ecx, eax, ebx
> ```
> 
> In this reordered execution, the multiplication (`mul`) is performed before the addition (`add`) since it has no dependency on the addition's result.

> [!idea] Exploiting Out-of-Order Execution: Speculative Execution
> Out-of-order execution can be exploited through speculative execution attacks, such as Spectre and Meltdown.
> - Speculative execution allows the processor to execute instructions before knowing if they are needed, based on predicted branches.
> - If the prediction is incorrect, the speculatively executed instructions are discarded, but they may leave side effects in caches or other shared resources.
> - Attackers can manipulate the branch predictor to speculatively execute code that accesses sensitive data, leaving measurable side effects that can be used to infer the data.

> [!idea] Exploiting Out-of-Order Execution: Timing Side Channels
> Out-of-order execution can also enable timing side-channel attacks.
> - Instructions that depend on sensitive data may have different execution times based on the data's value.
> - By measuring the execution time of specific code sequences, attackers can infer sensitive information.
> - Out-of-order execution can amplify these timing differences, making it easier to distinguish between different data values.

