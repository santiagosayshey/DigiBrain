> [!motivation] Protecting Legacy Codebases 
> **Legacy codebases written in non-memory-safe languages** are vulnerable to exploits due to the lack of built-in memory safety mechanisms. These vulnerabilities can be exploited by attackers to gain unauthorized access, execute arbitrary code, or cause system crashes. Protecting these codebases is crucial to maintain the security and stability of the systems they support.

> [!idea] Exploit Mitigation Techniques
> Exploit mitigation techniques aim to **protect legacy codebases by making it harder for attackers to exploit vulnerabilities**, even if the underlying bugs cannot be fixed directly. The goal is to turn potential exploits into crashes, preventing the attacker from gaining control or causing further damage.
> 
> Key techniques include:
> - **Compiler-based defenses**: Compiler flags and settings that add runtime checks, canaries, and other protective measures.
> - **Runtime defenses**: Techniques like address space layout randomization (ASLR) and data execution prevention (DEP) that make it harder for attackers to predict memory layouts or execute injected code.
> - **Vulnerability detection**: Tools and techniques to identify and prioritize vulnerabilities in the codebase, allowing for targeted hardening efforts.

> [!consider] Limitations and Trade-offs
> While exploit mitigation techniques can significantly reduce the risk of successful exploitation, they have some limitations and trade-offs to consider:
> - **Performance overhead**: Some techniques, like runtime checks and randomization, can introduce performance overhead.
> - **Incomplete protection**: Mitigation techniques can make exploitation harder but may not eliminate all possible attack vectors.
> - **Compatibility issues**: Some legacy codebases may rely on specific memory layouts or behaviors that are broken by mitigation techniques, requiring careful testing and adaptation.

