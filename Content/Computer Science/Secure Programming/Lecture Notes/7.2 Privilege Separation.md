> [!motivation] Balancing Privileges in Programs
> Many **programs require elevated privileges** (e.g., running as root) to perform specific tasks, such as binding to ports below 1024. However, these programs **also need to execute non-privileged code** for tasks that don't require special permissions. Any vulnerabilities or **bugs in the non-privileged sections of the code can potentially be exploited by attackers to gain unauthorized elevated privileges**, compromising the security of the entire system.

> [!example] SSH Process Permissions and Potential Abuse
> SSH (Secure Shell) is a network protocol that allows secure remote access to a system. Here's an overview of how SSH works:
> 
> 1. The SSH server (`sshd`) listens on port 22 for incoming connections. Since ports below 1024 are privileged, `sshd` must run with root privileges.
> 2. When a user connects, `sshd` forks a new process to handle the user's session. This process also runs with root privileges initially.
> 3. The user provides their credentials, and if the authentication is successful, the SSH server process drops its privileges and assumes the user's identity (UID and GID).
> 4. The user's SSH session continues to run with the user's limited permissions.
> 
> However, the initial SSH process running with root privileges can be a potential target for abuse. If an attacker discovers a vulnerability in the SSH server process, they could exploit it to:
> 
> - Gain unauthorized access to the system
> - Elevate their privileges to root
> - Access, modify, or delete sensitive files and directories
> - Install malware or backdoors
> - Intercept and manipulate network traffic
> 
> The impact of such an attack can be severe, as the attacker gains unrestricted access to the system with the highest level of privileges.

> [!idea] Privilege Separation
> To mitigate the risks associated with processes running with elevated privileges, privilege separation can be applied. Privilege separation involves **splitting a program into two or more processes:**
> 
> 1. A privileged process (monitor) that runs with higher privileges and performs only the necessary privileged tasks.
> 2. One or more unprivileged processes (slaves) that handle the majority of the program's functionality and run with lower privileges.
> 
> The **unprivileged processes communicate with the privileged process to request privileged operations as needed.** This way, if an attacker exploits a vulnerability in the unprivileged process, the damage is limited, and the **attacker cannot directly gain elevated privileges.**
> 
> By applying privilege separation to SSH, the impact of potential vulnerabilities can be minimized, as the majority of the SSH session runs with the user's limited permissions.

> [!example] SSH Privilege Abuse: The RegreSSHion Vulnerability (CVE-2022-36367)
> The RegreSSHion vulnerability in OpenSSH versions 7.7 through 9.0 allowed attackers to bypass authentication and gain **unauthorized access to the SSH console by exploiting a race condition in the post-authentication process** cleanup.
> 
> Here's a detailed explanation of how the exploit works:
> 
> 1. The attacker connects to the SSH server, triggering the creation of a new SSH process running with root privileges.
> 2. During the authentication process, the attacker sends a specific sequence of characters that causes the SSH process to misbehave:
>    - The attacker sends an `AUTH_GSSAPI_RESPONSE` message containing malformed data.
>    - This message is sent immediately after the `SSH_MSG_NEWCOMPRESS` message, which is used to negotiate compression algorithms.
> 3. The malformed `AUTH_GSSAPI_RESPONSE` message triggers a race condition in the OpenSSH server:
>    - The server tries to process the `AUTH_GSSAPI_RESPONSE` message before completing the compression setup.
>    - This leads to a null pointer dereference, causing the SSH process to crash.
> 4. The attacker quickly sends another `SSH_MSG_NEWCOMPRESS` message before the SSH process fully terminates.
> 5. The SSH process fails to properly clean up the post-authentication state due to the race condition:
>    - The process is in an inconsistent state, with some parts already cleaned up and others still active.
>    - This leaves the attacker with an active SSH session without requiring valid credentials.
> 6. The attacker gains unauthorized access to the system with the privileges of the SSH process, which is running as root.
> 
> By exploiting the race condition, the attacker can bypass the authentication process and directly access the SSH console with root privileges. This completely bypasses the privilege separation security measures implemented in OpenSSH.
> 
> The RegreSSHion vulnerability highlights the importance of careful handling of post-authentication cleanup and proper management of process states to prevent race conditions that can lead to privilege abuse.

