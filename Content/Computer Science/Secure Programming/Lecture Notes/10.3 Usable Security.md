
> [!motivation] Is It Usable?
> Traditional security focuses on preventing breaches through technical controls, but **usable security** recognizes that security must work with human behavior, not against it.
> 
> **The Current Problem**:
> - Security tools force users to make too many complex decisions
> - Training and awareness can't fix fundamentally unusable security
> - Users rationally choose to bypass security that blocks work
> - Security teams blame users while ignoring design flaws
> 
> **Core Principles**:
> We measure usable security through three key metrics:
> - **Effectiveness**: Can users successfully complete security tasks?
> - **Efficiency**: How much effort do security actions require?
> - **Satisfaction**: Do users accept or resist security measures?
> 
> Good security should require minimal decisions, support natural workflows, and make secure behavior the easiest path.

> [!idea] Building Usable Security
> Security must be designed around how humans actually work, not how we wish they would work:
> 
> **Human Limitations**:
> - Finite mental energy for security decisions
> - Focus primarily on main work tasks
> - Follow paths of least resistance
> - Make worse decisions under pressure
> 
> **Design Principles**:
> - Make dangerous actions difficult
> - Make safe actions natural
> - Minimize required decisions
> - Provide clear, actionable choices
> 
> **Implementation Strategy**:
> Instead of rules like "Choose complex passwords", build systems where:
> - Password managers are built in
> - Biometrics are readily available
> - Multi-factor auth is streamlined
> - Recovery processes are clear
>
> The goal isn't perfect security - it's security that works reliably in practice because it aligns with natural human behavior.

> [!idea] Making Security Work
> Three types of non-compliance show why traditional security fails:
> 
> **Routine Non-Compliance**:
> When rules are routinely ignored because they're impractical:
> - Password changes too frequent
> - Security blocks basic work tasks
> - Procedures too complex for daily use
> 
> **Situational Non-Compliance**:
> When security is bypassed for specific situations:
> - Sharing credentials for urgent tasks
> - Skipping steps under deadline pressure
> - Using workarounds for special cases
> 
> **Exceptional Non-Compliance**:
> When users must break rules to do their jobs:
> - Security prevents necessary work
> - No approved way to handle edge cases
> - Critical business needs blocked
> 
> **Building Better Systems**:
> - Study why users bypass security
> - Design security that helps rather than blocks
> - Make secure behavior the easiest path
> - Build security into normal workflows
> - Support rather than punish users
> 
> Real security isn't about perfect compliance - it's about creating systems that users can and will actually use securely.

> [!consider] The Developer-User Security Divide
> Security fails when developers and users live in different realities:
> 
> **Developer Reality**:
> - Under pressure to ship features
> - See security as technical problem
> - Limited real security training
> - Rely on complex documentation
> - Stack Overflow over official docs
> - Little understanding of user workflows
> 
> **User Reality**:
> - Focused on primary job tasks
> - See security as interference
> - Face constant security decisions
> - Deal with poor documentation
> - Just want to get work done
> - Security blocks productivity
> 
> This disconnect creates systems that are:
> - Technically secure but practically unusable
> - Full of unnecessary user decisions
> - Designed for ideal rather than real use
> - Likely to be bypassed

> [!idea] Nielsen's Framework for Security
> Nielsen's heuristics provide clear principles for usable security:
> 
> **Core User Needs**:
> 1. **System Visibility**: Users must always know:
>    - Current security state
>    - What actions are available
>    - Consequences of choices
> 
> 2. **Real World Connection**:
>    - Use non-technical language
>    - Match user mental models
>    - Connect to familiar concepts
> 
> 3. **User Control**:
>    - Clear escape routes
>    - Reversible actions
>    - No security dead ends
> 
> **Practical Implementation**:
> 4. **Error Prevention**:
>    - Block dangerous actions
>    - Confirm risky choices
>    - Guide safe behavior
> 
> 5. **Recognition Over Recall**:
>    - Make options visible
>    - Don't rely on memory
>    - Clear context always
> 
> 6. **Flexibility with Control**:
>    - Support different skill levels
>    - Allow efficient workflows
>    - Maintain security boundaries
> 
> These principles create security that users can understand, use, and trust.

