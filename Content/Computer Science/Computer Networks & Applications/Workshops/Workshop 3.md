

> [!exercise]+ Exercise 1 - IP Subnets
>
> Are the two IP addresses 129.127.8.8 and 129.127.104.8 in the same subnet? Explain your answer.
>
> Are the two IP addresses 129.127.8.8/24 and 129.127.104.8/24 in the same subnet? Explain your answer.
>
> **Answers:**
>
> 1. To determine if these IP addresses belong to the same subnet, we need to consider the class of the addresses. The first octet of both addresses is 129, which falls within the range of 128 to 191, indicating that they are Class B addresses. In Class B addressing, the first two octets (129.127) represent the network portion. Since both addresses share the same network portion, we can conclude that they belong to the **same subnet**.
>
> 2. When given IP addresses with a /24 suffix, it means that the first 24 bits (or the first three octets) of the addresses represent the network portion. To determine if these addresses are part of the same subnet, we need to compare the first three octets. In this case, the third octet differs between the two addresses (8 and 104), which means that the network portions are different. Therefore, the addresses 129.127.8.8/24 and 129.127.104.8/24 belong to **different subnets**.


> [!exercise]+ Exercise 2 - IP Fragmentation
>
> A IPv4 router that has an incoming datagram of 1,600 bytes to send into an outgoing link that has an MTU of 500 bytes. The in-coming datagram is stamped with the identification number 291.
>
> - How many fragments will be generated?
> - What are the values in the various fields in the IP datagram(s) generated by the router?
>
> **Answer:**
>
> 1. Calculate the number of fragments:
>    - IP header size: 20 bytes
>    - Available payload size per fragment: 500 bytes (MTU) - 20 bytes (IP header) = 480 bytes
>    - Number of fragments = (Datagram size - IP header size) / Available payload size per fragment
>    - Number of fragments = (1600 - 20) / 480⌉ = 3.29 = **4 fragments**
>
> 2. Determine the values in the various fields of the generated IP datagrams:
>
>    | Fragment | Identification | Flags (MF) | Fragment Offset | Total Length |
>    |----------|----------------|------------|-----------------|--------------|
>    | 1        | 291            | 1          | 0               | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 2        | 291            | 1          | 60 (480 / 8)    | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 3        | 291            | 1          | 120 (960 / 8)   | 500 bytes (480 bytes payload + 20 bytes header) |
>    | 4        | 291            | 0          | 180 (1440 / 8)  | 180 bytes (160 bytes payload + 20 bytes header) |


> [!exercise]+ Exercise 3 - Forwarding
> Consider an IP network using 32-bit host addresses. Suppose a router has four links, numbered 0 to 3, and packets are to be forwarded to the link interfaces as follows:
>
> | _**Destination Address Range**_                                                                                             | _**Link Interface**_ |
> | --------------------------------------------------------------------------------------------------------------------------- | -------------------- |
> | 11100000 00000000 00000000 00000000     <br><br>                        through<br><br>11100000 00000000 11111111 11111111 | 0                    |
> | 11100000 00000001 00000000 00000000<br><br>                       through<br><br>11100000 00000001 11111111 11111111       | 1                    |
> | 11100000 00000010 00000000 00000000<br><br>                      through<br><br>11100001 11111111 11111111 11111111       | 2                    |
> | Otherwise                                                                                                                   | 3                    |
>
> - Write out a forwarding table, that uses longest prefix matching, and forwards packets to the correct link interfaces.
> - Describe how your forwarding table determines the appropriate link interface for the IP datagrams with destination addresses:
>   - 11111000 10010001 01010001 01010101
>   - 11100000 00000000 11000011 00111100
>   - 11100001 10000000 00010001 01110111
>
>**Answer:**
>
> Forwarding Table:
>
> | **Prefix** | **Link Interface** |
> | ------------ | -------------------- |
> | 11100000 00000000 | 0 |
> | 11100000 00000001 | 1 |
> | 11100000 0000001 | 2 |
> | 11100000 000001 | 2 |
> | 11100000 00001 | 2 |
> | 11100000 0001 | 2 |
> | 11100000 001 | 2 |
> | 11100000 01 | 2 |
> | 11100000 1 | 2 |
> | 11100001 | 2 |
> | * | 3 |
>
> The forwarding table uses longest prefix matching to determine the appropriate link interface for each destination address. The table is sorted by the length of the prefix, with the longest prefixes at the top.
>
> **Determining the link interface for the given IP datagrams:**
>
> 1. 11111000 10010001 01010001 01010101
>    - The longest matching prefix is *, which corresponds to link interface 3.
>
> 2. 11100000 00000000 11000011 00111100
>    - The longest matching prefix is 11100000 00000000, which corresponds to link interface 0.
>
> 3. 11100001 10000000 00010001 01110111
>    - The longest matching prefix is 11100001, which corresponds to link interface 2.

> [!exercise]+ Exercise 4 - Routing Algorithms
> ![[Screenshot 2017-04-26 13.30.40 1.png]]
> 
> Using node E as your base, show how node E builds its routing table, using Dijkstra's algorithm and then using Distance Vector.
> 
> ---
> 
> **Dijkstra's Algorithm Routing Table for Node E**
>
> | Step | Known Set (N') | D(A) | D(B) | D(C) | D(D) | D(E) |
> |------|----------------|------|------|------|------|------|
> | 0 (Through E)    | E              | 8, E    | ∞     | ∞     | 3, E | 0, E |
> | 1 (Through D)    | E, D           | 8, E    | 5, D  | ∞     | 3, E | 0, E |
> | 2 (Through B)    | E, D, B        | 7, B    | 5, D  | 7, B  | 3, E | 0, E |
> | 3 (Complete)     | E, D, B, A, C  | 7, B    | 5, D  | 7, B  | 3, E | 0, E |
>
> Each step updates the shortest path known so far from E to all other nodes using the least cost paths through the nodes that have been finalized (in N').
> 
> **Distance Vector Routing Table for Node E**
>
> The evolution of node E's routing table through distance vector exchanges:
> 
> | Step | Node | D(A) | D(B) | D(C) | D(D) | D(E) |
> |------|------|------|------|------|------|------|
> | 0 (Initial) | E    | ∞    | ∞    | ∞    | 3, E | 0, E |
> | 1 (From D)   | E    | ∞    | 5, D | ∞    | 3, E | 0, E |
> | 2 (From B)   | E    | 7, B | 5, D | 7, B | 3, E | 0, E |
>
> Node E continuously receives and integrates distance vector updates from its neighbors, progressively refining the distances to all nodes based on the most efficient routes communicated by its neighbors.

